# A0135805H
###### \java\guitests\AddCommandTest.java
``` java
/**
 * Test the add command via GUI.
 * Note:
 *      Order-ness of the tasks is not tested.
 *      Invalid command input is not tested.
 */
public class AddCommandTest extends TodoListGuiTest {

    @Test
    public void add_initialData() {
        //Test if the data has correctly loaded the data into view.
        assertTrue(todoListView.isDisplayedCorrectly());
    }

    @Test
    public void add_addTasks() {
        //Add a task
        ImmutableTask task1 = TaskFactory.task();
        executeAddTestHelper(task1);

        //Add another task
        ImmutableTask task2 = TaskFactory.task();
        executeAddTestHelper(task2);

        //Add duplicated task
        executeAddTestHelper(task2);

        //Add an overdue task
        ImmutableTask task3 = TaskBuilder.name("Overdue Task")
                .due(LocalDateTime.now().minusHours(3))
                .build();
        executeAddTestHelper(task3);
    }

    @Test
    public void add_addEvents() {
        //Add an event
        ImmutableTask event1 = TaskFactory.event();
        executeAddTestHelper(event1);

        //Add an overdue event.
        ImmutableTask event2 = TaskBuilder.name("Overdue Event")
                .event(LocalDateTime.now().minusHours(3), LocalDateTime.now().minusHours(2))
                .build();
        executeAddTestHelper(event2);

        //Add an ongoing event.
        ImmutableTask event3 = TaskBuilder.name("Ongoing Event")
                .event(LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(2))
                .build();
        executeAddTestHelper(event3);

        //Add another event
        ImmutableTask event4 = TaskFactory.event();
        executeAddTestHelper(event4);

        //Add duplicated event
        executeAddTestHelper(event1);
    }

    @Test
    public void add_addManyRandom() {
        //Add a long list of random task, which in the end spans at least 2 pages.
        List<ImmutableTask> randomTaskList = TaskFactory.list(15, 25);
        randomTaskList.forEach(this::executeAddTestHelper);
    }

    @Test
    public void add_invalidParameters() {
        //No title
        assertErrorViewDisplayed("add /d tomorrow");

        //Wrong date
        assertErrorViewDisplayed("add some task /d hehe");

        //Invalid tag
        assertErrorViewDisplayed("add invalid tag /t oops!");
    }

    /* Helper Methods */
    /**
     * Gets the index of the newly added task.
     */
    private int getNewlyAddedTaskIndex() {
        return TestUtil.compareAndGetIndex(previousTasksFromView, todoListView.getImmutableTaskList());
    }

    /**
     * A helper method to run the entire add command process and testing.
     */
    private void executeAddTestHelper(ImmutableTask task) {
        updatePreviousTaskListFromView();
        executeAddCommand(task);
        assertCorrectnessHelper(task);
    }

    /**
     * Executes an add command given a {@code task}
     */
    private void executeAddCommand(ImmutableTask task) {
        String commandText = CommandGeneratorUtil.generateAddCommand(task);
        runCommand(commandText);
    }

    /**
     * Asserts that specific view scenarios are displayed correctly.
     */
    private void assertCorrectnessHelper(ImmutableTask newTask) {
        int addedIndex = getNewlyAddedTaskIndex();
        TaskCardViewHandle taskCardHandle = todoListView.getTaskCardViewHandle(addedIndex);

        assertAddSuccess(taskCardHandle, newTask, addedIndex);
        assertCorrectFeedbackDisplayed(newTask);
        assertCollapsed(taskCardHandle);
    }

    /**
     * Check the two following areas:
     *      1. If the {@code task} added to the view is reflected correctly in it's own task card view.
     *      2. If the remaining task cards are present and still displayed correctly in their own
     *         respective card views.
     */
    private void assertAddSuccess(TaskCardViewHandle newTaskHandle, ImmutableTask newTask, int addedListIndex) {
        int expectedDisplayedIndex = UiTestUtil.convertToUiIndex(addedListIndex);

        //Test for the newly added task.
        assertTrue(newTaskHandle.isDisplayedCorrectly(expectedDisplayedIndex, newTask));

        //Test for remaining tasks.
        assertTrue(todoListView.isDisplayedCorrectly());
    }

    /**
     * Check if the correct feedback message for adding has been displayed to the user.
     */
    private void assertCorrectFeedbackDisplayed(ImmutableTask task) {
        assertFeedbackMessage("");
    }

    /**
     * Tasks should be collapsed when newly added.
     * Checks the case where if the task is collapsible,
     * then the task is in the collapsed state when newly added.
     */
    private void assertCollapsed(TaskCardViewHandle newTask) {
        if (newTask.isTaskCollapsible()) {
            assertTrue(newTask.isTaskCardCollapsed());
        }
    }
}
```
###### \java\guitests\DeleteCommandTest.java
``` java
/**
 * Test the delete command via GUI.
 * Note:
 *      Invalid indices are not tested.
 */
public class DeleteCommandTest extends TodoListGuiTest {

    @Override
    protected TodoList getInitialData() {
        return getInitialDataHelper(10, 20);
    }

    @Test
    public void delete_correctBoundary() {
        //delete the last item in the list
        executeDeleteHelper(initialTaskData.size());

        //delete the first in the list (note that we initialised the size to be > 2.
        executeDeleteHelper(1);

    }

    @Test
    public void delete_allTasks() {
        //delete all the elements, until you have none left.
        Random random = new Random();
        int remainingTasks = initialTaskData.size();
        while (remainingTasks > 0) {
            int randomChoice = random.nextInt(remainingTasks--) + 1;
            executeDeleteHelper(randomChoice);
        }
    }

    @Test
    public void delete_invalidCommands() {
        //Missing Index
        assertErrorViewDisplayed("delete ");

        //Invalid Index
        assertErrorViewDisplayed("delete a");
    }

    /**
     * A helper method to run the entire delete command process and testing.
     */
    private void executeDeleteHelper(int displayedIndex) {
        ImmutableTask deletedTask = executeDeleteCommand(displayedIndex);
        assertDeleteSuccess(deletedTask);
        assertCorrectFeedbackDisplayed(deletedTask);
    }

    /**
     * Deletes a task from the to-do list view, and returns the deleted task for verification.
     */
    private ImmutableTask executeDeleteCommand(int displayedIndex) {
        int listIndex = UiTestUtil.convertToListIndex(displayedIndex);
        String commandText = CommandGeneratorUtil.generateDeleteCommand(displayedIndex);
        ImmutableTask deletedTask = todoListView.getTask(listIndex);

        runCommand(commandText);
        return deletedTask;
    }

    /**
     * Check if the {@code task} deleted from the view is reflected correctly (i.e. it's no longer there)
     * and check if the remaining tasks are displayed correctly.
     */
    private void assertDeleteSuccess(ImmutableTask deletedTask) {
        //Check if the task is really deleted.
        assertFalse(todoListView.getImmutableTaskList().contains(deletedTask));

        //Test if the remaining list is correct.
        assertTrue(todoListView.isDisplayedCorrectly());
    }

    /**
     * Check if the correct feedback message for deleting has been displayed to the user.
     */
    private void assertCorrectFeedbackDisplayed(ImmutableTask task) {
        assertFeedbackMessage("\'" + task.getTitle() + "\' successfully deleted!");
    }

}
```
###### \java\guitests\FindCommandTest.java
``` java
/**
 * Tests the find command in GUI setting.
 * In particular, only the {@link SearchStatusViewHandle} will be tested for now.
 * We will rely {@link seedu.todo.logic.commands.FindCommandTest} to test the remaining part of finding.
 */
public class FindCommandTest extends TodoListGuiTest {

    @Override
    protected TodoList getInitialData() {
        List<ImmutableTask> tasks = new ArrayList<>();

        tasks.add(TaskBuilder.name("Project dynamite").build());
        tasks.add(TaskBuilder.name("Dynamite little bombarded bomb")
                .event(LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(3))
                .pinned()
                .build());
        tasks.add(TaskBuilder.name("Pikachu pika pika")
                .due(LocalDateTime.now().plusDays(1))
                .build());
        tasks.add(TaskBuilder.name("Kaboom")
                .due(LocalDateTime.now().plusDays(1))
                .tagged("dynamite", "pikachu")
                .build());

        return getInitialDataHelper(tasks);
    }

    @Test
    public void find_noResults() {
        runCommand("find happy birthday to you");

        assertEquals("happy, birthday, to, you", searchStatusView.getSearchTermText());
        assertTrue(searchStatusView.isVisible());
        assertTrue(searchStatusView.doesSearchCountMatch(0));
    }

    @Test
    public void find_taskNameResults() {
        runCommand("f dynamite");

        assertEquals("dynamite", searchStatusView.getSearchTermText());
        assertTrue(searchStatusView.isVisible());
        assertTrue(searchStatusView.doesSearchCountMatch(2));
    }

    @Test
    public void find_tagResults() {
        runCommand("f /t pika dynamite");

        assertEquals("pika, dynamite", searchStatusView.getSearchTermText());
        assertTrue(searchStatusView.isVisible());
        assertTrue(searchStatusView.doesSearchCountMatch(1));
    }
}
```
###### \java\guitests\guihandles\CommandErrorViewHandle.java
``` java
/**
 * A handler for retrieving error messages to user via {@link seedu.todo.ui.view.CommandErrorView}
 */
public class CommandErrorViewHandle extends GuiHandle {
    /* Constants */
    private static final String NON_FIELD_ERROR_GRID_ID = "#nonFieldErrorGrid";
    private static final String FIELD_ERROR_GRID_ID = "#fieldErrorGrid";
    private static final String ERROR_VIEW_PLACEHOLDER_ID = "#commandErrorViewPlaceholder";

    /**
     * Constructs a handle to the {@link CommandFeedbackViewHandle}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public CommandErrorViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /* Interfacing Methods */
    /**
     * Returns true if the placeholder is visible.
     */
    public boolean isVisible() {
        Node placeholder = getNode(ERROR_VIEW_PLACEHOLDER_ID);
        return UiTestUtil.isDisplayed(placeholder);
    }

    /**
     * Returns true if the placeholder has messages displayed.
     */
    public boolean hasErrorMessages() {
        int numOfErrorMessages = 0;

        GridPane errorField = (GridPane) getNode(FIELD_ERROR_GRID_ID);
        GridPane nonErrorField = (GridPane) getNode(NON_FIELD_ERROR_GRID_ID);

        numOfErrorMessages += errorField.getChildren().size() / 2;
        numOfErrorMessages += nonErrorField.getChildren().size() / 2;

        return numOfErrorMessages > 0;
    }

    /**
     * Returns true if there are error messages displayed on the user's screen.
     */
    public boolean isErrorMessagesDisplayed() {
        return isVisible() && hasErrorMessages();
    }
}
```
###### \java\guitests\guihandles\CommandFeedbackViewHandle.java
``` java
/**
 * A handler for retrieving feedback to user via {@link CommandFeedbackView}
 */
public class CommandFeedbackViewHandle extends GuiHandle {
    /* Constants */
    public static final String FEEDBACK_VIEW_LABEL_ID = "#commandFeedbackLabel";

    /**
     * Constructs a handle to the {@link CommandFeedbackViewHandle}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public CommandFeedbackViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /**
     * Get the feedback {@link Label} object.
     */
    private Label getFeedbackLabel() {
        return (Label) getNode(FEEDBACK_VIEW_LABEL_ID);
    }

    /**
     * Get the text that is displayed on this {@link #getFeedbackLabel()} object.
     */
    public String getText() {
        return getFeedbackLabel().getText();
    }

```
###### \java\guitests\guihandles\CommandInputViewHandle.java
``` java
/**
 * A handle to the {@link CommandInputView}'s command text box in the GUI.
 */
public class CommandInputViewHandle extends GuiHandle {
    /* Constants */
    private static final String COMMAND_INPUT_FIELD_ID = "#commandTextField";

    /**
     * Constructs a handle to the {@link CommandInputView}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public CommandInputViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /* Interfacing Methods */
    /**
     * Types in the supplied command into the text box in {@link CommandInputView}.
     *      Note: any existing text in the text box will be replaced.
     *      Note: this method will not execute the command. See {@link #runCommand(String)}.
     * @param command Command text to be supplied into the text box.
     */
    public void enterCommand(String command) {
        setTextAreaText(COMMAND_INPUT_FIELD_ID, command);
    }

    /**
     * Gets the command text that is inside the text box in {@link CommandInputView}.
     * @return A command text.
     */
    public String getCommandInput() {
        return getTextAreaText(COMMAND_INPUT_FIELD_ID);
    }

```
###### \java\guitests\guihandles\FilterBarViewHandle.java
``` java
/**
 * A handler for indicating which view the user is at via {@link seedu.todo.ui.view.FilterBarView}
 */
public class FilterBarViewHandle extends GuiHandle {
    /* Constants */
    private static final String FILTER_BAR_VIEW_ID = "#filterBarView";

    /**
     * Constructs a handle to the {@link seedu.todo.ui.view.HelpView}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public FilterBarViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /**
     * Gets the labels of all the view categories on the filter bar view
     */
    public List<String> getFilterBarViewLabels() {
        List<HBox> tagViewBoxes = getFilterViewLabelContainers();
        return tagViewBoxes.stream()
                .map(this::getTextFromHBox)
                .collect(Collectors.toList());
    }

    /**
     * Gets the selected filter view category.
     */
    public String getSelectedFilterView() {
        List<HBox> tagViewBoxes = getFilterViewLabelContainers();
        List<HBox> selectedViewBoxes = tagViewBoxes.stream()
                .filter(hBox -> hBox.getStyleClass().contains("selected"))
                .collect(Collectors.toList());

        //Just to check if there is only 1 item selected.
        assert selectedViewBoxes.size() == 1;

        //Get the correct item.
        HBox selectedItem = selectedViewBoxes.get(0);
        return getTextFromHBox(selectedItem);
    }

    /* Helper Methods */
    /**
     * Get all the displayed filter view labels contained in the respective HBoxes.
     */
    private List<HBox> getFilterViewLabelContainers() {
        FlowPane filterBarView = (FlowPane) getNode(FILTER_BAR_VIEW_ID);
        return filterBarView.getChildren()
                .stream()
                .map(node -> (HBox) node)
                .collect(Collectors.toList());
    }

    /**
     * Extracts all the labels from the single {@code hBox} view.
     */
    private List<Label> getLabelsFromHBox(HBox hBox) {
        return hBox.getChildren()
                .stream()
                .map(node -> ((Label) node))
                .collect(Collectors.toList());
    }

    /**
     * Get a single text string from all the {@code labels}.
     */
    private String getTextFromLabels(List<Label> labels) {
        List<String> strings = labels.stream()
                .map(Labeled::getText)
                .collect(Collectors.toList());

        StringBuilder builder = new StringBuilder();
        strings.forEach(builder::append);
        return builder.toString();
    }

    /**
     * Extracts the text from the labels contained in {@code hBox}.
     */
    private String getTextFromHBox(HBox hBox) {
        List<Label> labels = getLabelsFromHBox(hBox);
        return getTextFromLabels(labels);
    }
}
```
###### \java\guitests\guihandles\GlobalTagViewHandle.java
``` java
/**
 * A handler for retrieving the global list of tags via {@link seedu.todo.ui.view.GlobalTagView}
 */
public class GlobalTagViewHandle extends GuiHandle {
    /* Constant */
    private static final String TAG_VIEW_PANEL_ID = "#globalTagViewPanel";
    private static final String TAGS_CONTAINER_ID = "#tagFlowPane";

    /**
     * Constructs a handle to the {@link seedu.todo.ui.view.GlobalTagView}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public GlobalTagViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /* Interfacing Methods */
    /**
     * Returns true if the placeholder is visible.
     */
    public boolean isVisible() {
        Node view = getNode(TAG_VIEW_PANEL_ID);
        return UiTestUtil.isDisplayed(view);
    }

    /**
     * Gets a list of tag names that are displayed in this view.
     */
    public List<String> getDisplayedTags() {
        FlowPane flowPane = (FlowPane) getNode(TAGS_CONTAINER_ID);
        return flowPane.getChildren()
                .stream()
                .map(node -> ((Label) node).getText())
                .collect(Collectors.toList());
    }
}
```
###### \java\guitests\guihandles\HelpViewHandle.java
``` java
/**
 * A handler for retrieving help view details to user via {@link seedu.todo.ui.view.HelpView}
 */
public class HelpViewHandle extends GuiHandle {
    /* Constants */
    private static final String HELP_GRID_ID = "#helpGrid";
    private static final String HELP_VIEW_ID = "#helpPanelView";

    /**
     * Constructs a handle to the {@link seedu.todo.ui.view.HelpView}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public HelpViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /**
     * Returns true if the placeholder is visible.
     */
    public boolean isVisible() {
        Node view = getNode(HELP_VIEW_ID);
        return UiTestUtil.isDisplayed(view);
    }

    /**
     * Returns the number of help items displayed.
     */
    public int numberOfItemsDisplayed() {
        GridPane helpGrid = (GridPane) getNode(HELP_GRID_ID);
        return helpGrid.getChildren().size() / 2;
    }

    /**
     * Returns a set of displayed help items, where each item represents an array of:
     *      [description, command keyword, command arguments]
     */
    private List<String[]> getDisplayedHelpItems() {
        List<String[]> displayedHelpItems = new ArrayList<>();
        GridPane helpGrid = (GridPane) getNode(HELP_GRID_ID);
        List<Node> helpGridNodes = helpGrid.getChildren();

        for (int i = 0; i < helpGridNodes.size(); i += 2) {
            String[] helpItem = new String[3];
            List<Node> commandDetails = ((TextFlow) helpGridNodes.get(i+1)).getChildren();
            helpItem[0] = ((Text) helpGridNodes.get(i)).getText();
            helpItem[1] = ((Text) commandDetails.get(0)).getText();
            helpItem[2] = ((Text) commandDetails.get(1)).getText();

            //Because there is a space between command keyword and argument in the argument text,
            //we need to remove it.
            helpItem[2] = helpItem[2].substring(1, helpItem[2].length());
            displayedHelpItems.add(helpItem);
        }
        return displayedHelpItems;
    }

    /**
     * Returns true if this help view displays all the help items correctly, by checking if the data provided
     * by {@code commandSummaries} matches to what is displayed.
     */
    public boolean isHelpItemsDisplayedCorrectly(List<String[]> commandSummaries) {
        List<String[]> displayedCommandSummaries = getDisplayedHelpItems();

        for (int i = 0; i < commandSummaries.size(); i++) {
            String[] expectedCommandSummary = commandSummaries.get(i);
            String[] displayedCommandSummary = displayedCommandSummaries.get(i);
            if (!Arrays.equals(expectedCommandSummary, displayedCommandSummary)) {
                return false;
            }
        }
        return true;
    }
}
```
###### \java\guitests\guihandles\SearchStatusViewHandle.java
``` java

import guitests.GuiRobot;
import javafx.scene.Node;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import seedu.todo.TestApp;
import seedu.todo.testutil.UiTestUtil;

/**
 * A handler for retrieving the status of the search result via {@link seedu.todo.ui.view.SearchStatusView}
 */
public class SearchStatusViewHandle extends GuiHandle {
    /* Constants */
    private static final String SEARCH_STATUS_VIEW_ID = "#searchStatusView";
    private static final String SEARCH_TERM_LABEL_ID = "#searchTerm";
    private static final String SEARCH_COUNT_LABEL_ID = "#searchCount";

    /**
     * Constructs a handle to the {@link seedu.todo.ui.view.SearchStatusView}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public SearchStatusViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /* Interfacing Methods */
    /**
     * Returns true if the view is visible.
     */
    public boolean isVisible() {
        Node view = getNode(SEARCH_STATUS_VIEW_ID);
        return UiTestUtil.isDisplayed(view);
    }

    /**
     * Returns the search terms displayed in the view, separated by comma.
     */
    public String getSearchTermText() {
        Text text = (Text) getNode(SEARCH_TERM_LABEL_ID);
        return text.getText();
    }

    /**
     * Returns true if the number of items {@code count} found is displayed correctly in this view.
     */
    public boolean doesSearchCountMatch(int count) {
        Text text = (Text) getNode(SEARCH_COUNT_LABEL_ID);
        String actual = text.getText();
        String expected;
        if (count == 1) {
            expected = "1 task found";
        } else {
            expected = count + " tasks found";
        }
        return expected.equals(actual);
    }
}
```
###### \java\guitests\guihandles\TaskCardViewHandle.java
``` java
/**
 * Provides a handle to a {@link TaskCardView}
 * that exists in {@link TodoListView}
 */
public class TaskCardViewHandle extends GuiHandle {

    /* Constants */
    private static final String TITLE_LABEL_ID = "#titleLabel";
    private static final String DESCRIPTION_LABEL_ID = "#descriptionLabel";
    private static final String DATE_LABEL_ID = "#dateLabel";
    private static final String LOCATION_LABEL_ID = "#locationLabel";

    private static final String DESCRIPTION_BOX_ID = "#descriptionBox";
    private static final String DATE_BOX_ID = "#dateBox";
    private static final String LOCATION_BOX_ID = "#locationBox";
    private static final String TITLE_PANE_ID = "#titleFlowPane";

    private static final String PIN_IMAGE_ID = "#pinImage";

    private static final String TYPE_LABEL_ID = "#typeLabel";
    private static final String MOREINFO_LABEL_ID = "#moreInfoLabel";

    /* Variables */
    private Node rootNode;

    /**
     * Constructs a handle for {@link TaskCardView}.
     *
     * @param guiRobot The GUI test robot.
     * @param primaryStage The main stage that is executed from the application's UI.
     * @param rootNode Node that houses the contents of this Task Card.
     */
    public TaskCardViewHandle(GuiRobot guiRobot, Stage primaryStage, Node rootNode){
        super(guiRobot, primaryStage, null);
        this.rootNode = rootNode;
    }

    /* Task Property Getters */
    public String getDisplayedTitle() {
        return getTextFromLabel(TITLE_LABEL_ID);
    }

    public String getDisplayedDescription() {
        return getTextFromLabel(DESCRIPTION_LABEL_ID);
    }

    public String getDisplayedDateText() {
        return getTextFromLabel(DATE_LABEL_ID);
    }

    public String getDisplayedLocation() {
        return getTextFromLabel(LOCATION_LABEL_ID);
    }

    public String getDisplayedTypeLabel() {
        return getTextFromLabel(TYPE_LABEL_ID);
    }

```
###### \java\guitests\guihandles\TaskCardViewHandle.java
``` java
    public boolean getMoreInfoLabelVisibility() {
        Node moreInfoLabel = getNode(MOREINFO_LABEL_ID);
        return UiTestUtil.isDisplayed(moreInfoLabel);
    }

    public boolean getDescriptionBoxVisibility() {
        Node descriptionBox = getNode(DESCRIPTION_BOX_ID);
        return UiTestUtil.isDisplayed(descriptionBox);
    }

    public boolean getDateBoxVisibility() {
        Node dateBox = getNode(DATE_BOX_ID);
        return UiTestUtil.isDisplayed(dateBox);
    }

    public boolean getLocationBoxVisibility() {
        Node locationBox = getNode(LOCATION_BOX_ID);
        return UiTestUtil.isDisplayed(locationBox);
    }

    public boolean getPinImageVisibility() {
        Node pinImage = getNode(PIN_IMAGE_ID);
        return UiTestUtil.isDisplayed(pinImage);
    }

    public boolean isSelectedStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "selected");
    }

    public boolean isCompletedStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "completed");
    }

    public boolean isOverdueStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "overdue");
    }

    public boolean isOngoingStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "ongoing");
    }

    public boolean isTaskCardCollapsed() {
        return UiTestUtil.containsStyleClass(rootNode, "collapsed");
    }

    public boolean isTaskCollapsible() {
        return !getDisplayedDescription().isEmpty();
    }

    /* General Methods */
    /**
     * Checks if the supplied index matches to what this node displays.
     * To be used for nodes filtering.
     */
    public boolean matchesTask(int displayedIndex) {
        return getDisplayedTitle().startsWith(displayedIndex + ". ");
    }

    /**
     * Given an {@link ImmutableTask} and a displayed index, check if this view is displayed correctly.
     * @param displayedIndex Index displayed in the view.
     * @param task Task displayed in the view.
     * @return Returns true only if and only if the elements in this view is displayed correctly.
     * TODO: Maybe we do not need this at all.
     */
    public boolean isDisplayedCorrectly(int displayedIndex, ImmutableTask task) {
        //JUnit Assertion Test: To know which test are failing in detail
        assertTrue(isTitleCorrect(displayedIndex, task));
        assertTrue(isDescriptionCorrect(task));
        assertTrue(isTaskCardCollapsibleStateCorrect());
        assertTrue(isCompletedDisplayCorrect(task));
        assertTrue(isDateTextCorrect(task));
        assertTrue(isLocationCorrect(task));
        assertTrue(isTypeDisplayCorrect(task));
        assertTrue(isPinDisplayCorrect(task));
        assertTrue(isOverdueDisplayCorrect(task));
        assertTrue(isOngoingDisplayCorrect(task));
        return true;
    }

    private boolean isTitleCorrect(int displayedIndex, ImmutableTask task) {
        String expected = convertToDisplayedTitle(displayedIndex, task.getTitle());
        String actual = getDisplayedTitle();
        return expected.equals(actual);
    }

    private boolean isDescriptionCorrect(ImmutableTask task) {
        java.util.Optional<String> description = task.getDescription();

        if (description.isPresent()) {
            //If there is a task description, it should match with the displayed description.
            String expected = description.get();
            String actual = getDisplayedDescription();
            return expected.equals(actual);
        } else {
            //Description should be hidden when there is no description.
            boolean expected = false;
            boolean actual = getDescriptionBoxVisibility();
            return expected == actual;
        }
    }

    private boolean isDateTextCorrect(ImmutableTask task) {
        java.util.Optional<LocalDateTime> startTime = task.getStartTime();
        java.util.Optional<LocalDateTime> endTime = task.getEndTime();

        TimeUtil timeUtil = new TimeUtil();

        String displayedDateText = getDisplayedDateText();
        String expectedDateText;

        if (!startTime.isPresent() && !endTime.isPresent()) {
            //Date box should be hidden when there is no start and end time.
            return !getDateBoxVisibility();
        } else if (startTime.isPresent() && endTime.isPresent()) {
            //When start and end date are available, expect event format
            expectedDateText = timeUtil.getEventTimeText(startTime.get(), endTime.get());
        } else if (endTime.isPresent()) {
            //When only end time is present, expect deadline format
            expectedDateText = timeUtil.getTaskDeadlineText(endTime.get());
        } else {
            //Otherwise, illegal date state.
            throw new IllegalStateException("Start time is present, but end time is not.");
        }
        return expectedDateText.equals(displayedDateText);
    }

    private boolean isLocationCorrect(ImmutableTask task) {
        java.util.Optional<String> location = task.getLocation();

        if (location.isPresent()) {
            //If there is a location, it should match with the displayed location.
            String expected = location.get();
            String actual = getDisplayedLocation();
            return expected.equals(actual);
        } else {
            //Description should be hidden when there is no description.
            boolean expected = false;
            boolean actual = getLocationBoxVisibility();
            return expected == actual;
        }
    }

    private boolean isPinDisplayCorrect(ImmutableTask task) {
        boolean expected = task.isPinned();
        boolean actual = getPinImageVisibility();
        return expected == actual;
    }

    private boolean isCompletedDisplayCorrect(ImmutableTask task) {
        boolean expected = task.isCompleted();
        boolean actual = isCompletedStyleApplied();
        return expected == actual;
    }

    private boolean isOverdueDisplayCorrect(ImmutableTask task) {
        java.util.Optional<LocalDateTime> endTime = task.getEndTime();
        boolean actual = isOverdueStyleApplied();
        boolean expected;

        if (endTime.isPresent()) {
            expected = seedu.todo.testutil.TimeUtil.isOverdue(endTime.get());
        } else {
            expected = false;
        }
        return expected == actual;
    }

    private boolean isOngoingDisplayCorrect(ImmutableTask task) {
        java.util.Optional<LocalDateTime> startTime = task.getStartTime();
        java.util.Optional<LocalDateTime> endTime = task.getEndTime();
        boolean actual = isOngoingStyleApplied();
        boolean expected;

        if (startTime.isPresent() && endTime.isPresent()) {
            expected = seedu.todo.testutil.TimeUtil.isOngoing(startTime.get(), endTime.get());
        } else {
            expected = false;
        }
        return expected == actual;
    }

    private boolean isTypeDisplayCorrect(ImmutableTask task) {
        String actual = getDisplayedTypeLabel();
        String expected;

        if (task.isEvent()) {
            expected = "Event";
        } else {
            expected = "Task";
        }

        return expected.equals(actual);
    }

    public boolean isTaskCardCollapsibleStateCorrect() {
        boolean collapsedStyleApplied = UiTestUtil.containsStyleClass(rootNode, "collapsed");
        boolean moreInfoLabelDisplayed = UiTestUtil.isDisplayed(getNode(MOREINFO_LABEL_ID));

        if (isTaskCollapsible()) {
            return collapsedStyleApplied == moreInfoLabelDisplayed;
        } else {
            return !moreInfoLabelDisplayed;
        }
    }

    /* View Elements Helper Methods */
```
###### \java\guitests\guihandles\TaskCardViewHandle.java
``` java
    /**
     * Gets a text from the node with {@code fieldId}.
     *
     * @param fieldId To get the node's text from.
     * @return Returns the text presented in the node.
     */
    private String getTextFromLabel(String fieldId) {
        return ((Label) getNode(fieldId)).getText();
    }

    /**
     * Converts {@code actualTitle} to a displayed title with the relevant {@code displayedIndex}.
     * @param displayedIndex The index that is shown on the title displayed to the user.
     * @param actualTitle The actual title of the task.
     * @return Returns a title text that is actually displayed to the user.
     */
    private String convertToDisplayedTitle(int displayedIndex, String actualTitle) {
        return displayedIndex + ". " + actualTitle;
    }

```
###### \java\guitests\guihandles\TodoListViewHandle.java
``` java
/**
 * Provides a handle for the {@link TodoListView}
 * containing a list of tasks.
 */
public class TodoListViewHandle extends GuiHandle {

    /* Constants */
    public static final int NOT_FOUND = -1;
    private static final String TASK_CARD_ID = "#taskCard";
    private static final String TODO_LIST_VIEW_ID = "#todoListView";

```
###### \java\guitests\guihandles\TodoListViewHandle.java
``` java
    /**
     * Gets a list of {@link ImmutableTask}
     */
    public List<ImmutableTask> getImmutableTaskList() {
        return getTodoListView().getItems();
    }

    /**
     * Gets a set of task card nodes in this to-do list.
     */
    public Set<Node> getAllTaskCardNodes() {
        return guiRobot.lookup(TASK_CARD_ID).queryAll();
    }

    /**
     * Gets a specific task from the list of tasks stored in the view by the list index.
     */
    public ImmutableTask getTask(int listIndex) {
        return getImmutableTaskList().get(listIndex);
    }

```
###### \java\guitests\guihandles\TodoListViewHandle.java
``` java
    /**
     * Gets a {@link TaskCardViewHandle} object with the position {@code listIndex} located in the to-do list view.
     * Guaranteed unique result for identical tasks.
     * Inherits the behaviour from {@link #getTaskCardViewNode(int)}.
     *
     * @param listIndex Index of the {@link #getImmutableTaskList()}.
     * @return An instance of the handle.
     */
    public TaskCardViewHandle getTaskCardViewHandle(int listIndex) {
        Node taskCardNode = getTaskCardViewNode(listIndex);
        if (taskCardNode != null) {
            return new TaskCardViewHandle(guiRobot, primaryStage, taskCardNode);
        } else {
            return null;
        }
    }

    /**
     * Gets a {@link Node} object with the position {@code listIndex} located in the to-do list view.
     * Guarantees:
     *      -  Unique result for identical tasks, because we are referencing from the index displayed
     *         in the UI.
     *      -  The object returned will never be null.
     *         This means if I can't find the object, an exception will be thrown.
     * Behaviour:
     *      Because a task card node is only drawn when the task card is shown on the screen,
     *      this method will automatically scroll the to-do list view to the position where the
     *      node is drawn.
     *
     * @param listIndex Index of the {@link #getImmutableTaskList()}
     *                  (must be a valid value from 0 to length of task list - 1,
     *                  else {@link RuntimeException} is thrown.
     * @return An instance of the node. Guarantees non-null.
     * @throws NodeFinderException if we can't find the node after finite attempts.
     */
    private Node getTaskCardViewNode(int listIndex) throws NodeFinderException {
        //Get the references
        int displayedIndex = UiTestUtil.convertToUiIndex(listIndex);
        Optional<Node> possibleNode;
        int attemptCounter = 0;

        //Try to get the node for finite number of times
        do {
            //Since nodes are not drawn if they are not in view, scroll to that position first.
            Platform.runLater(() -> getTodoListView().scrollTo(listIndex));
            //Allow the new nodes to be loaded from scrolling.
            guiRobot.sleep(50 * attemptCounter++);

            //Then, attempt to search for the node, breaking from the loop when it is found.
            Set<Node> taskCardNodes = getAllTaskCardNodes();
            possibleNode = taskCardNodes.stream().filter(node -> {
                TaskCardViewHandle taskCardView = new TaskCardViewHandle(guiRobot, primaryStage, node);
                return taskCardView.matchesTask(displayedIndex);
            }).findFirst();
        } while (!possibleNode.isPresent() && attemptCounter < 50);

        if (possibleNode.isPresent()) {
            return possibleNode.get();
        } else {
            String errorMessage
                    = "Either the node fails to draw on the screen, or you provided an invalid index "
                    + listIndex + " where the number of nodes is " + getAllTaskCardNodes().size();
            throw new NodeFinderException(errorMessage, NodeFinderException.ErrorType.NO_NODES_FOUND);
        }
    }

    /**
     * Checks if all the tasks stored inside the to-do list are displayed correctly.
     * Note: This does not check the sorted-ness of the list.
     * @return True if all the items are correctly displayed.
     */
    public boolean isDisplayedCorrectly() {
        return doesTodoListMatch();
    }

    /**
     * Given a list of tasks, check if all the tasks in the list are displayed correctly in the
     * {@link TodoListView}.
     * Note: this does not check the sorted-ness of the list.
     *
     * @return True if all the tasks in the {@code tasks} are displayed correctly.
     */
    public boolean doesTodoListMatch() {
        boolean outcome = true;
        List<ImmutableTask> tasks = getImmutableTaskList();
        for (int listIndex = 0; listIndex < tasks.size(); listIndex++) {
            ImmutableTask task = tasks.get(listIndex);
            TaskCardViewHandle handle = getTaskCardViewHandle(listIndex);
            int displayedIndex = UiTestUtil.convertToUiIndex(listIndex);
            outcome &= handle.isDisplayedCorrectly(displayedIndex, task);
        }
        return outcome;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point= TestUtil.getScreenMidPoint(getTodoListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code tasks} appear as the sub list (in that order) at position
     * {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ImmutableTask... tasks) {
        List<ImmutableTask> taskList = getImmutableTaskList();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + tasks.length > taskList.size()){
            return false;
        }

        // Return false if any of the task doesn't match
        for (int i = 0; i < tasks.length; i++) {
            ImmutableTask taskInView = taskList.get(i);
            ImmutableTask taskInList = tasks[i];
            if (!taskInView.equals(taskInList)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Navigates the {@link TodoListView} to display and select the task.
     * @param listIndex Index of the list that the list view should navigate to.
     * @return Handle of the selected task.
     */
    public TaskCardViewHandle navigateToTask(int listIndex) {
        guiRobot.interact(() -> {
            getTodoListView().scrollTo(listIndex);
            guiRobot.sleep(150);
            getTodoListView().getSelectionModel().select(listIndex);
        });
        guiRobot.sleep(100);
        return getTaskCardViewHandle(listIndex);
    }
}
```
###### \java\guitests\guihandles\ViewCommandTest.java
``` java
/**
 * Tests the display of the {@link seedu.todo.ui.view.FilterBarView} with the
 * {@link seedu.todo.logic.commands.ViewCommand}
 *
 * {@link seedu.todo.logic.commands.ViewCommandTest} ensures that the task view itself matches the filter.
 */
public class ViewCommandTest extends TodoListGuiTest {

    @Test
    public void view_checkAllFilterViews_allDisplayedInView() {

        List<String> displayedViewFilter = filterBarView.getFilterBarViewLabels();
        List<String> expectedViewFilter = new ArrayList<>();
        for (TaskViewFilter filter : TaskViewFilter.all()) {
            String capitalisedText = WordUtils.capitalize(filter.name);
            expectedViewFilter.add(capitalisedText);
        }
        assertEquals(expectedViewFilter, displayedViewFilter);
    }

    @Test
    public void view_defaultSelected_viewAllSelected() {
        assertSelection(TaskViewFilter.DEFAULT);
    }

    @Test
    public void view_switchViews_selectionCorrect() {
        //With full name, switching view works.
        runCommand("view completed");
        assertSelection(TaskViewFilter.COMPLETED);

        runCommand("view incomplete");
        assertSelection(TaskViewFilter.INCOMPLETE);

        runCommand("view events");
        assertSelection(TaskViewFilter.EVENTS);

        runCommand("view due soon");
        assertSelection(TaskViewFilter.DUE_SOON);

        runCommand("view all");
        assertSelection(TaskViewFilter.DEFAULT);

        runCommand("view today");
        assertSelection(TaskViewFilter.TODAY);

        //With short forms, switching view works.
        runCommand("view c");
        assertSelection(TaskViewFilter.COMPLETED);

        runCommand("view i");
        assertSelection(TaskViewFilter.INCOMPLETE);

        runCommand("view e");
        assertSelection(TaskViewFilter.EVENTS);

        runCommand("view d");
        assertSelection(TaskViewFilter.DUE_SOON);

        runCommand("view a");
        assertSelection(TaskViewFilter.DEFAULT);

        runCommand("view t");
        assertSelection(TaskViewFilter.TODAY);
    }

    /**
     * Helper method to check if the selection is as {@code expected}.
     */
    private void assertSelection(TaskViewFilter expected) {
        String actualSelection = filterBarView.getSelectedFilterView();
        String expectedSelection = WordUtils.capitalize(expected.name);
        assertEquals(expectedSelection, actualSelection);
    }
}
```
###### \java\guitests\HelpCommandTest.java
``` java
/**
 * Tests the display of help command.
 */
public class HelpCommandTest extends TodoListGuiTest {

    @Test
    public void help_showHelpPanelWithFull() {
        //Should display help with the complete "help" word.
        runCommand("help");
        assertHelpViewDisplayed();
    }

    @Test
    public void help_showHelpPanelWithShort() {
        //Should display help with an incomplete word of "help".
        runCommand("h");
        assertHelpViewDisplayed();
    }

    /**
     * Helper method to check if the help view is shown, and the content is correctly displayed.
     */
    private void assertHelpViewDisplayed() {
        assertTrue(helpView.isVisible());
        assertTrue(helpView.isHelpItemsDisplayedCorrectly(getAllCommandSummaryArray()));
    }

    /* Helper Methods */
    /**
     * Get a representation of the command summary by a list of array strings, where each item has the
     * following format:
     *      [Scenario, Command, Arguments]
     */
    private List<String[]> getAllCommandSummaryArray() {
        return CommandMap.getAllCommandSummary().stream()
                .map(CommandSummary::toArray)
                .collect(Collectors.toList());
    }
}
```
###### \java\guitests\TagCommandTest.java
``` java
/**
 * Tests the tag command, including:
 *      1. Display the global list of tags.
 *      2. TODO: CRUD of tags.
 */
public class TagCommandTest extends TodoListGuiTest {

    @Override
    protected TodoList getInitialData() {
        List<ImmutableTask> tasks = new ArrayList<>();

        //Initialise some dummy tasks with tags.
        for (int numOfTags = 0; numOfTags <= 5; numOfTags ++) {
            String[] listOfTagNames = TaskFactory.randomTags(numOfTags);

            ImmutableTask task = TaskBuilder.name(TaskFactory.taskTitle())
                    .tagged(listOfTagNames).build();

            tasks.add(task);
        }

        return getInitialDataHelper(tasks);
    }

    /* Actual Tests */
    @Test
    public void tags_displayGlobalTagList() {
        //Check that all the tags are displayed, and they are unique.
        runCommand("tag");
        List<String> displayedTagNames = globalTagView.getDisplayedTags();
        assertNoDuplicate(displayedTagNames);
        assertEqualTagNames(getTagList(todoListView.getImmutableTaskList()),
                Sets.newHashSet(displayedTagNames));
    }

    /* Helper Method */
    /**
     * Get the list of tags given a listof {@code tasks}
     */
    private Set<String> getTagList(List<ImmutableTask> tasks) {
        Set<String> listOfTagNames = new HashSet<>();
        tasks.forEach(task -> listOfTagNames.addAll(Tag.getLowerCaseNames(task.getTags())));
        return listOfTagNames;
    }

    /**
     * Asserts that two sets are equal (with no case sensitivity)
     */
    private void assertEqualTagNames(Set<String> tagNames1, Set<String> tagNames2) {
        tagNames1 = tagNames1.stream()
                .map(String::toLowerCase)
                .collect(Collectors.toSet());
        tagNames2 = tagNames2.stream()
                .map(String::toLowerCase)
                .collect(Collectors.toSet());
        assertEquals(tagNames1, tagNames2);
    }

    /**
     * Asserts that there are no duplicate strings
     */
    private void assertNoDuplicate(List<String> strings) {
        Set<String> stringSet = new HashSet<>(strings);
        assertTrue(strings.size() == stringSet.size());
    }
}
```
###### \java\guitests\TodoListGuiTest.java
``` java
    /**
     * Override {@link #getInitialData()} and use this method to set a variable initial
     * task size between {@code lowerBound} and {@code upperBound} inclusive.
     */
    protected TodoList getInitialDataHelper(int lowerBound, int upperBound) {
        TodoList todoList = TestUtil.generateEmptyTodoList(getDataFileLocation());
        initialTaskData = TaskFactory.list(lowerBound, upperBound);
        TestUtil.loadTodoListWithData(todoList, initialTaskData);
        return todoList;
    }

    /**
     * Override {@link #getInitialData()} and use this method to set a custom list of tasks.
     */
    protected TodoList getInitialDataHelper(List<ImmutableTask> tasks) {
        TodoList todoList = TestUtil.generateEmptyTodoList(getDataFileLocation());
        initialTaskData = tasks;
        TestUtil.loadTodoListWithData(todoList, initialTaskData);
        return todoList;
    }

```
###### \java\guitests\TodoListGuiTest.java
``` java
    /**
     * Enters the command via the {@link CommandInputView} but does not execute.
     */
    protected void enterCommand(String commandText) {
        commandInputView.enterCommand(commandText);
        mainGui.pressSpace();
    }

    /**
     * Executes the command via the {@link CommandInputView}
     */
    protected void runCommand(String commandText) {
        commandInputView.runCommand(commandText);
    }

    /**
     * Asserts the message shown in the {@link CommandFeedbackView}
     * is same as the given {@code expected} string.
     */
    protected void assertFeedbackMessage(String expected) {
        assertEquals(expected, commandFeedbackView.getText());
    }

    /**
     * Executes the incorrect command, and asserts that error view is shown to the user.
     */
    protected void assertErrorViewDisplayed(String commandInput) {
        runCommand(commandInput);
        assertTrue(mainGui.getCommandErrorView().isErrorMessagesDisplayed());
        enterCommand(" ");
        assertFalse(mainGui.getCommandErrorView().isVisible());
    }
}
```
###### \java\seedu\todo\commons\util\StringUtilTest.java
``` java
    @Test
    public void partitionStringAtPosition_emptyString() {
        String[] expected = {"", "", ""};

        //Tests null string
        testPartitionStringAtPositionHelper(null, 0, expected);

        //Test empty String
        testPartitionStringAtPositionHelper("", 0, expected);
    }

    @Test
    public void partitionStringAtPosition_positionOutOfBounds() {
        String input = "I have a Pikachu";
        String[] expected = {"", "", ""};

        //Tests position too low
        testPartitionStringAtPositionHelper(input, -1, expected);

        //Tests position too high
        testPartitionStringAtPositionHelper(input, 16, expected);
    }

    @Test
    public void partitionStringAtPosition_partitionCorrectly() {
        String input = "I have a Pikachu";

        //Test lower bound
        testPartitionStringAtPositionHelper(input, 0, new String[] {"", "I", " have a Pikachu"});

        //Test upper bound
        testPartitionStringAtPositionHelper(input, 15, new String[] {"I have a Pikach", "u", ""});

        //Test normal partition
        testPartitionStringAtPositionHelper(input, 5, new String[] {"I hav", "e", " a Pikachu"});
    }

    /**
     * Helper method to test partitionStringAtPosition(...).
     * @param input String to be partitioned.
     * @param position Position where partition should take place.
     * @param expected Expected output as String array.
     */
    private void testPartitionStringAtPositionHelper(String input, int position, String[] expected) {
        String[] outcome = StringUtil.partitionStringAtPosition(input, position);
        assertArrayEquals(expected, outcome);
    }

    @Test
    public void splitString_emptyInput() {
        String[] expected = new String[0];

        //Test null input.
        testSplitStringHelper(null, expected);

        //Test empty input.
        testSplitStringHelper("", expected);

        //Test only space and commas.
        testSplitStringHelper(" , ,   ,,, ,,,, , , ,,, , ,", expected);
    }

    @Test
    public void splitString_validInput() {
        //Input does not include space and comma
        testSplitStringHelper("!@(*&$!R#@%", new String[]{"!@(*&$!R#@%"});

        //Test one element
        testSplitStringHelper("Pichu-Pikachu_RAICHU's", new String[] {"Pichu-Pikachu_RAICHU's"});

        //Test multiple element split by space and comma
        testSplitStringHelper("an apple a, day, keeps , , doctor ,,, away",
                new String[] {"an", "apple", "a", "day", "keeps", "doctor", "away"});
    }
    
    @Test
    public void splitString_delimiterAtEnd() {
        testSplitStringHelper(", pikachu", new String[]{"pikachu"});
        testSplitStringHelper("pikachu  , ", new String[]{"pikachu"});
    }

    /**
     * Helper method to test split(...).
     * @param input String to be split.
     * @param expected Expected output as String array.
     */
    private void testSplitStringHelper(String input, String[] expected) {
        String[] outcome = StringUtil.split(input);
        assertArrayEquals(expected, outcome);
    }

    @Test
    public void testConvertListToString_emptyList() {
        String expected = "";

        //Test null list
        testConvertListToStringHelper(null, expected);

        //Test empty list
        testConvertListToStringHelper(new String[0], expected);
    }

    @Test
    public void testConvertListToString_validInput() {
        //Test one element
        testConvertListToStringHelper(new String[]{"applepie123!"}, "applepie123!");

        //Test several elements
        testConvertListToStringHelper(new String[]{"this", "is", "apple", "pen"}, "this, is, apple, pen");
    }

    /**
     * Helper method to test split(...).
     * @param input String to be split.
     * @param expected Expected output as String array.
     */
    private void testConvertListToStringHelper(String[] input, String expected) {
        String outcome = StringUtil.convertListToString(input);
        assertEquals(expected, outcome);
    }

    @Test
    public void testConvertIterableToString_emptyList() {
        String expected = "";

        //Test null list
        testConvertIterableToStringHelper(null, expected);

        //Test empty list
        testConvertIterableToStringHelper(new ArrayList<>(), expected);
    }

    @Test
    public void testConvertIterableToString_validInput() {
        //Test one element
        List<String> array1 = Collections.singletonList("applepie123!");
        testConvertIterableToStringHelper(array1, "applepie123!");

        //Test several elements
        List<String> array2 = Arrays.asList("this", "is", "apple", "pen");
        testConvertIterableToStringHelper(array2, "this, is, apple, pen");
    }

    /**
     * Helper method to test split(...).
     * @param input String to be split.
     * @param expected Expected output as String array.
     */
    private void testConvertIterableToStringHelper(Iterable<String> input, String expected) {
        String outcome = StringUtil.convertIterableToString(input);
        assertEquals(expected, outcome);
    }

```
###### \java\seedu\todo\commons\util\TimeUtilTest.java
``` java
/**
 * Tests the TimeUtil class
 */
public class TimeUtilTest {
    
    /**
     * Aids to test taskDeadlineText with a current time and due time, against an expected output.
     */
    private void testTaskDeadlineTextHelper(String expectedOutput, LocalDateTime currentTime,
                                            LocalDateTime dueTime) {
        TimeUtil timeUtil = new TimeUtil();
        timeUtil.setNow(currentTime);
        String generatedOutput = timeUtil.getTaskDeadlineText(dueTime);
        assertEquals(expectedOutput, generatedOutput);
    }

    /**
     * Aids to test eventTimeText with a current time, startTime and endTime, against an expected output.
     */
    private void testEventTimeTextHelper(String expectedOutput, LocalDateTime currentTime,
                                         LocalDateTime startTime, LocalDateTime endTime) {
        TimeUtil timeUtil = new TimeUtil();
        timeUtil.setNow(currentTime);
        String generatedOutput = timeUtil.getEventTimeText(startTime, endTime);
        assertEquals(expectedOutput, generatedOutput);
    }
        
    @Test
    public void getTaskDeadlineString_nullEndTime() {
        testTaskDeadlineTextHelper("", LocalDateTime.now(), null);
    }
    
    @Test
    public void getTaskDeadlineText_dueNow() {
        String expectedOutput = "due now";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Lower Bound: 0th second
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0), dueTime);
        //Upper Bound: 59th second
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 59), dueTime);
        //In the middle: 30th second
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 30), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_dueLessThanAMinute() {
        String expectedOutput = "in less than a minute";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Lower bound: 59 seconds left
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 1), dueTime);
        //Upper bound: 1 second left
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 59), dueTime);
        //In the middle: 30 seconds left
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 30), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_aMinuteBeforeDeadline() {
        String expectedOutput = "in 1 minute";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Upper Bound
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 0), dueTime);
        //In the middle
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 58, 30), dueTime);
        //Lower Bound
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 58, 1), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_aMinuteAfterDeadline() {
        String expectedOutput = "1 minute ago";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Lower Bound
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 1, 0), dueTime);
        //Middle
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 1, 30), dueTime);
        //Upper Bound
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 1, 59), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_minutesBeforeDeadline() {
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Test 2 min to 59 min
        for (int minutesLeft = 2; minutesLeft <= 59; minutesLeft++) {
            String expectedOutput = "in " + minutesLeft + " minutes";
            
            testTaskDeadlineTextHelper(expectedOutput, dueTime.minusMinutes(minutesLeft), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.minusMinutes(minutesLeft).minusSeconds(30), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.minusMinutes(minutesLeft).minusSeconds(59), dueTime);
        }
    }
    
    @Test
    public void getTaskDeadlineText_minutesAfterDeadline() {
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Test 2 min to 59 min
        for (int minutesLater = 2; minutesLater <= 59; minutesLater++) {
            String expectedOutput = minutesLater + " minutes ago";
            
            testTaskDeadlineTextHelper(expectedOutput, dueTime.plusMinutes(minutesLater), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.plusMinutes(minutesLater).plusSeconds(30), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.plusMinutes(minutesLater).plusSeconds(59), dueTime);
        }
    }
    
    @Test
    public void getTaskDeadlineText_todayBeforeDeadline() {
        testTaskDeadlineTextHelper("by today, 5:59 PM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 10, 45), LocalDateTime.of(2016, Month.MARCH, 20, 17, 59));
        testTaskDeadlineTextHelper("by tonight, 6:00 PM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 11, 58), LocalDateTime.of(2016, Month.MARCH, 20, 18, 0));
        testTaskDeadlineTextHelper("in 30 minutes", 
                LocalDateTime.of(2016, Month.MARCH, 20, 0, 0), LocalDateTime.of(2016, Month.MARCH, 20, 0, 30));
    }
    
    @Test
    public void getTaskDeadlineText_todayAfterDeadline() {
        testTaskDeadlineTextHelper("since today, 12:00 PM",
                LocalDateTime.of(2016, Month.MARCH, 20, 18, 45), LocalDateTime.of(2016, Month.MARCH, 20, 12, 0));
        testTaskDeadlineTextHelper("since tonight, 6:50 PM",
                LocalDateTime.of(2016, Month.MARCH, 20, 23, 58), LocalDateTime.of(2016, Month.MARCH, 20, 18, 50));
        testTaskDeadlineTextHelper("30 minutes ago", 
                LocalDateTime.of(2016, Month.MARCH, 20, 0, 30), LocalDateTime.of(2016, Month.MARCH, 20, 0, 0));
    }
    
    @Test
    public void getTaskDeadlineText_tomorrowBeforeDeadline() {
        testTaskDeadlineTextHelper("by tomorrow, 12:00 PM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 12, 0), LocalDateTime.of(2016, Month.MARCH, 21, 12, 0));
        testTaskDeadlineTextHelper("by tomorrow, 12:51 AM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 23, 50), LocalDateTime.of(2016, Month.MARCH, 21, 0, 51));
        testTaskDeadlineTextHelper("in 20 minutes", 
                LocalDateTime.of(2016, Month.MARCH, 20, 23, 50), LocalDateTime.of(2016, Month.MARCH, 21, 0, 10));
    }
    
    @Test
    public void getTaskDeadlineText_yesterdayAfterDeadline() {
        testTaskDeadlineTextHelper("since yesterday, 12:00 PM", 
                LocalDateTime.of(2016, Month.MARCH, 21, 12, 0), LocalDateTime.of(2016, Month.MARCH, 20, 12, 0));
        testTaskDeadlineTextHelper("since yesterday, 12:51 AM",
                LocalDateTime.of(2016, Month.MARCH, 21, 23, 50), LocalDateTime.of(2016, Month.MARCH, 20, 0, 51));
        testTaskDeadlineTextHelper("20 minutes ago", 
                LocalDateTime.of(2016, Month.MARCH, 21, 0, 10), LocalDateTime.of(2016, Month.MARCH, 20, 23, 50));
    }
    
    @Test
    public void getTaskDeadlineText_thisYearBeforeDeadline() {
        testTaskDeadlineTextHelper("by 12 August, 12:55 PM", 
                LocalDateTime.of(2016, Month.JANUARY, 21, 12, 0),
                LocalDateTime.of(2016, Month.AUGUST, 12, 12, 55));

        testTaskDeadlineTextHelper("by 15 September, 12:00 AM",
                LocalDateTime.of(2016, Month.SEPTEMBER, 13, 23, 59),
                LocalDateTime.of(2016, Month.SEPTEMBER, 15, 0, 0));
    }
    
    @Test
    public void getTaskDeadlineText_thisYearAfterDeadline() {
        testTaskDeadlineTextHelper("since 21 January, 8:47 PM", 
                LocalDateTime.of(2016, Month.AUGUST, 12, 12, 55),
                LocalDateTime.of(2016, Month.JANUARY, 21, 20, 47));

        testTaskDeadlineTextHelper("since 13 September, 11:59 PM",
                LocalDateTime.of(2016, Month.SEPTEMBER, 15, 0, 0),
                LocalDateTime.of(2016, Month.SEPTEMBER, 13, 23, 59));
    }
    
    @Test
    public void getTaskDeadlineText_differentYearBeforeDeadline() {
        testTaskDeadlineTextHelper("in 1 minute", 
                LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59),
                LocalDateTime.of(2017, Month.JANUARY, 1, 0, 0));
        testTaskDeadlineTextHelper("by tomorrow, 1:15 AM",
                LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 0),
                LocalDateTime.of(2017, Month.JANUARY, 1, 1, 15));
        testTaskDeadlineTextHelper("by 31 January 2017, 1:05 AM",
                LocalDateTime.of(2016, Month.JUNE, 30, 22, 0),
                LocalDateTime.of(2017, Month.JANUARY, 31, 1, 5));
        testTaskDeadlineTextHelper("by 31 August 2020, 12:35 PM",
                LocalDateTime.of(2016, Month.FEBRUARY, 13, 13, 0),
                LocalDateTime.of(2020, Month.AUGUST, 31, 12, 35));
    }
    
    @Test
    public void getTaskDeadlineText_differentYearAfterDeadline() {
        testTaskDeadlineTextHelper("1 minute ago", 
                LocalDateTime.of(2017, Month.JANUARY, 1, 0, 0),
                LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59));
        testTaskDeadlineTextHelper("since yesterday, 12:00 AM",
                LocalDateTime.of(2017, Month.JANUARY, 1, 0, 0),
                LocalDateTime.of(2016, Month.DECEMBER, 31, 0, 0));
        testTaskDeadlineTextHelper("since 30 June 2016, 10:00 PM",
                LocalDateTime.of(2017, Month.JANUARY, 31, 1, 5),
                LocalDateTime.of(2016, Month.JUNE, 30, 22, 0));
        testTaskDeadlineTextHelper("since 13 February 2016, 1:00 PM",
                LocalDateTime.of(2020, Month.AUGUST, 31, 12, 35),
                LocalDateTime.of(2016, Month.FEBRUARY, 13, 13, 0));
    }
    
    @Test
    public void getEventTimeText_nullStartTime() {
        testEventTimeTextHelper("", LocalDateTime.now(), null, LocalDateTime.now().plusMinutes(1));
    }
    
    @Test
    public void getEventTimeText_nullEndTime() {
        testEventTimeTextHelper("", LocalDateTime.now(), LocalDateTime.now().plusMinutes(1), null);
    }

    @Test
    public void getEventTimeText_sameDay() {
        LocalDateTime currentTime = LocalDateTime.of(2016, 10, 20, 12, 00);
        testEventTimeTextHelper("yesterday, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2016, 10, 19, 20, 30));
        testEventTimeTextHelper("today, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 16, 50), LocalDateTime.of(2016, 10, 20, 20, 30));
        testEventTimeTextHelper("tonight, from 6:00 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 18, 00), LocalDateTime.of(2016, 10, 20, 20, 30));
        testEventTimeTextHelper("tomorrow, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 21, 16, 50), LocalDateTime.of(2016, 10, 21, 20, 30));
        testEventTimeTextHelper("21 November, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 11, 21, 16, 50), LocalDateTime.of(2016, 11, 21, 20, 30));
        testEventTimeTextHelper("21 November 2017, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2017, 11, 21, 16, 50), LocalDateTime.of(2017, 11, 21, 20, 30));
    }

    @Test
    public void getEventTimeText_differentDay() {
        LocalDateTime currentTime = LocalDateTime.of(2016, 10, 20, 12, 00);
        testEventTimeTextHelper("from yesterday, 4:50 PM to today, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2016, 10, 20, 14, 30));
        testEventTimeTextHelper("from yesterday, 4:50 PM to tonight, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2016, 10, 20, 20, 30));
        testEventTimeTextHelper("from today, 4:50 PM to tomorrow, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 16, 50), LocalDateTime.of(2016, 10, 21, 20, 30));
        testEventTimeTextHelper("from tonight, 6:50 PM to tomorrow, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 18, 50), LocalDateTime.of(2016, 10, 21, 20, 30));
        testEventTimeTextHelper("from tomorrow, 6:50 PM to 22 October, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 21, 18, 50), LocalDateTime.of(2016, 10, 22, 20, 30));
        testEventTimeTextHelper("from 18 October, 6:50 PM to 22 October, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 18, 18, 50), LocalDateTime.of(2016, 10, 22, 20, 30));
    }

    @Test
    public void getEventTimeText_differentYear() {
        LocalDateTime currentTime = LocalDateTime.of(2016, 12, 31, 12, 00);
        testEventTimeTextHelper("from 19 October, 4:50 PM to 3 January 2017, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2017, 1, 3, 14, 30));
        testEventTimeTextHelper("from 19 October, 4:50 PM to tomorrow, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2017, 1, 1, 14, 30));
        testEventTimeTextHelper("from today, 4:50 PM to 4 January 2017, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 12, 31, 16, 50), LocalDateTime.of(2017, 1, 4, 14, 30));
    }
    
    @Test
    public void isOverdue_nullEndTime() {
        TimeUtil timeUtil = new TimeUtil();
        assertFalse(timeUtil.isOverdue(null));
    }
    
    @Test
    public void isOverdue_endTimeAfterNow() {
        TimeUtil timeUtil = new TimeUtil();
        timeUtil.setNow(LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 34));
        LocalDateTime laterEndTime = LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 35);
        assertFalse(timeUtil.isOverdue(laterEndTime));
    }
    
    @Test
    public void isOverdue_endTimeBeforeNow() {
        TimeUtil timeUtil = new TimeUtil();
        timeUtil.setNow(LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 36));
        LocalDateTime laterEndTime = LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 35);
        assertTrue(timeUtil.isOverdue(laterEndTime));
    }

```
###### \java\seedu\todo\logic\commands\AddCommandTest.java
``` java
    @Test
    public void testAddTag_singleTag() throws Exception {
        Set<Tag> expectedTags = TaskFactory.convertToTags("pikachu");

        setParameter("Task with tags");
        setParameter("t", "pikachu");
        execute(true);

        ImmutableTask task = getTaskAt(1);
        assertEquals("Task with tags", task.getTitle());
        assertEquals(expectedTags, task.getTags());
    }

    @Test
    public void testAddTag_maxTags() throws Exception {
        Set<Tag> expectedTags
                = TaskFactory.convertToTags("pikachu123", "charizaRD_-", "-pichu-", "---raichu", "gasly");

        setParameter("Hello with tags");
        setParameter("t", "pikachu123 , charizaRD_-  -pichu-  ---raichu,  gasly");
        execute(true);

        ImmutableTask task = getTaskAt(1);
        assertEquals("Hello with tags", task.getTitle());
        assertEquals(expectedTags, task.getTags());
    }

    @Test
    public void testAddTag_fullEventWithTags() throws Exception {
        Set<Tag> expectedTags = TaskFactory.convertToTags("leisure", "pokemon", "pikachu");

        setParameter("Pokemon with tags");
        setParameter("m", "Some long long very very long long massively long description. Thank you.");
        setParameter("t", "leisure   pokemon, pikachu  ");
        setParameter("d", "tomorrow 8am to 9am");
        setParameter("p", null);
        setParameter("l", "some weird location at bukit timah");
        execute(true);

        ImmutableTask task = getTaskAt(1);
        assertEquals("Pokemon with tags", task.getTitle());
        assertEquals("Some long long very very long long massively long description. Thank you.",
                task.getDescription().get());
        assertEquals(TimeUtil.tomorrow().withHour(8), task.getStartTime().get());
        assertEquals(TimeUtil.tomorrow().withHour(9), task.getEndTime().get());
        assertEquals("some weird location at bukit timah", task.getLocation().get());
        assertEquals(expectedTags, task.getTags());
        assertTrue(task.isPinned());
        assertTrue(task.isEvent());
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_tooManyTags() throws Exception {
        setParameter("Chinatown with tags");
        setParameter("t", "pikachu123 , charizard_-  -pichu-  ---raichu,  gasly, oops");
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_tagNameTooLong() throws Exception {
        setParameter("Pikachu with tags");
        setParameter("t", "123456789012345678901");
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_invalidTagCharacters() throws Exception {
        setParameter("Penguin with tags");
        setParameter("t", "invalid@");
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_duplicatedTags() throws Exception {
        setParameter("Some bored task with tags");
        setParameter("t", "say duplicated again say");
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_noTagsSupplied() throws Exception {
        setParameter("Hello world with tags");
        setParameter("t", "   ");
        execute(false);
    }
}
```
###### \java\seedu\todo\logic\commands\TagCommandTest.java
``` java
/**
 * Performs integration testing for Tag Command.
 */
public class TagCommandTest extends CommandTest {

    /* Constants */
    private static final String[] TAG_NAMES = {
        "MacBook_Pro1", "MacBook_Air", "Mac_PrO2", "Surface_-Pro3", "Surface-STUDIO", "SurFACE_BoOk"
    };

    private static final String[] TAG_NAMES_0_TO_4 = {
            TAG_NAMES[0], TAG_NAMES[1], TAG_NAMES[2], TAG_NAMES[3], TAG_NAMES[4]
    };

    private static final String[] TAG_NAMES_0_TO_3 = {
            TAG_NAMES[0], TAG_NAMES[1], TAG_NAMES[2], TAG_NAMES[3]
    };

    private static final String[] TAG_NAMES_0_TO_2 = {
            TAG_NAMES[0], TAG_NAMES[1], TAG_NAMES[2]
    };

    /* Override Methods */
    @Override
    protected BaseCommand commandUnderTest() {
        return new TagCommand();
    }

    @Before
    public void setUp() throws Exception{
        //Task indexed at 5
        model.add("Task 5 With 5 Tags");
        Thread.sleep(10);

        //Task indexed at 4
        model.add("Task 4 With 3 Tags");
        Thread.sleep(10);

        //Task indexed at 3
        model.add("Task 3 With 1 Tag");
        Thread.sleep(10);

        //Task indexed at 2
        model.add("Task 2 With 1 Tag");
        Thread.sleep(10);

        //Task indexed at 1
        model.add("Task 1 With 0 Tags");
        Thread.sleep(10);

        //Add tags to dummy tasks
        model.addTagsToTask(5, TAG_NAMES_0_TO_4);
        model.addTagsToTask(4, TAG_NAMES_0_TO_2);
        model.addTagsToTask(3, TAG_NAMES[1]);
        model.addTagsToTask(2, TAG_NAMES[0]);
    }

    /* Global Tag View Test */
    @Test
    public void getTagList_tagListAtInitial() throws Exception {
        //Since at start, we have tag names from 0 to 4 inclusive assigned to tasks already.
        //So we expect the following 5 tag names.
        assertGlobalTagListCorrect(TAG_NAMES_0_TO_4);
    }

    @Test
    public void getTagList_tagListAfterDelete() throws Exception {
        //Expects the tag list to contain only the tags that are still available after a task is deleted.
        model.delete(5);

        //Since task 5 is deleted, we expect tag 0 to 2 inclusive.
        assertGlobalTagListCorrect(TAG_NAMES_0_TO_2);
    }

    /* Add Tag Test */
    @Test
    public void testAddTag_addSingleTag() throws Exception {
        //Adds a single tag to a task without tags.
        Set<Tag> expectedTags = convertToTags(TAG_NAMES[5]);
        setParameter("1 " + TAG_NAMES[5]);
        execute(true);

        ImmutableTask task = getTaskAt(1);
        assertEquals(expectedTags, task.getTags());
        assertGlobalTagListCorrect(TAG_NAMES);
    }

    @Test
    public void testAddTag_addMaxTags() throws Exception {
        //Adds 5 tags to a task without tags.
        Set<Tag> expectedTags = convertToTags(TAG_NAMES_0_TO_4);

        StringJoiner joiner = new StringJoiner(" ");
        joiner.add("1")
                .add(TAG_NAMES[0]).add(TAG_NAMES[1]).add(TAG_NAMES[2]).add(TAG_NAMES[3]).add(TAG_NAMES[4]);
        setParameter(joiner.toString());
        execute(true);

        ImmutableTask task = getTaskAt(1);
        assertEquals(expectedTags, task.getTags());
        assertGlobalTagListCorrect(TAG_NAMES_0_TO_4);
    }

    @Test
    public void testAddTag_unrestrictedSeparators() throws Exception {
        //Allows separators such as space, commas.
        Set<Tag> expectedTags = convertToTags("Pikachu", "Pichu", "Raichu");
        setParameter("1 ,  Pichu, Pikachu Raichu  , ");
        execute(true);

        ImmutableTask task = getTaskAt(1);
        assertEquals(expectedTags, task.getTags());
        assertGlobalTagListCorrect(TAG_NAMES_0_TO_4, "Pikachu", "Pichu", "Raichu");
    }

```
###### \java\seedu\todo\logic\commands\TagCommandTest.java
``` java
    @Test (expected = ValidationException.class)
    public void testAddTag_addNoTags() throws Exception {
        //Provides no tag names.
        setParameter("1");
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_addTooManyTags1() throws Exception {
        //Adds 6 tags to a task without tags
        setParameter("1 tag1 tag2 tag3 tag4 tag5 tag6");
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_addTooManyTags2() throws Exception {
        //Adds 3 tags to a task with 3 tags
        setParameter("4 tag1 tag2 tag3");
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_addInvalidTag() throws Exception {
        //Adds a tag with invalid character (not alphanumeric, nor underscores, nor dashes)
        setParameter("1 invalid:)");
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_addTooLongTag() throws Exception {
        //Adds a tag with 21 characters
        setParameter("1 123456789012345678901");
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void testAddTag_duplicatedTagNames() throws Exception {
        //Adds tags that contains duplicated tag names
        setParameter("1 hello say hello again");
        execute(false);
    }

    /* Delete Tag From Task Test */
    @Test
    public void testDeleteTagFromTask_deleteOneTag() throws Exception {
        //Deletes one tag from task 5 with 5 tags. Expects 4 tags left.
        Set<Tag> expectedTags = convertToTags(TAG_NAMES_0_TO_3);

        setParameter("5");
        setParameter("d", TAG_NAMES[4]);
        execute(true);

        ImmutableTask task = getTaskAt(5);
        assertEquals(expectedTags, task.getTags());
        assertGlobalTagListCorrect(TAG_NAMES_0_TO_3);
    }

    @Test
    public void testDeleteTagFromTask_deleteAllTags() throws Exception {
        //Deletes all the tags from a task with 5 tags. Expects none left.
        Set<Tag> expectedTags = new HashSet<>();

        StringJoiner joiner = new StringJoiner(" ");
        joiner.add(TAG_NAMES[0]).add(TAG_NAMES[1]).add(TAG_NAMES[2]).add(TAG_NAMES[3]).add(TAG_NAMES[4]);

        setParameter("5");
        setParameter("d", joiner.toString());
        execute(true);

        ImmutableTask task = getTaskAt(5);
        assertEquals(expectedTags, task.getTags());
        assertGlobalTagListCorrect(TAG_NAMES_0_TO_2);
    }
    
```
###### \java\seedu\todo\logic\commands\TagCommandTest.java
``` java
    @Test
    public void testDeleteTagFromTask_deleteMissing() {
        //Deletes a tag that is not found. This should result in no-op.
        Set<Tag> expectedTags = new HashSet<>(getTaskAt(5).getTags());

        setParameter("5");
        setParameter("d", TAG_NAMES[1] + " " + TAG_NAMES[5]);

        try {
            execute(false);
            assert false; //After the above line, not supposed to happen!
        } catch (ValidationException e) {
            //Okay, exception is expected. Now to check the state of the object.
            Set<Tag> outcomeTags = new HashSet<>(getTaskAt(5).getTags());
            assertEquals(expectedTags, outcomeTags);
        }
    }

    @Test (expected = ValidationException.class)
    public void testDeleteTagFromTask_deleteNoParam() throws Exception {
        //Declares no parameters to delete command.
        setParameter("1");
        setParameter("d", "   ");
        execute(false);
    }

    /* Delete Tags Globally Test */
    @Test
    public void testDeleteTagGlobally_deleteOneTag() throws Exception {
        //Deletes one tag from the list of tags. All other tags should stay intact.
        Set<Tag> expects0Tags = convertToTags();
        Set<Tag> expects1Tags = convertToTags(TAG_NAMES[1]);
        Set<Tag> expects2Tags = convertToTags(TAG_NAMES[1], TAG_NAMES[2]);
        Set<Tag> expects4Tags = convertToTags(TAG_NAMES[1], TAG_NAMES[2], TAG_NAMES[3], TAG_NAMES[4]);

        setParameter("d", TAG_NAMES[0]);
        execute(true);

        assertEquals(expects0Tags, getTaskAt(1).getTags());
        assertEquals(expects0Tags, getTaskAt(2).getTags());
        assertEquals(expects1Tags, getTaskAt(3).getTags());
        assertEquals(expects2Tags, getTaskAt(4).getTags());
        assertEquals(expects4Tags, getTaskAt(5).getTags());
        assertGlobalTagListCorrect(TAG_NAMES[1], TAG_NAMES[2], TAG_NAMES[3], TAG_NAMES[4]);
    }

    @Test
    public void testDeleteTagGlobally_deleteMoreTags() throws Exception {
        //Deletes two tags from the list of tags. All other tags should stay intact.
        Set<Tag> expects0Tags = convertToTags();
        Set<Tag> expects1Tags = convertToTags(TAG_NAMES[2]);
        Set<Tag> expects3Tags = convertToTags(TAG_NAMES[2], TAG_NAMES[3], TAG_NAMES[4]);

        setParameter("d", TAG_NAMES[0] + " " + TAG_NAMES[1]);
        execute(true);

        assertEquals(expects0Tags, getTaskAt(1).getTags());
        assertEquals(expects0Tags, getTaskAt(2).getTags());
        assertEquals(expects0Tags, getTaskAt(3).getTags());
        assertEquals(expects1Tags, getTaskAt(4).getTags());
        assertEquals(expects3Tags, getTaskAt(5).getTags());
        assertGlobalTagListCorrect(TAG_NAMES[2], TAG_NAMES[3], TAG_NAMES[4]);
    }

    @Test
    public void testDeleteTagGlobally_deleteMissingTags() {
        //Deletes a tag that does not exist. This should result in no op.
        List<Set<Tag>> listOfExpectedOutcome = model.getObservableList().stream()
                .map((Function<ImmutableTask, Set<Tag>>) task -> new HashSet<>(task.getTags()))
                .collect(Collectors.toList());

        setParameter("d", TAG_NAMES[1] + " " + TAG_NAMES[5]);

        try {
            execute(false);
            assert false; //After the above line, not supposed to happen!
        } catch (ValidationException e) {
            //Validation exception expected, now check that the tags are unmodified.
            for (int taskIndex = 1; taskIndex <= 5 ; taskIndex ++) {
                assertEquals(listOfExpectedOutcome.get(taskIndex - 1), getTaskAt(taskIndex).getTags());
            }
        }
    }

    @Test (expected = ValidationException.class)
    public void testDeleteTagGlobally_deleteNoParam() throws Exception {
        //Declares no parameters to delete command.
        setParameter("d", "   ");
        execute(false);
    }

    /* Global Rename Tag Test */
    @Test
    public void globalRenameTag_globalRenameTagSuccess() throws Exception {
        //Renames a tag successfully
        Set<Tag> expectsTask1Tag = convertToTags();
        Set<Tag> expectsTask2Tag = convertToTags(TAG_NAMES[5]);
        Set<Tag> expectsTask3Tag = convertToTags(TAG_NAMES[1]);
        Set<Tag> expectsTask4Tag = convertToTags(TAG_NAMES[5], TAG_NAMES[1], TAG_NAMES[2]);
        Set<Tag> expectsTask5Tag
                = convertToTags(TAG_NAMES[5], TAG_NAMES[1], TAG_NAMES[2], TAG_NAMES[3], TAG_NAMES[4]);

        setParameter("r", TAG_NAMES[0] + " " + TAG_NAMES[5]);
        execute(true);

        assertEquals(expectsTask1Tag, getTaskAt(1).getTags());
        assertEquals(expectsTask2Tag, getTaskAt(2).getTags());
        assertEquals(expectsTask3Tag, getTaskAt(3).getTags());
        assertEquals(expectsTask4Tag, getTaskAt(4).getTags());
        assertEquals(expectsTask5Tag, getTaskAt(5).getTags());
        assertGlobalTagListCorrect(TAG_NAMES[1], TAG_NAMES[2], TAG_NAMES[3], TAG_NAMES[4], TAG_NAMES[5]);
    }
    
    

    @Test (expected = ValidationException.class)
    public void globalRenameTag_newNameExists() throws Exception {
        //Renames to a name that already exists.
        setParameter("r", TAG_NAMES[0] + " " + TAG_NAMES[1]);
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void globalRenameTag_oldNameMissing() throws Exception {
        //Renames from a name that does not exist
        setParameter("r", TAG_NAMES[5] + " " + TAG_NAMES[1]);
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void globalRenameTag_oneTagNameOnly() throws Exception {
        //Provides one tag name for rename only. This is incorrect.
        setParameter("r", TAG_NAMES[5]);
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void globalRenameTag_renameNoParams() throws Exception {
        //Provides no tag names for renaming. This is incorrect.
        setParameter("r", "   ");
        execute(false);
    }

    /* Rename Tag Test */
    @Test
    public void renameTagFromTask_renameSuccess() throws Exception {
        Set<Tag> expectedTags = convertToTags(TAG_NAMES[5]);
        Set<Tag> task4Tags = Sets.newHashSet(getTaskAt(4).getTags());

        setParameter("2");
        setParameter("r", TAG_NAMES[0] + " " + TAG_NAMES[5]);
        execute(true);

        //Checks if the tag at task 2 is renamed successfully.
        assertEquals(expectedTags, getTaskAt(2).getTags());

        //Check that tag from other tasks are untouched.
        assertEquals(task4Tags, getTaskAt(4).getTags());

        //Check global tags list
        assertGlobalTagListCorrect(TAG_NAMES);
    }

    @Test (expected = ValidationException.class)
    public void renameTagFromTask_tagNameNotFound() throws Exception {
        setParameter("2");
        setParameter("r", TAG_NAMES[5] + " " + TAG_NAMES[2]);
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void renameTagFromTask_sameTagName() throws Exception {
        //Same old and new tag names.
        setParameter("2");
        setParameter("r", TAG_NAMES[0] + " " + TAG_NAMES[0]);
        execute(false);
    }

    @Test (expected = ValidationException.class)
    public void renameTagFromTask_newNameExist() throws Exception {
        setParameter("4");
        setParameter("r", TAG_NAMES[0] + " " + TAG_NAMES[2]);
        execute(false);
    }

    /* Helper Methods */
    /**
     * Asserts the global tag list contains the list of tags specified in {@code expectedTagNames}.
     */
    private void assertGlobalTagListCorrect(String... expectedTagNames) {
        Set<String> expectedTagSet = Arrays.stream(expectedTagNames)
                .map(String::toLowerCase)
                .collect(Collectors.toSet());
        Set<String> actualTagSet = Tag.getLowerCaseNames(model.getGlobalTagsList());
        assertEquals(expectedTagSet, actualTagSet);
    }

    /**
     * Asserts the global tag list contains the list of tags specified in {@code expectedTagNames}.
     */
    private void assertGlobalTagListCorrect(String[] expectedTagNameArray, String... expectedTagNames) {
        List<String> tagNames = new ArrayList<>();
        Arrays.stream(expectedTagNameArray).forEach(tagNames::add);
        Arrays.stream(expectedTagNames).forEach(tagNames::add);
        assertGlobalTagListCorrect(tagNames.toArray(new String[0]));
    }
}
```
###### \java\seedu\todo\logic\commands\UndoCommandTest.java
``` java
    @Test
    public void testUndo_undoAddTag() throws Exception {
        String tagName = "pikachu";
        model.add("Sample Task");
        Thread.sleep(10);
        model.addTagsToTask(1, tagName);

        //Sanity check: The tag is really added.
        assertTrue(model.getTask(1).getTags().contains(new Tag(tagName)));

        model.undo();

        //Check if the the tag is removed.
        assertFalse(model.getTask(1).getTags().contains(new Tag(tagName)));
    }

    @Test
    public void testUndo_undoDeleteTagFromATask() throws Exception {
        String tagName = "apple123";
        model.add("Sample Task");
        Thread.sleep(10);
        model.addTagsToTask(1, tagName);
        model.deleteTagsFromTask(1, tagName);

        //Sanity check: The tag is really deleted.
        assertFalse(model.getTask(1).getTags().contains(new Tag(tagName)));

        model.undo();

        //Check if the the tag is restored.
        assertTrue(model.getTask(1).getTags().contains(new Tag(tagName)));
    }

    @Test
    public void testUndo_undoRenameTagFromTask() throws Exception {

        String oldName = "farfetch";
        String newName = "nearthrow";
        model.add("Sample Task");
        Thread.sleep(10);
        model.addTagsToTask(1, oldName);

        model.renameTag(1, oldName, newName);

        //Sanity check: The tag is really renamed.
        assertTrue(model.getTask(1).getTags().contains(new Tag(newName)));

        model.undo();

        //Check if the the tag is restored.
        assertTrue(model.getTask(1).getTags().contains(new Tag(oldName)));
    }

    @Test
    public void testUndo_undoTagRename_allTagNamesRestored() throws Exception {
        String oldTag = "vertices";
        String newTag = "edges";

        for (int i = 1; i <= 3; i ++) {
            model.add("Sample Task " + i);
            Thread.sleep(10);
            model.addTagsToTask(1, oldTag);
        }

        model.renameTag(oldTag, newTag);

        //Sanity check: The tags are really renamed.
        model.getObservableList().forEach(task -> {
            boolean hasOldTag = task.getTags().contains(new Tag(oldTag));
            boolean hasNewTag = task.getTags().contains(new Tag(newTag));
            assertTrue(hasNewTag && !hasOldTag);
        });

        model.undo();

        //Check if the old tag name is restored.
        model.getObservableList().forEach(task -> {
            boolean hasOldTag = task.getTags().contains(new Tag(oldTag));
            boolean hasNewTag = task.getTags().contains(new Tag(newTag));
            assertTrue(!hasNewTag && hasOldTag);
        });
    }

    @Test
    public void testUndo_undoTagDelete_allTagNamesRestored() throws Exception {
        String oldTag = "wonderful";

        for (int i = 1; i <= 3; i ++) {
            model.add("Sample Task " + i);
            Thread.sleep(10);
            model.addTagsToTask(1, oldTag);
        }

        model.deleteTags(oldTag);

        //Sanity check: The tags are really deleted.
        model.getObservableList().forEach(task -> {
            boolean hasOldTag = task.getTags().contains(new Tag(oldTag));
            assertFalse(hasOldTag);
        });

        model.undo();

        //Checks if the tags are restored.
        model.getObservableList().forEach(task -> {
            boolean hasOldTag = task.getTags().contains(new Tag(oldTag));
            assertTrue(hasOldTag);
        });
    }
}
```
###### \java\seedu\todo\testutil\TaskFactory.java
``` java
    /**
     * Generates a random tag from the pool of tags.
     */
    public static String randomTag() {
        return tags.get(random.nextInt(tags.size()));
    }

    /**
     * Generates a list of unique tags from the pool of tags.
     */
    public static String[] randomTags(int numberOfTags) {
        List<String> copyOfTagNames = new ArrayList<>(tags);
        Collections.shuffle(copyOfTagNames);
        return copyOfTagNames.subList(0, numberOfTags).toArray(new String[0]);
    }

    /**
     * Generates a randomly sized list of unique tags from the pool of tags.
     */
    public static String[] randomTags() {
        return randomTags(1 + random.nextInt(4));
    }

```
###### \java\seedu\todo\testutil\TaskFactory.java
``` java
    /**
     * Generates a list of random tasks with a random size between {@code lowerBound}
     * and {@code upperBound} inclusive.
     *
     * @return Returns a randomly generated list.
     */
    public static List<ImmutableTask> list(int lowerBound, int upperBound) {
        int size = lowerBound + random.nextInt(upperBound - lowerBound + 1);
        ArrayList<ImmutableTask> tasks = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            tasks.add(random());
        }
        return tasks;
    }

    /**
     * Helps to convert a varang of tag names to a set of tags.
     */
    public static Set<Tag> convertToTags(String... tagNames) {
        Set<Tag> outcomeTags = new HashSet<>();
        for (String tagName : tagNames) {
            outcomeTags.add(new Tag(tagName));
        }
        return outcomeTags;
    }
}
```
###### \java\seedu\todo\testutil\TimeUtil.java
``` java
    /**
     * Checks against system time if the provided dueTime is before system time.
     *
     * @param dueTime The due time to check against with the current system time.
     * @return Returns true if the provided dueTime is before system time.
     */
    public static boolean isOverdue(LocalDateTime dueTime) {
        return dueTime.isBefore(LocalDateTime.now());
    }

    /**
     * Checks against system time if the provided time period is ongoing.
     * @param startTime start time of the event
     * @param endTime end time of the event
     * @return Returns true if the provided time period surrounds the current time.
     */
    public static boolean isOngoing(LocalDateTime startTime, LocalDateTime endTime) {
        return startTime.isBefore(LocalDateTime.now()) && endTime.isAfter(LocalDateTime.now());
    }

    /**
     * Gets the complete date time text in the following format:
     *      12 August 2015, 12:34 PM
     */
    public static String getDateTimeText(LocalDateTime dateTime) {
        return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_FULL_DATE));
    }
}
```
###### \java\seedu\todo\testutil\UiTestUtil.java
``` java
/**
 * This class stores all the commonly used helper functions that aids in GUI testing.
 */
public class UiTestUtil {

    /**
     * Checks if the node is displayed on the user interface by checking its properties.
     *
     * @param node The node to be tested for whether it is displayed on the UI.
     * @return Returns true if the node is displayed, false otherwise.
     */
    public static boolean isDisplayed(Node node) {
        //Checks if the node is hidden programatically
        boolean isVisible = node.isVisible();

        //Otherwise, check if the node is hidden with CSS styling
        boolean isCollapsed = parentContainsStyleClass(node, "collapsed");
        boolean isCollapsible = containsStyleClass(node, "collapsible");

        return isVisible && !(isCollapsed && isCollapsible);
    }

    public static boolean containsStyleClass(Node node, String styleClass) {
        return node.getStyleClass().contains(styleClass);
    }

    public static boolean parentContainsStyleClass(Node node, String styleClass) {
        return node.getStyleableParent().getStyleClass().contains(styleClass);
    }

    /**
     * Converts an index from a list to the index that is displayed to the user via the Ui
     */
    public static int convertToListIndex(int uiIndex) {
        return uiIndex - 1;
    }

    /**
     * Converts an index displayed on the Ui to the user, to the index used on the list
     */
    public static int convertToUiIndex(int listIndex) {
        return listIndex + 1;
    }

}
```
