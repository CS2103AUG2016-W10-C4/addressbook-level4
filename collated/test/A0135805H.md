# A0135805H
###### \java\guitests\AddCommandTest.java
``` java
/**
 * Test the add command via GUI.
 * Note:
 *      Order-ness of the tasks is not tested.
 *      Invalid command input is not tested.
 */
public class AddCommandTest extends TodoListGuiTest {

    @Test
    public void add_initialData() {
        //Test if the data has correctly loaded the data into view.
        assertTrue(todoListView.isDisplayedCorrectly());
    }

    @Test
    public void add_addTasks() {
        //Add a task
        ImmutableTask task1 = TaskFactory.task();
        executeAddTestHelper(task1);

        //Add another task
        ImmutableTask task2 = TaskFactory.task();
        executeAddTestHelper(task2);

        //Add duplicated task
        executeAddTestHelper(task2);
    }

    @Test
    public void add_addEvents() {
        //Add an event
        ImmutableTask event1 = TaskFactory.event();
        executeAddTestHelper(event1);

        //Add another event
        ImmutableTask event2 = TaskFactory.event();
        executeAddTestHelper(event2);

        //Add duplicated task
        executeAddTestHelper(event1);
    }

    @Test
    public void add_addManyRandom() {
        //Add a long list of random task, which in the end spans at least 2 pages.
        List<ImmutableTask> randomTaskList = TaskFactory.list(15, 25);
        randomTaskList.forEach(this::executeAddTestHelper);
    }

    /* Helper Methods */
    /**
     * Gets the index of the newly added task.
     */
    private int getNewlyAddedTaskIndex() {
        return TestUtil.compareAndGetIndex(previousTasksFromView, todoListView.getImmutableTaskList());
    }

    /**
     * A helper method to run the entire add command process and testing.
     */
    private void executeAddTestHelper(ImmutableTask task) {
        updatePreviousTaskListFromView();
        executeAddCommand(task);
        assertCorrectnessHelper(task);
    }

    /**
     * Executes an add command given a {@code task}
     */
    private void executeAddCommand(ImmutableTask task) {
        String commandText = CommandGeneratorUtil.generateAddCommand(task);
        runCommand(commandText);
    }

    private void assertCorrectnessHelper(ImmutableTask newTask) {
        int addedIndex = getNewlyAddedTaskIndex();
        TaskCardViewHandle taskCardHandle = todoListView.getTaskCardViewHandle(addedIndex);

        assertAddSuccess(taskCardHandle, newTask, addedIndex);
        assertCorrectFeedbackDisplayed(newTask);
        assertCollapsed(taskCardHandle);
    }

    /**
     * Check the two following areas:
     *      1. If the {@code task} added to the view is reflected correctly in it's own task card view.
     *      2. If the remaining task cards are present and still displayed correctly in their own
     *         respective card views.
     */
    private void assertAddSuccess(TaskCardViewHandle newTaskHandle, ImmutableTask newTask, int addedListIndex) {
        int expectedDisplayedIndex = UiTestUtil.convertToUiIndex(addedListIndex);

        //Test for the newly added task.
        assertTrue(newTaskHandle.isDisplayedCorrectly(expectedDisplayedIndex, newTask));

        //Test for remaining tasks.
        assertTrue(todoListView.isDisplayedCorrectly());
    }

    /**
     * Check if the correct feedback message for adding has been displayed to the user.
     */
    private void assertCorrectFeedbackDisplayed(ImmutableTask task) {
        assertFeedbackMessage("\'" + task.getTitle() + "\' successfully added!");
    }

    /**
     * Tasks should be collapsed when newly added.
     * Checks the case where if the task is collapsible, then the task is in the collapsed state when newly added.
     */
    private void assertCollapsed(TaskCardViewHandle newTask) {
        if (newTask.isTaskCollapsible()) {
            assertTrue(newTask.isTaskCardCollapsed());
        }
    }
}
```
###### \java\guitests\DeleteCommandTest.java
``` java
/**
 * Test the delete command via GUI.
 * Note:
 *      Invalid indices are not tested.
 */
public class DeleteCommandTest extends TodoListGuiTest {

    @Override
    protected TodoList getInitialData() {
        return getInitialDataHelper(10, 20);
    }

    @Test
    public void delete_correctBoundary() {
        //delete the last item in the list
        executeDeleteHelper(initialTaskData.size());

        //delete the first in the list (note that we initialised the size to be > 2.
        executeDeleteHelper(1);

    }

    @Test
    public void delete_allTasks() {
        //delete all the elements, until you have none left.
        Random random = new Random();
        int remainingTasks = initialTaskData.size();
        while (remainingTasks > 0) {
            int randomChoice = random.nextInt(remainingTasks--) + 1;
            executeDeleteHelper(randomChoice);
        }
    }

    /**
     * A helper method to run the entire delete command process and testing.
     */
    private void executeDeleteHelper(int displayedIndex) {
        ImmutableTask deletedTask = executeDeleteCommand(displayedIndex);
        assertDeleteSuccess(deletedTask);
        assertCorrectFeedbackDisplayed(deletedTask);
    }

    /**
     * Deletes a task from the to-do list view, and returns the deleted task for verification.
     */
    private ImmutableTask executeDeleteCommand(int displayedIndex) {
        int listIndex = UiTestUtil.convertToListIndex(displayedIndex);
        String commandText = CommandGeneratorUtil.generateDeleteCommand(displayedIndex);
        ImmutableTask deletedTask = todoListView.getTask(listIndex);

        runCommand(commandText);
        return deletedTask;
    }

    /**
     * Check if the {@code task} deleted from the view is reflected correctly (i.e. it's no longer there)
     * and check if the remaining tasks are displayed correctly.
     */
    private void assertDeleteSuccess(ImmutableTask deletedTask) {
        //Check if the task is really deleted.
        assertFalse(todoListView.getImmutableTaskList().contains(deletedTask));

        //Test if the remaining list is correct.
        assertTrue(todoListView.isDisplayedCorrectly());
    }

    /**
     * Check if the correct feedback message for deleting has been displayed to the user.
     */
    private void assertCorrectFeedbackDisplayed(ImmutableTask task) {
        assertFeedbackMessage("\'" + task.getTitle() + "\' successfully deleted!");
    }

}
```
###### \java\guitests\guihandles\CommandFeedbackViewHandle.java
``` java
/**
 * A handler for retrieving feedback to user via {@link CommandFeedbackView}
 */
public class CommandFeedbackViewHandle extends GuiHandle {
    /* Constants */
    public static final String FEEDBACK_VIEW_LABEL_ID = "#commandFeedbackLabel";

    /**
     * Constructs a handle to the {@link CommandFeedbackViewHandle}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public CommandFeedbackViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /**
     * Get the feedback {@link Label} object.
     */
    private Label getFeedbackLabel() {
        return (Label) getNode(FEEDBACK_VIEW_LABEL_ID);
    }

    /**
     * Get the text that is displayed on this {@link #getFeedbackLabel()} object.
     */
    public String getText() {
        return getFeedbackLabel().getText();
    }

    /**
     * Returns true if the {@code feedbackMessage} matches the displayed message in the view.
     */
    public boolean doesFeedbackMessageMatch(String feedbackMessage) {
        return this.getText().equals(feedbackMessage);
    }

    /**
     * Returns true if this feedback view has error style applied.
     */
    public boolean isErrorStyleApplied() {
        return UiTestUtil.containsStyleClass(getFeedbackLabel(), "error");
    }
}
```
###### \java\guitests\guihandles\CommandInputViewHandle.java
``` java
/**
 * A handle to the {@link CommandInputView}'s
 * command text box in the GUI.
 */
public class CommandInputViewHandle extends GuiHandle {
    /* Constants */
    private static final String COMMAND_INPUT_FIELD_ID = "#commandTextField";

    /**
     * Constructs a handle to the {@link CommandInputView}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public CommandInputViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /* Interfacing Methods */
    /**
     * Types in the supplied command into the text box in {@link CommandInputView}.
     *      Note: any existing text in the text box will be replaced.
     *      Note: this method will not execute the command. See {@link #runCommand(String)}.
     * @param command Command text to be supplied into the text box.
     */
    public void enterCommand(String command) {
        setTextAreaText(COMMAND_INPUT_FIELD_ID, command);
    }

    /**
     * Gets the command text that is inside the text box in {@link CommandInputView}.
     * @return A command text.
     */
    public String getCommandInput() {
        return getTextAreaText(COMMAND_INPUT_FIELD_ID);
    }

    /**
     * Enters the given command in the Command Box and presses enter.
     * @param command Command text to be executed.
     */
    public void runCommand(String command) {
        enterCommand(command);
        pressEnter();
        guiRobot.sleep(GUI_SLEEP_DURATION); //Give time for the command to take effect
    }

    /* Text View Helper Methods */
    /**
     * Gets the text stored in a text area given the id to the text area
     *
     * @param textFieldId ID of the text area.
     * @return Returns the text that is contained in the text area.
     */
    private String getTextAreaText(String textFieldId) {
        return ((TextArea) getNode(textFieldId)).getText();
    }

    /**
     * Keys in the given {@code newText} to the specified text area given its ID.
     *
     * @param textFieldId ID for the text area.
     * @param newText Text to be keyed in to the text area.
     */
    private void setTextAreaText(String textFieldId, String newText) {
        guiRobot.clickOn(textFieldId);
        TextArea textArea = (TextArea)guiRobot.lookup(textFieldId).tryQuery().get();
        Platform.runLater(() -> textArea.setText(newText));
        guiRobot.sleep(GUI_SLEEP_DURATION); // so that the texts stays visible on the GUI for a short period
    }
}
```
###### \java\guitests\guihandles\TaskCardViewHandle.java
``` java
/**
 * Provides a handle to a {@link TaskCardView}
 * that exists in {@link TodoListView}
 */
public class TaskCardViewHandle extends GuiHandle {

    /* Constants */
    private static final String TITLE_LABEL_ID = "#titleLabel";
    private static final String DESCRIPTION_LABEL_ID = "#descriptionLabel";
    private static final String DATE_LABEL_ID = "#dateLabel";
    private static final String LOCATION_LABEL_ID = "#locationLabel";

    private static final String DESCRIPTION_BOX_ID = "#descriptionBox";
    private static final String DATE_BOX_ID = "#dateBox";
    private static final String LOCATION_BOX_ID = "#locationBox";

    private static final String PIN_IMAGE_ID = "#pinImage";

    private static final String TYPE_LABEL_ID = "#typeLabel";
    private static final String MOREINFO_LABEL_ID = "#moreInfoLabel";

    /* Variables */
    private Node rootNode;

    /**
     * Constructs a handle for {@link TaskCardView}.
     *
     * @param guiRobot The GUI test robot.
     * @param primaryStage The main stage that is executed from the application's UI.
     * @param rootNode Node that houses the contents of this Task Card.
     */
    public TaskCardViewHandle(GuiRobot guiRobot, Stage primaryStage, Node rootNode){
        super(guiRobot, primaryStage, null);
        this.rootNode = rootNode;
    }

    /* Task Property Getters */
    public String getDisplayedTitle() {
        return getTextFromLabel(TITLE_LABEL_ID);
    }

    public String getDisplayedDescription() {
        return getTextFromLabel(DESCRIPTION_LABEL_ID);
    }

    public String getDisplayedDateText() {
        return getTextFromLabel(DATE_LABEL_ID);
    }

    public String getDisplayedLocation() {
        return getTextFromLabel(LOCATION_LABEL_ID);
    }

    public String getDisplayedTypeLabel() {
        return getTextFromLabel(TYPE_LABEL_ID);
    }

    public boolean getMoreInfoLabelVisibility() {
        Node moreInfoLabel = getNode(MOREINFO_LABEL_ID);
        return UiTestUtil.isDisplayed(moreInfoLabel);
    }

    public boolean getDescriptionBoxVisibility() {
        Node descriptionBox = getNode(DESCRIPTION_BOX_ID);
        return UiTestUtil.isDisplayed(descriptionBox);
    }

    public boolean getDateBoxVisibility() {
        Node dateBox = getNode(DATE_BOX_ID);
        return UiTestUtil.isDisplayed(dateBox);
    }

    public boolean getLocationBoxVisibility() {
        Node locationBox = getNode(LOCATION_BOX_ID);
        return UiTestUtil.isDisplayed(locationBox);
    }

    public boolean getPinImageVisibility() {
        Node pinImage = getNode(PIN_IMAGE_ID);
        return UiTestUtil.isDisplayed(pinImage);
    }

    public boolean isSelectedStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "selected");
    }

    public boolean isCompletedStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "completed");
    }

    public boolean isOverdueStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "overdue");
    }

    public boolean isTaskCardCollapsed() {
        return UiTestUtil.containsStyleClass(rootNode, "collapsed");
    }

    public boolean isTaskCollapsible() {
        return !getDisplayedDescription().isEmpty();
    }

    /* General Methods */
    /**
     * Checks if the supplied index matches to what this node displays.
     * To be used for nodes filtering.
     */
    public boolean matchesTask(int displayedIndex) {
        return getDisplayedTitle().startsWith(displayedIndex + ". ");
    }

    /**
     * Given an {@link ImmutableTask} and a displayed index, check if this view is displayed correctly.
     * @param displayedIndex Index displayed in the view.
     * @param task Task displayed in the view.
     * @return Returns true only if and only if the elements in this view is displayed correctly.
     * TODO: Maybe we do not need this at all.
     */
    public boolean isDisplayedCorrectly(int displayedIndex, ImmutableTask task) {
        //JUnit Assertion Test: To know which test are failing in detail
        assertTrue(isTitleCorrect(displayedIndex, task));
        assertTrue(isDescriptionCorrect(task));
        assertTrue(isTaskCardCollapsedStateCorrect());
        assertTrue(isCompletedDisplayCorrect(task));
        assertTrue(isDateTextCorrect(task));
        assertTrue(isLocationCorrect(task));
        assertTrue(isTypeDisplayCorrect(task));
        assertTrue(isPinDisplayCorrect(task));
        assertTrue(isOverdueDisplayCorrect(task));
        return true;
    }

    private boolean isTitleCorrect(int displayedIndex, ImmutableTask task) {
        String expected = convertToDisplayedTitle(displayedIndex, task.getTitle());
        String actual = getDisplayedTitle();
        return expected.equals(actual);
    }

    private boolean isDescriptionCorrect(ImmutableTask task) {
        java.util.Optional<String> description = task.getDescription();

        if (description.isPresent()) {
            //If there is a task description, it should match with the displayed description.
            String expected = description.get();
            String actual = getDisplayedDescription();
            return expected.equals(actual);
        } else {
            //Description should be hidden when there is no description.
            boolean expected = false;
            boolean actual = getDescriptionBoxVisibility();
            return expected == actual;
        }
    }

    private boolean isDateTextCorrect(ImmutableTask task) {
        java.util.Optional<LocalDateTime> startTime = task.getStartTime();
        java.util.Optional<LocalDateTime> endTime = task.getEndTime();

        TimeUtil timeUtil = new TimeUtil();

        String displayedDateText = getDisplayedDateText();
        String expectedDateText;

        if (!startTime.isPresent() && !endTime.isPresent()) {
            //Date box should be hidden when there is no start and end time.
            return !getDateBoxVisibility();
        } else if (startTime.isPresent() && endTime.isPresent()) {
            //When start and end date are available, expect event format
            expectedDateText = timeUtil.getEventTimeText(startTime.get(), endTime.get());
        } else if (endTime.isPresent()) {
            //When only end time is present, expect deadline format
            expectedDateText = timeUtil.getTaskDeadlineText(endTime.get());
        } else {
            //Otherwise, illegal date state.
            throw new IllegalStateException("Start time is present, but end time is not.");
        }
        return expectedDateText.equals(displayedDateText);
    }

    private boolean isLocationCorrect(ImmutableTask task) {
        java.util.Optional<String> location = task.getLocation();

        if (location.isPresent()) {
            //If there is a location, it should match with the displayed location.
            String expected = location.get();
            String actual = getDisplayedLocation();
            return expected.equals(actual);
        } else {
            //Description should be hidden when there is no description.
            boolean expected = false;
            boolean actual = getLocationBoxVisibility();
            return expected == actual;
        }
    }

    private boolean isPinDisplayCorrect(ImmutableTask task) {
        boolean expected = task.isPinned();
        boolean actual = getPinImageVisibility();
        return expected == actual;
    }

    private boolean isCompletedDisplayCorrect(ImmutableTask task) {
        boolean expected = task.isCompleted();
        boolean actual = isCompletedStyleApplied();
        return expected == actual;
    }

    private boolean isOverdueDisplayCorrect(ImmutableTask task) {
        java.util.Optional<LocalDateTime> endTime = task.getEndTime();
        boolean actual = isOverdueStyleApplied();
        boolean expected;

        if (endTime.isPresent() && !task.isEvent()) {
            expected = seedu.todo.testutil.TimeUtil.isOverdue(endTime.get());
        } else {
            expected = false;
        }
        return expected == actual;
    }

    private boolean isTypeDisplayCorrect(ImmutableTask task) {
        String actual = getDisplayedTypeLabel();
        String expected;

        if (task.isEvent()) {
            expected = "Event";
        } else {
            expected = "Task";
        }

        return expected.equals(actual);
    }

    public boolean isTaskCardCollapsedStateCorrect() {
        boolean collapsedStyleApplied = UiTestUtil.containsStyleClass(rootNode, "collapsed");
        boolean moreInfoLabelDisplayed = UiTestUtil.isDisplayed(getNode(MOREINFO_LABEL_ID));

        if (isTaskCollapsible()) {
            return collapsedStyleApplied == moreInfoLabelDisplayed;
        } else {
            return !moreInfoLabelDisplayed;
        }
    }

    /* View Elements Helper Methods */
    /**
     * Search and returns exactly one matching node.
     *
     * @param fieldId Field ID to search inside the parent node.
     * @return Returns one appropriate node that matches the {@code fieldId}.
     * @throws NullPointerException when no node with {@code fieldId} can be found, intentionally breaking the tests.
     */
    @Override
    protected Node getNode(String fieldId) throws NullPointerException {
        Optional<Node> node = guiRobot.from(rootNode).lookup(fieldId).tryQuery();
        if (node.isPresent()) {
            return node.get();
        } else {
            throw new NullPointerException("Node " + fieldId + " is not found.");
        }
    }

    /**
     * Gets a text from the node with {@code fieldId}.
     *
     * @param fieldId To get the node's text from.
     * @return Returns the text presented in the node.
     */
    private String getTextFromLabel(String fieldId) {
        return ((Label) getNode(fieldId)).getText();
    }

    /**
     * Converts {@code actualTitle} to a displayed title with the relevant {@code displayedIndex}.
     * @param displayedIndex The index that is shown on the title displayed to the user.
     * @param actualTitle The actual title of the task.
     * @return Returns a title text that is actually displayed to the user.
     */
    private String convertToDisplayedTitle(int displayedIndex, String actualTitle) {
        return displayedIndex + ". " + actualTitle;
    }

    /* Override Methods */
    @Override
    public boolean equals(Object obj) {
        if(obj instanceof TaskCardViewHandle) {
            TaskCardViewHandle handle = (TaskCardViewHandle) obj;

            boolean hasEqualTitle = this.getDisplayedTitle()
                    .equals(handle.getDisplayedTitle());
            boolean hasEqualDescription = this.getDisplayedDescription()
                    .equals(handle.getDisplayedDescription());
            boolean hasEqualDateText = this.getDisplayedDateText()
                    .equals(handle.getDisplayedDateText());
            boolean hasEqualLocation = this.getDisplayedLocation()
                    .equals(handle.getDisplayedLocation());
            boolean hasEqualType = this.getDisplayedTypeLabel()
                    .equals(handle.getDisplayedTypeLabel());
            boolean hasEqualMoreInfoVisibility = this.getMoreInfoLabelVisibility()
                    == handle.getMoreInfoLabelVisibility();
            boolean hasEqualDescriptionBoxVisibility = this.getDescriptionBoxVisibility()
                    == handle.getDescriptionBoxVisibility();
            boolean hasEqualDateBoxVisibility = this.getDateBoxVisibility()
                    == handle.getDateBoxVisibility();
            boolean hasEqualLocationBoxVisibility = this.getLocationBoxVisibility()
                    == handle.getLocationBoxVisibility();
            boolean hasEqualPinImageVisibility = this.getPinImageVisibility()
                    == handle.getPinImageVisibility();
            boolean hasEqualSelectedStyleApplied = this.isSelectedStyleApplied()
                    == handle.isSelectedStyleApplied();
            boolean hasEqualCompletedStyleApplied = this.isCompletedStyleApplied()
                    == handle.isCompletedStyleApplied();
            boolean hasEqualOverdueStyleApplied = this.isOverdueStyleApplied()
                    == handle.isOverdueStyleApplied();

            return hasEqualTitle && hasEqualDescription && hasEqualDateText
                    && hasEqualLocation && hasEqualType && hasEqualMoreInfoVisibility
                    && hasEqualDescriptionBoxVisibility && hasEqualDateBoxVisibility
                    && hasEqualLocationBoxVisibility && hasEqualPinImageVisibility
                    && hasEqualSelectedStyleApplied && hasEqualCompletedStyleApplied
                    && hasEqualOverdueStyleApplied;
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getDisplayedTitle() + " " + getDisplayedDescription();
    }
}
```
###### \java\guitests\guihandles\TodoListViewHandle.java
``` java
/**
 * Provides a handle for the {@link TodoListView}
 * containing a list of tasks.
 */
public class TodoListViewHandle extends GuiHandle {

    /* Constants */
    public static final int NOT_FOUND = -1;
    private static final String TASK_CARD_ID = "#taskCard";
    private static final String TODO_LIST_VIEW_ID = "#todoListView";

    /**
     * Constructs a handle for {@link TodoListView}.
     *
     * @param guiRobot The GUI test robot.
     * @param primaryStage The main stage that is executed from the application's UI.
     */
    public TodoListViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /* View Element Helper Methods */
    /**
     * Gets an instance of {@link ListView} of {@link TodoListView}
     */
    public ListView<ImmutableTask> getTodoListView() {
        return (ListView<ImmutableTask>) getNode(TODO_LIST_VIEW_ID);
    }

    /**
     * Gets a list of {@link ImmutableTask}
     */
    public List<ImmutableTask> getImmutableTaskList() {
        return getTodoListView().getItems();
    }

    /**
     * Gets a set of task card nodes in this to-do list.
     */
    public Set<Node> getAllTaskCardNodes() {
        return guiRobot.lookup(TASK_CARD_ID).queryAll();
    }

    /**
     * Gets a specific task from the list of tasks stored in the view by the list index.
     */
    public ImmutableTask getTask(int listIndex) {
        return getImmutableTaskList().get(listIndex);
    }

    /**
     * Gets the first occurring element from {@link #getImmutableTaskList()}
     * where the detail matches the {@code task} param.
     *
     * @return Returns a value bounded from 0 to length - 1.
     *         Also returns {@code NOT_FOUND} (value of -1) if not found in the list.
     */
    public int getFirstTaskIndex(ImmutableTask task) {
        List<ImmutableTask> tasks = getImmutableTaskList();
        for (int listIndex = 0; listIndex < tasks.size(); listIndex++) {
            ImmutableTask taskInList = tasks.get(listIndex);
            if (TestUtil.isShallowEqual(task, taskInList)) {
                return listIndex;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a {@link TaskCardViewHandle} object with the position {@code listIndex} located in the to-do list view.
     * Guaranteed unique result for identical tasks.
     * Inherits the behaviour from {@link #getTaskCardViewNode(int)}.
     *
     * @param listIndex Index of the {@link #getImmutableTaskList()}.
     * @return An instance of the handle.
     */
    public TaskCardViewHandle getTaskCardViewHandle(int listIndex) {
        Node taskCardNode = getTaskCardViewNode(listIndex);
        if (taskCardNode != null) {
            return new TaskCardViewHandle(guiRobot, primaryStage, taskCardNode);
        } else {
            return null;
        }
    }

    /**
     * Gets a {@link Node} object with the position {@code listIndex} located in the to-do list view.
     * Guarantees:
     *      -  Unique result for identical tasks, because we are referencing from the index displayed
     *         in the UI.
     *      -  The object returned will never be null.
     *         This means if I can't find the object, an exception will be thrown.
     * Behaviour:
     *      Because a task card node is only drawn when the task card is shown on the screen,
     *      this method will automatically scroll the to-do list view to the position where the
     *      node is drawn.
     *
     * @param listIndex Index of the {@link #getImmutableTaskList()}
     *                  (must be a valid value from 0 to length of task list - 1,
     *                  else {@link RuntimeException} is thrown.
     * @return An instance of the node. Guarantees non-null.
     * @throws NodeFinderException if we can't find the node after finite attempts.
     */
    private Node getTaskCardViewNode(int listIndex) throws NodeFinderException {
        int displayedIndex = UiTestUtil.convertToUiIndex(listIndex);
        Optional<Node> possibleNode;
        int attemptCounter = 0;

        do {
            Platform.runLater(() -> getTodoListView().scrollTo(listIndex));
            guiRobot.sleep(50 * attemptCounter++); //Allow the new nodes to be loaded from scrolling.

            Set<Node> taskCardNodes = getAllTaskCardNodes();
            possibleNode = taskCardNodes.stream().filter(node -> {
                TaskCardViewHandle taskCardView = new TaskCardViewHandle(guiRobot, primaryStage, node);
                return taskCardView.matchesTask(displayedIndex);
            }).findFirst();
        } while (!possibleNode.isPresent() && attemptCounter < 50);

        if (possibleNode.isPresent()) {
            return possibleNode.get();
        } else {
            String errorMessage = "Either the node fails to draw on the screen, or you provided an invalid index "
                                  + listIndex + " where the number of nodes is " + getAllTaskCardNodes().size();
            throw new NodeFinderException(errorMessage, NodeFinderException.ErrorType.NO_NODES_FOUND);
        }
    }

    /**
     * Checks if all the tasks stored inside the to-do list are displayed correctly.
     * Note: This does not check the sorted-ness of the list.
     * @return True if all the items are correctly displayed.
     */
    public boolean isDisplayedCorrectly() {
        return doesTodoListMatch();
    }

    /**
     * Given a list of tasks, check if all the tasks in the list are displayed correctly in the
     * {@link TodoListView}.
     * Note: this does not check the sorted-ness of the list.
     *
     * @return True if all the tasks in the {@code tasks} are displayed correctly.
     */
    public boolean doesTodoListMatch() {
        boolean outcome = true;
        List<ImmutableTask> tasks = getImmutableTaskList();
        for (int listIndex = 0; listIndex < tasks.size(); listIndex++) {
            ImmutableTask task = tasks.get(listIndex);
            TaskCardViewHandle handle = getTaskCardViewHandle(listIndex);
            int displayedIndex = UiTestUtil.convertToUiIndex(listIndex);
            outcome &= handle.isDisplayedCorrectly(displayedIndex, task);
        }
        return outcome;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point= TestUtil.getScreenMidPoint(getTodoListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code tasks} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ImmutableTask... tasks) {
        List<ImmutableTask> taskList = getImmutableTaskList();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + tasks.length > taskList.size()){
            return false;
        }

        // Return false if any of the task doesn't match
        for (int i = 0; i < tasks.length; i++) {
            ImmutableTask taskInView = taskList.get(i);
            ImmutableTask taskInList = tasks[i];
            if (!taskInView.equals(taskInList)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Navigates the {@link TodoListView} to display and select the task.
     * @param listIndex Index of the list that the list view should navigate to.
     * @return Handle of the selected task.
     */
    public TaskCardViewHandle navigateToTask(int listIndex) {
        guiRobot.interact(() -> {
            getTodoListView().scrollTo(listIndex);
            guiRobot.sleep(150);
            getTodoListView().getSelectionModel().select(listIndex);
        });
        guiRobot.sleep(100);
        return getTaskCardViewHandle(listIndex);
    }
}
```
###### \java\seedu\todo\commons\util\StringUtilTest.java
``` java
    @Test
    public void partitionStringAtPosition_emptyString() {
        String[] expected = {"", "", ""};

        //Tests null string
        testPartitionStringAtPositionHelper(null, 0, expected);

        //Test empty String
        testPartitionStringAtPositionHelper("", 0, expected);
    }

    @Test
    public void partitionStringAtPosition_positionOutOfBounds() {
        String input = "I have a Pikachu";
        String[] expected = {"", "", ""};

        //Tests position too low
        testPartitionStringAtPositionHelper(input, -1, expected);

        //Tests position too high
        testPartitionStringAtPositionHelper(input, 16, expected);
    }

    @Test
    public void partitionStringAtPosition_partitionCorrectly() {
        String input = "I have a Pikachu";

        //Test lower bound
        testPartitionStringAtPositionHelper(input, 0, new String[] {"", "I", " have a Pikachu"});

        //Test upper bound
        testPartitionStringAtPositionHelper(input, 15, new String[] {"I have a Pikach", "u", ""});

        //Test normal partition
        testPartitionStringAtPositionHelper(input, 5, new String[] {"I hav", "e", " a Pikachu"});
    }

    /**
     * Helper method to test partitionStringAtPosition(...).
     * @param input String to be partitioned.
     * @param position Position where partition should take place.
     * @param expected Expected output as String array.
     */
    private void testPartitionStringAtPositionHelper(String input, int position, String[] expected) {
        String[] outcome = StringUtil.partitionStringAtPosition(input, position);
        assertArrayEquals(expected, outcome);
    }

    @Test
    public void splitString_emptyInput() {
        String[] expected = new String[0];

        //Test null input.
        testSplitStringHelper(null, expected);

        //Test empty input.
        testSplitStringHelper("", expected);

        //Test only space and commas.
        testSplitStringHelper(" , ,   ,,, ,,,, , , ,,, , ,", expected);
    }

    @Test
    public void splitString_validInput() {
        //Input does not include space and comma
        testSplitStringHelper("!@(*&$!R#@%", new String[]{"!@(*&$!R#@%"});

        //Test one element
        testSplitStringHelper("Pichu-Pikachu_RAICHU's", new String[] {"Pichu-Pikachu_RAICHU's"});

        //Test multiple element split by space and comma
        testSplitStringHelper("an apple a, day, keeps , , doctor ,,, away", new String[] {"an", "apple", "a", "day", "keeps", "doctor", "away"});
    }

    /**
     * Helper method to test splitString(...).
     * @param input String to be split.
     * @param expected Expected output as String array.
     */
    private void testSplitStringHelper(String input, String[] expected) {
        String[] outcome = StringUtil.splitString(input);
        assertArrayEquals(expected, outcome);
    }

    @Test
    public void testConvertListToString_emptyList() {
        String expected = "";

        //Test null list
        testConvertListToStringHelper(null, expected);

        //Test empty list
        testConvertListToStringHelper(new String[0], expected);
    }

    @Test
    public void testConvertListToString_validInput() {
        //Test one element
        testConvertListToStringHelper(new String[]{"applepie123!"}, "applepie123!");

        //Test several elements
        testConvertListToStringHelper(new String[]{"this", "is", "apple", "pen"}, "this, is, apple, pen");
    }

    /**
     * Helper method to test splitString(...).
     * @param input String to be split.
     * @param expected Expected output as String array.
     */
    private void testConvertListToStringHelper(String[] input, String expected) {
        String outcome = StringUtil.convertListToString(input);
        assertEquals(expected, outcome);
    }
```
###### \java\seedu\todo\commons\util\TimeUtilTest.java
``` java
    /**
     * A subclass of TimeUtil that provides the ability to override the current system time, 
     * so that time sensitive components can be conveniently tested. 
     */
    private class ModifiedTimeUtil extends TimeUtil {
        
        /**
         * Construct a ModifiedTimeUtil object overriding the current time with Clock object.
         * Is only used for dependency injection in testing time sensitive components.
         */
        private ModifiedTimeUtil(Clock clock) {
            this.clock = clock;
        }
        
        /**
         * Construct a ModifiedTimeUtil object overriding the current time with LocalDateTime object.
         * Is only used for dependency injection in testing time sensitive components.
         */
        public ModifiedTimeUtil(LocalDateTime pseudoCurrentTime) {
            this(Clock.fixed(pseudoCurrentTime.toInstant(
                    ZoneId.systemDefault().getRules().getOffset(pseudoCurrentTime)), ZoneId.systemDefault()));
        }
    }
    
    /**
     * Aids to test taskDeadlineText with a current time and due time, against an expected output.
     */
    private void testTaskDeadlineTextHelper(String expectedOutput, LocalDateTime currentTime, LocalDateTime dueTime) {
        TimeUtil timeUtil = new ModifiedTimeUtil(currentTime);
        String generatedOutput = timeUtil.getTaskDeadlineText(dueTime);
        assertEquals(expectedOutput, generatedOutput);
    }

    /**
     * Aids to test eventTimeText with a current time, startTime and endTime, against an expected output.
     */
    private void testEventTimeTextHelper(String expectedOutput, LocalDateTime currentTime,
                                         LocalDateTime startTime, LocalDateTime endTime) {
        TimeUtil timeUtil = new ModifiedTimeUtil(currentTime);
        String generatedOutput = timeUtil.getEventTimeText(startTime, endTime);
        assertEquals(expectedOutput, generatedOutput);
    }
        
    @Test
    public void getTaskDeadlineString_nullEndTime() {
        testTaskDeadlineTextHelper("", LocalDateTime.now(), null);
    }
    
    @Test
    public void getTaskDeadlineText_dueNow() {
        String expectedOutput = "due now";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);
        
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0), dueTime);
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 59), dueTime);
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 30), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_dueLessThanAMinute() {
        String expectedOutput = "in less than a minute";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);
        
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 1), dueTime);
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 59), dueTime);
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 30), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_aMinuteBeforeDeadline() {
        String expectedOutput = "in 1 minute";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);
        
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 0), dueTime);
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 58, 30), dueTime);
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 58, 1), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_aMinuteAfterDeadline() {
        String expectedOutput = "1 minute ago";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);
        
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 1, 0), dueTime);
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 1, 30), dueTime);
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 1, 59), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_minutesBeforeDeadline() {
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);
        
        for (int minutesLeft = 2; minutesLeft <= 59; minutesLeft++) {
            String expectedOutput = "in " + minutesLeft + " minutes";
            
            testTaskDeadlineTextHelper(expectedOutput, dueTime.minusMinutes(minutesLeft), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.minusMinutes(minutesLeft).minusSeconds(30), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.minusMinutes(minutesLeft).minusSeconds(59), dueTime);
        }
    }
    
    @Test
    public void getTaskDeadlineText_minutesAfterDeadline() {
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);
        
        for (int minutesLater = 2; minutesLater <= 59; minutesLater++) {
            String expectedOutput = minutesLater + " minutes ago";
            
            testTaskDeadlineTextHelper(expectedOutput, dueTime.plusMinutes(minutesLater), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.plusMinutes(minutesLater).plusSeconds(30), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.plusMinutes(minutesLater).plusSeconds(59), dueTime);
        }
    }
    
    @Test
    public void getTaskDeadlineText_todayBeforeDeadline() {
        testTaskDeadlineTextHelper("by today, 5:59 PM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 10, 45), LocalDateTime.of(2016, Month.MARCH, 20, 17, 59));
        testTaskDeadlineTextHelper("by tonight, 6:00 PM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 11, 58), LocalDateTime.of(2016, Month.MARCH, 20, 18, 0));
        testTaskDeadlineTextHelper("in 30 minutes", 
                LocalDateTime.of(2016, Month.MARCH, 20, 0, 0), LocalDateTime.of(2016, Month.MARCH, 20, 0, 30));
    }
    
    @Test
    public void getTaskDeadlineText_todayAfterDeadline() {
        testTaskDeadlineTextHelper("since today, 12:00 PM",
                LocalDateTime.of(2016, Month.MARCH, 20, 18, 45), LocalDateTime.of(2016, Month.MARCH, 20, 12, 0));
        testTaskDeadlineTextHelper("since tonight, 6:50 PM",
                LocalDateTime.of(2016, Month.MARCH, 20, 23, 58), LocalDateTime.of(2016, Month.MARCH, 20, 18, 50));
        testTaskDeadlineTextHelper("30 minutes ago", 
                LocalDateTime.of(2016, Month.MARCH, 20, 0, 30), LocalDateTime.of(2016, Month.MARCH, 20, 0, 0));
    }
    
    @Test
    public void getTaskDeadlineText_tomorrowBeforeDeadline() {
        testTaskDeadlineTextHelper("by tomorrow, 12:00 PM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 12, 0), LocalDateTime.of(2016, Month.MARCH, 21, 12, 0));
        testTaskDeadlineTextHelper("by tomorrow, 12:51 AM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 23, 50), LocalDateTime.of(2016, Month.MARCH, 21, 0, 51));
        testTaskDeadlineTextHelper("in 20 minutes", 
                LocalDateTime.of(2016, Month.MARCH, 20, 23, 50), LocalDateTime.of(2016, Month.MARCH, 21, 0, 10));
    }
    
    @Test
    public void getTaskDeadlineText_yesterdayAfterDeadline() {
        testTaskDeadlineTextHelper("since yesterday, 12:00 PM", 
                LocalDateTime.of(2016, Month.MARCH, 21, 12, 0), LocalDateTime.of(2016, Month.MARCH, 20, 12, 0));
        testTaskDeadlineTextHelper("since yesterday, 12:51 AM",
                LocalDateTime.of(2016, Month.MARCH, 21, 23, 50), LocalDateTime.of(2016, Month.MARCH, 20, 0, 51));
        testTaskDeadlineTextHelper("20 minutes ago", 
                LocalDateTime.of(2016, Month.MARCH, 21, 0, 10), LocalDateTime.of(2016, Month.MARCH, 20, 23, 50));
    }
    
    @Test
    public void getTaskDeadlineText_thisYearBeforeDeadline() {
        testTaskDeadlineTextHelper("by 12 August, 12:55 PM", 
                LocalDateTime.of(2016, Month.JANUARY, 21, 12, 0), LocalDateTime.of(2016, Month.AUGUST, 12, 12, 55));
        testTaskDeadlineTextHelper("by 15 September, 12:00 AM",
                LocalDateTime.of(2016, Month.SEPTEMBER, 13, 23, 59), LocalDateTime.of(2016, Month.SEPTEMBER, 15, 0, 0));
    }
    
    @Test
    public void getTaskDeadlineText_thisYearAfterDeadline() {
        testTaskDeadlineTextHelper("since 21 January, 8:47 PM", 
                LocalDateTime.of(2016, Month.AUGUST, 12, 12, 55), LocalDateTime.of(2016, Month.JANUARY, 21, 20, 47));
        testTaskDeadlineTextHelper("since 13 September, 11:59 PM",
                LocalDateTime.of(2016, Month.SEPTEMBER, 15, 0, 0), LocalDateTime.of(2016, Month.SEPTEMBER, 13, 23, 59));
    }
    
    @Test
    public void getTaskDeadlineText_differentYearBeforeDeadline() {
        testTaskDeadlineTextHelper("in 1 minute", 
                LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59), LocalDateTime.of(2017, Month.JANUARY, 1, 0, 0));
        testTaskDeadlineTextHelper("by tomorrow, 1:15 AM",
                LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 0), LocalDateTime.of(2017, Month.JANUARY, 1, 1, 15));
        testTaskDeadlineTextHelper("by 31 January 2017, 1:05 AM",
                LocalDateTime.of(2016, Month.JUNE, 30, 22, 0), LocalDateTime.of(2017, Month.JANUARY, 31, 1, 5));
        testTaskDeadlineTextHelper("by 31 August 2020, 12:35 PM",
                LocalDateTime.of(2016, Month.FEBRUARY, 13, 13, 0), LocalDateTime.of(2020, Month.AUGUST, 31, 12, 35));
    }
    
    @Test
    public void getTaskDeadlineText_differentYearAfterDeadline() {
        testTaskDeadlineTextHelper("1 minute ago", 
                LocalDateTime.of(2017, Month.JANUARY, 1, 0, 0), LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59));
        testTaskDeadlineTextHelper("since yesterday, 12:00 AM",
                LocalDateTime.of(2017, Month.JANUARY, 1, 0, 0), LocalDateTime.of(2016, Month.DECEMBER, 31, 0, 0));
        testTaskDeadlineTextHelper("since 30 June 2016, 10:00 PM",
                LocalDateTime.of(2017, Month.JANUARY, 31, 1, 5), LocalDateTime.of(2016, Month.JUNE, 30, 22, 0));
        testTaskDeadlineTextHelper("since 13 February 2016, 1:00 PM",
                LocalDateTime.of(2020, Month.AUGUST, 31, 12, 35), LocalDateTime.of(2016, Month.FEBRUARY, 13, 13, 0));
    }
    
    @Test
    public void getEventTimeText_nullStartTime() {
        testEventTimeTextHelper("", LocalDateTime.now(), null, LocalDateTime.now().plusMinutes(1));
    }
    
    @Test
    public void getEventTimeText_nullEndTime() {
        testEventTimeTextHelper("", LocalDateTime.now(), LocalDateTime.now().plusMinutes(1), null);
    }

    @Test
    public void getEventTimeText_sameDay() {
        LocalDateTime currentTime = LocalDateTime.of(2016, 10, 20, 12, 00);
        testEventTimeTextHelper("yesterday, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2016, 10, 19, 20, 30));
        testEventTimeTextHelper("today, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 16, 50), LocalDateTime.of(2016, 10, 20, 20, 30));
        testEventTimeTextHelper("tonight, from 6:00 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 18, 00), LocalDateTime.of(2016, 10, 20, 20, 30));
        testEventTimeTextHelper("tomorrow, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 21, 16, 50), LocalDateTime.of(2016, 10, 21, 20, 30));
        testEventTimeTextHelper("21 November, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 11, 21, 16, 50), LocalDateTime.of(2016, 11, 21, 20, 30));
        testEventTimeTextHelper("21 November 2017, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2017, 11, 21, 16, 50), LocalDateTime.of(2017, 11, 21, 20, 30));
    }

    @Test
    public void getEventTimeText_differentDay() {
        LocalDateTime currentTime = LocalDateTime.of(2016, 10, 20, 12, 00);
        testEventTimeTextHelper("from yesterday, 4:50 PM to today, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2016, 10, 20, 14, 30));
        testEventTimeTextHelper("from yesterday, 4:50 PM to tonight, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2016, 10, 20, 20, 30));
        testEventTimeTextHelper("from today, 4:50 PM to tomorrow, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 16, 50), LocalDateTime.of(2016, 10, 21, 20, 30));
        testEventTimeTextHelper("from tonight, 6:50 PM to tomorrow, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 18, 50), LocalDateTime.of(2016, 10, 21, 20, 30));
        testEventTimeTextHelper("from tomorrow, 6:50 PM to 22 October, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 21, 18, 50), LocalDateTime.of(2016, 10, 22, 20, 30));
        testEventTimeTextHelper("from 18 October, 6:50 PM to 22 October, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 18, 18, 50), LocalDateTime.of(2016, 10, 22, 20, 30));
    }

    @Test
    public void getEventTimeText_differentYear() {
        LocalDateTime currentTime = LocalDateTime.of(2016, 12, 31, 12, 00);
        testEventTimeTextHelper("from 19 October, 4:50 PM to 3 January 2017, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2017, 1, 3, 14, 30));
        testEventTimeTextHelper("from 19 October, 4:50 PM to tomorrow, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2017, 1, 1, 14, 30));
        testEventTimeTextHelper("from today, 4:50 PM to 4 January 2017, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 12, 31, 16, 50), LocalDateTime.of(2017, 1, 4, 14, 30));
    }
    
    @Test
    public void isOverdue_nullEndTime() {
        TimeUtil timeUtil = new TimeUtil();
        assertFalse(timeUtil.isOverdue(null));
    }
    
    @Test
    public void isOverdue_endTimeAfterNow() {
        TimeUtil timeUtil = new ModifiedTimeUtil(LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 34));
        LocalDateTime laterEndTime = LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 35);
        assertFalse(timeUtil.isOverdue(laterEndTime));
    }
    
    @Test
    public void isOverdue_endTimeBeforeNow() {
        TimeUtil timeUtil = new ModifiedTimeUtil(LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 36));
        LocalDateTime laterEndTime = LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 35);
        assertTrue(timeUtil.isOverdue(laterEndTime));
    }

```
###### \java\seedu\todo\testutil\TaskFactory.java
``` java
    /**
     * Generates a list of random tasks with a random size between {@code lowerBound}
     * and {@code upperBound} inclusive.
     *
     * @return Returns a randomly generated list.
     */
    public static List<ImmutableTask> list(int lowerBound, int upperBound) {
        int size = lowerBound + random.nextInt(upperBound - lowerBound + 1);
        ArrayList<ImmutableTask> tasks = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            tasks.add(random());
        }
        return tasks;
    }
}
```
###### \java\seedu\todo\testutil\TimeUtil.java
``` java
    /**
     * Checks against system time if the provided dueTime is before system time.
     *
     * @param dueTime The due time to check against with the current system time.
     * @return Returns true if the provided dueTime is before system time.
     */
    public static boolean isOverdue(LocalDateTime dueTime) {
        return dueTime.isBefore(LocalDateTime.now());
    }

    /**
     * Gets the complete date time text in the following format:
     *      12 August 2015, 12:34 PM
     */
    public static String getDateTimeText(LocalDateTime dateTime) {
        return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_FULL_DATE));
    }
}
```
