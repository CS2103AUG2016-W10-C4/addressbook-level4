# A0135805H
###### \build\resources\main\style\DefaultStyle.css
``` css
.main {
    -fx-background-color: #2D2D2D;
    -fx-border-color: #00A4FF;
    -fx-border-width: 1px;
    -fx-padding: 12;
    -fx-spacing: 4;
}

.text1 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI Black";
    -fx-font-size: 17pt;
}

.text2 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI Semibold";
    -fx-font-size: 15pt;
}

.text3 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI Semibold";
    -fx-font-size: 13pt;
}

.text4 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI";
    -fx-font-size: 12pt;
}

.code {
    -fx-font-family: "Consolas";
}

.bolder {
    -fx-font-weight: bolder;
}

.underline {
    -fx-underline: true;
}

.gridPanel {
    -fx-hgap: 16pt;
    -fx-vgap: 2pt;
    -fx-background-color: #3D3D3D;
    -fx-padding: 8 8 8 8;
}

.spacingBig {
    -fx-spacing: 16px;
    -fx-hgap: 16px;
    -fx-vgap: 16px;
}

.spacing {
    -fx-spacing: 8px;
    -fx-hgap: 8px;
    -fx-vgap: 8px;
}

.spacingSmall {
    -fx-spacing: 2px;
    -fx-hgap: 2px;
    -fx-vgap: 2px;
}

.subheadingPadding {
    -fx-padding: 0 0 0 2;
}


.commandFeedback{
    -fx-text-fill: #FFFFFF;
    -fx-font-family: "Segoe UI";
    -fx-font-size: 12pt;
}

.commandFeedback.error {
    -fx-text-fill: #FF6464;
}

.commandInput {
    -fx-font-family: "Consolas";
    -fx-font-size: 20px;
}

.commandInput.error {
    -fx-border-color: #FF6464;
    -fx-border-width: 2px;
    -fx-text-fill: #FF6464;
}

.commandError {
    -fx-text-fill: #FFFFFF;
    -fx-font-family: "Segoe UI";
    -fx-font-size: 12pt;
    -fx-wrap-text: true;
}

.roundLabel {
    -fx-background-radius: 10;
    -fx-text-fill: #ffffff;
    -fx-background-color: #2D2D2D;
    -fx-font-size: 10pt;
    -fx-font-family: "Segoe UI Semilight";
}

/***View Filter Styles Start***/
.viewFilter .label{
    -fx-font-family: "Segoe UI";
    -fx-font-size: 14pt;
    -fx-text-fill: #FFFFFF;
}

.viewFilter .selected {
    -fx-background-color: #FFFFFF;
    -fx-background-radius: 100;
    -fx-padding: 0 8 0 8;
}

.viewFilter .selected .label {
    -fx-text-fill: #2D2D2D;
    -fx-font-family: "Segoe UI Semibold";
}

```
###### \build\resources\main\style\DefaultStyle.css
``` css
/***TaskCardView Styles Start***/
/*Default and Base*/
.taskCard .label {
    -fx-font-smoothing-type: lcd;
}

.taskCard .titleLabel {
    -fx-font-size: 16pt;
    -fx-font-family: "Segoe UI Semibold";
}

.taskCard .descriptionLabel {
    -fx-font-size: 12pt;
    -fx-font-family: "Segoe UI";
}

.taskCard .footnoteLabel {
    -fx-font-size: 10pt;
    -fx-font-family: "Segoe UI Semilight";
    -fx-font-style: italic;
}

.taskCard .highlightedBackground {
    -fx-background-color: #00A4FF;
}

.taskCard .lightBackground {
    -fx-background-color: #d2d2d2;
}

.taskCard .pinImage {
    -fx-image: url("../images/star_gold.png");
    -fx-fit-to-width: 30px;
    -fx-fit-to-height: 30px;
}

.taskCard .dateImage {
    -fx-image: url("../images/clock_black.png");
    -fx-fit-to-width: 20px;
    -fx-fit-to-height: 20px;
}

.taskCard .locationImage {
    -fx-image: url("../images/location_black.png");
    -fx-fit-to-width: 20px;
    -fx-fit-to-height: 20px;
}

/*Completed*/
.completed .label{
    -fx-text-fill: #7F7F7F;
}

.completed .titleLabel .text {
    -fx-strikethrough: true;
}

.completed .roundLabel {
    -fx-background-color: #7F7F7F;
    -fx-text-fill: #ffffff;
}

.completed .pinImage {
    -fx-image: url("../images/star_grey.png");
}

.completed .dateImage {
    -fx-image: url("../images/clock_grey.png");
}

.completed .locationImage {
    -fx-image: url("../images/location_grey.png");
}

/*Overdue*/
.overdue {
    -fx-background-color: #FF6464;
}

.overdue .label {
    -fx-text-fill: #FFFFFF;
}

.overdue .roundLabel {
    -fx-background-color: #FFFFFF;
    -fx-text-fill: #FF6464;
}

.overdue .pinImage {
    -fx-image: url("../images/star_white.png");
}

.overdue .dateImage {
    -fx-image: url("../images/clock_white.png");
}

.overdue .locationImage {
    -fx-image: url("../images/location_white.png");
}


```
###### \build\resources\main\style\DefaultStyle.css
``` css
/*Selected*/
.selected {
    -fx-background-color: #00A4FF;
}

.selected .label {
    -fx-text-fill: #FFFFFF;
}

.selected .roundLabel {
    -fx-background-color: #FFFFFF;
    -fx-text-fill: #00A4FF;
}

.selected .pinImage {
    -fx-image: url("../images/star_white.png");
}

.selected .dateImage {
    -fx-image: url("../images/clock_white.png");
}

.selected .locationImage {
    -fx-image: url("../images/location_white.png");
}

/*Collapse*/
.collapsed .collapsible {
    visibility: collapse;
    -fx-pref-height: 0px;
    -fx-min-height: 0px;
}

/***TaskCardView Styles End***/

```
###### \docs\DeveloperGuide.md
``` md
### UI component

<img src="diagrams/Ui Component.png" />

<figcaption>The relation between the UI subcomponents</figcaption>

The UI component handles the interaction between the user and application. In particular, the UI is responsible for passing the textual command input from the user to the `Logic` for execution, and displaying the outcome of the execution to the user via the GUI.

<img src="diagrams/Ui Image.png" />

<figcaption>Visual identification of view elements in the UI</figcaption>

**API** : [`Ui.java`](../src/main/java/seedu/todo/ui/Ui.java)

The UI mainly consists of a `MainWindow`, as shown in the diagram above. This is where most of the interactions between the user and the application happen here. The `MainWindow` contains several major view elements that are discussed in greater detail below:

#### Command Line Interface
The UI aims to imitate the Command Line Interface (CLI) closely by accepting textual commands from users, and displaying textual feedback back to the users. The CLI consists of:

- `CommandInputView` - a text box for users to key in their commands
- `CommandFeedbackView` - a single line text that provides a response to their commands
- `CommandErrorView` - a detailed breakdown of any erroneous commands presented with a table

These view classes are represented by the `CommandXView` class in the UML diagram above. 

The `CommandController` class is introduced to link the three classes together, so they can work and communicate with each other. The `CommandController`:

1. Obtains a user-supplied command string from the `CommandInputView`
2. Submits the command string to `Logic` for execution
3. Receives a `CommandResult` from `Logic` after the execution
4. Displays the execution outcome via the `CommandResult` to the `CommandFeedbackView` and `CommandErrorView`

#### To-do List Display
A to-do list provides a richer representation of the tasks than the CLI to the users. The To-do List Display consists of: 

- `TodoListView` - a [`ListView`](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/ListView.html) that displays a list of `TaskCard`.
- `TaskCard` - an item in the `TodoListView` that displays details of a specific task.

Specifically, the `TodoListView` attaches an `ObservableList` of `ImmutableTask` from the `Model` and listens to any changes that are made to the `ObservableList`. If there are any modifications made, the `TaskCard` and `TodoListView` are updated automatically.

#### Additional Information
All these view classes, including the `MainWindow`, inherit from the abstract `UiPart` class. They can be loaded using the utility class `UiPartLoader`.

The UI component uses [JavaFX](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-overview.htm#JFXST784) UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the [`CommandInputView`](../src/main/java/seedu/todo/ui/view/CommandInputView.java) is specified in [`CommandInputView.fxml`](../src/main/resources/view/CommandInputView.fxml)

Other than through `CommandResult` and `ObservableList`, you may also invoke changes to the GUI outside the scope of UI components by raising an event. `UiManager` will then call specific view elements to update the GUI accordingly. For example, you may show the `HelpView` by raising a `ShowHelpPanel` via the `EventsCentre`.

```
###### \docs\UserGuide.md
``` md
## Introduction

In today's hectic society, our lives feel like a never-ending procession of tasks, deadlines, events and anniversaries to keep up with. Tracking these daily activities on a to-do list can be daunting. Many task management applications today have too many buttons that you have to click through just to add a task, and user interfaces that are so cumbersome it is hard for you to make it a habit to use.

Ever wished for a tool that can manage all your daily activities in distinct categories, and suggest to you which one you want to complete first? Well, look no further as Uncle Jim's Discount To-do List is here to save your day.

Uncle Jim's Discount To-do List (Uncle Jim in short) is a revolutionary mouse-free personal task manager that helps you to keep track of your daily activities through the power of your keyboard. Gone are the days when you had to click through several pages of menus just to add a simple task to your schedule. Our command line interface is not only flexible but remarkably easy to use. Just type the command and hit enter!

Moreover, we know that you understand your activities better. So Uncle Jim allows you to create your very own categories to organise your activities. Uncle Jim is also capable of managing both tasks *and* event so you don't have to use two different applications to be productive. Our unique product will intelligently sieve out urgent deadlines and serve up reminders for you so you will no longer overlook another significant activity.

Sounds exciting? Then let's get started!

```
###### \src\main\java\seedu\todo\commons\events\ui\ExpandCollapseTaskEvent.java
``` java
/**
 * An event to tell the Ui to collapse or expand a given task in the to-do list.
 */
public class ExpandCollapseTaskEvent extends BaseEvent{

    public final ImmutableTask task;

    /**
     * Construct an event that tells the Ui to collapse or expend a given task in the to-do list.
     * @param task a single index of the task that is matching to the Ui (index 1 to num of tasks, inclusive)
     */
    public ExpandCollapseTaskEvent(ImmutableTask task) {
        this.task = task;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \src\main\java\seedu\todo\commons\util\StringUtil.java
``` java
    /**
     * Partitions the string into three parts:
     *      string[0 .. position - 1], string[position], string[position + 1 .. length - 1], all index inclusive
     * @param string to be partitioned
     * @param position location where the string should be partitioned
     * @return a String array containing the three elements stated above,
     *         where each element must not be null, but can have empty string.
     */
    public static String[] partitionStringAtPosition(String string, int position) {
        String[] stringArray = new String[3];
        if (string == null || string.isEmpty() || position < 0 || position >= string.length()) {
            stringArray[0] = "";
            stringArray[1] = "";
            stringArray[2] = "";
        } else {
            stringArray[0] = string.substring(0, position);
            stringArray[1] = string.substring(position, position + 1);
            stringArray[2] = string.substring(position + 1, string.length());
        }
        return stringArray;
    }

    /**
     * Splits string at only space and comma.
     * @return Returns a String array with all the split components of the string.
     */
    public static String[] splitString(String string) {
        if (string == null || string.isEmpty()) {
            return new String[0];
        } else {
            return string.trim().split("([, ])+");
        }
    }

    /**
     * Given a string list, gets the text from the list in the following manner:
     *      apple, pear, pineapple
     */
    public static String convertListToString(String[] stringList) {
        if (stringList == null || stringList.length == 0) {
            return "";
        }
        StringJoiner stringJoiner = new StringJoiner(", ");
        for (String string : stringList) {
            stringJoiner.add(string);
        }
        return stringJoiner.toString();
    }

```
###### \src\main\java\seedu\todo\commons\util\TimeUtil.java
``` java
/**
 * Utility methods that deals with time.
 */
public class TimeUtil {

    /* Constants */
    private static final Logger logger = LogsCenter.getLogger(TimeUtil.class);

    private static final String WORD_IN = "in";
    private static final String WORD_BY = "by";
    private static final String WORD_SINCE = "since";
    private static final String WORD_AGO = "ago";
    private static final String WORD_FROM = "from";
    private static final String WORD_TO = "to";
    private static final String WORD_TOMORROW = "tomorrow";
    private static final String WORD_YESTERDAY = "yesterday";
    private static final String WORD_TODAY = "today";
    private static final String WORD_TONIGHT = "tonight";
    private static final String WORD_COMMA = ",";
    private static final String WORD_SPACE = " ";

    private static final String DUE_NOW = "due now";
    private static final String DUE_LESS_THAN_A_MINUTE = "in less than a minute";

    private static final String UNIT_MINUTES = "minutes";
    private static final String VALUE_ONE_MINUTE = "1 minute";

    private static final String FORMAT_DATE_WITH_YEAR = "d MMMM yyyy";
    private static final String FORMAT_DATE_NO_YEAR = "d MMMM";
    private static final String FORMAT_TIME = "h:mm a";
    
    private static final Pattern DATE_REGEX = Pattern.compile("\\b([0123]?\\d)([/-])([01]?\\d)(?=\\2\\d{2,4}|\\s|$)");
    
    /* Variables */
    protected Clock clock = Clock.systemDefaultZone();
    
    /**
     * Gets the task deadline expression for the UI.
     * @param endTime ending time
     * @return a formatted deadline String
     */
    public String getTaskDeadlineText(LocalDateTime endTime) {
        if (endTime == null) {
            logger.log(Level.WARNING, "endTime in getTaskDeadlineText(...) is missing.");
            return "";
        }

        LocalDateTime currentTime = LocalDateTime.now(clock);
        if (endTime.isAfter(currentTime)) {
            return getDeadlineNotOverdueText(currentTime, endTime);
        } else {
            return getDeadlineOverdueText(currentTime, endTime);
        }
    }

    /**
     * Helper method of {@link #getTaskDeadlineText(LocalDateTime)} to get deadline text
     * when it is still not overdue (currentTime < endTime).
     * @param currentTime the time now
     * @param endTime the due date and time
     * @return a formatted deadline string
     */
    private String getDeadlineNotOverdueText(LocalDateTime currentTime, LocalDateTime endTime) {
        Duration durationCurrentToEnd = Duration.between(currentTime, endTime);
        long minutesToDeadline = durationCurrentToEnd.toMinutes();
        long secondsToDeadline = durationCurrentToEnd.getSeconds();

        StringJoiner stringJoiner = new StringJoiner(WORD_SPACE);

        if (secondsToDeadline <= 59) {
            return DUE_LESS_THAN_A_MINUTE;
        } else if (minutesToDeadline <= 59) {
            stringJoiner.add(WORD_IN).add(getMinutesText(currentTime, endTime));
        } else {
            stringJoiner.add(WORD_BY).add(getDateText(currentTime, endTime) + WORD_COMMA)
                    .add(getTimeText(endTime));
        }
        return stringJoiner.toString();
    }

    /**
     * Helper method of {@link #getTaskDeadlineText(LocalDateTime)} to get deadline text
     * when it is overdue (currentTime > endTime).
     * @param currentTime the time now
     * @param endTime the due date and time
     * @return a formatted deadline string
     */
    private String getDeadlineOverdueText(LocalDateTime currentTime, LocalDateTime endTime) {
        Duration durationCurrentToEnd = Duration.between(currentTime, endTime);
        long minutesToDeadline = durationCurrentToEnd.toMinutes();
        long secondsToDeadline = durationCurrentToEnd.getSeconds();

        StringJoiner stringJoiner = new StringJoiner(WORD_SPACE);

        if (secondsToDeadline >= -59) {
            return DUE_NOW;
        } else if (minutesToDeadline >= -59) {
            stringJoiner.add(getMinutesText(currentTime, endTime)).add(WORD_AGO);
        } else {
            stringJoiner.add(WORD_SINCE).add(getDateText(currentTime, endTime) + WORD_COMMA)
                    .add(getTimeText(endTime));
        }
        return stringJoiner.toString();
    }

    /**
     * Gets the event date and time text for the UI
     * @param startTime of the event
     * @param endTime of the event
     * @return a formatted event duration string
     */
    public String getEventTimeText(LocalDateTime startTime, LocalDateTime endTime) {
        if (startTime == null || endTime == null) {
            logger.log(Level.WARNING, "Either startTime or endTime is missing in getEventTimeText(...)");
            return "";
        } else if (startTime.isAfter(endTime)) {
            logger.log(Level.WARNING, "Start time is after end time in getEventTimeText(...)");
            return "";
        }

        LocalDateTime currentTime = LocalDateTime.now(clock);
        StringJoiner joiner = new StringJoiner(WORD_SPACE);
        if (isSameDay(startTime, endTime)) {
            joiner.add(getDateText(currentTime, startTime) + WORD_COMMA)
                    .add(WORD_FROM).add(getTimeText(startTime))
                    .add(WORD_TO).add(getTimeText(endTime));
        } else {
            joiner.add(WORD_FROM).add(getDateText(currentTime, startTime) + WORD_COMMA).add(getTimeText(startTime))
                    .add(WORD_TO).add(getDateText(currentTime, endTime) + WORD_COMMA).add(getTimeText(endTime));
        }
        return joiner.toString();
    }


    /**
     * Gives a formatted text of the dateTime based on the current system time, and then returns one of the following:
     *      "Yesterday", "Today", "Tonight", "Tomorrow",
     *      full date without year if this year,
     *      full date with year if other year.
     *
     * @param dateTime to format the date with
     * @return a formatted date text described above
     */
    private String getDateText(LocalDateTime currentTime, LocalDateTime dateTime) {
        if (isYesterday(currentTime, dateTime)) {
            return WORD_YESTERDAY;
        } else if (isTonight(currentTime, dateTime)) {
            return WORD_TONIGHT;
        } else if (isToday(currentTime, dateTime)) {
            return WORD_TODAY;
        } else if (isTomorrow(currentTime, dateTime)) {
            return WORD_TOMORROW;
        } else if (isSameYear(currentTime, dateTime)) {
            return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_DATE_NO_YEAR));
        } else {
            return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_DATE_WITH_YEAR));
        }
    }

    /**
     * Returns a formatted string of the time component of dateTime
     * @param dateTime to format the time with
     * @return a formatted time text (HH:MM A/PM)
     */
    private String getTimeText(LocalDateTime dateTime) {
        return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_TIME));
    }

    /**
     * Counts the number of minutes between the two dateTimes and prints out either:
     *      "1 minute" or "X minutes", for X != 1, X >= 0.
     * @param dateTime1 the first time instance
     * @param dateTime2 the other time instance
     * @return a formatted string to tell number of minutes left (as above)
     */
    private String getMinutesText(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        Duration duration = Duration.between(dateTime1, dateTime2);
        long minutesToDeadline = Math.abs(duration.toMinutes());

        if (minutesToDeadline == 1){
            return VALUE_ONE_MINUTE;
        } else {
            return minutesToDeadline + WORD_SPACE + UNIT_MINUTES;
        }
    }

    public boolean isTomorrow(LocalDateTime dateTimeToday, LocalDateTime dateTimeTomorrow) {
        LocalDate dayBefore = dateTimeToday.toLocalDate();
        LocalDate dayAfter = dateTimeTomorrow.toLocalDate();
        return dayBefore.plusDays(1).equals(dayAfter);
    }
    
    public boolean isToday(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        LocalDate date1 = dateTime1.toLocalDate();
        LocalDate date2 = dateTime2.toLocalDate();
        return date1.equals(date2);
    }

    private boolean isTonight(LocalDateTime dateTimeToday, LocalDateTime dateTimeTonight) {
        return isToday(dateTimeToday, dateTimeTonight)
                && dateTimeTonight.toLocalTime().isAfter(LocalTime.of(17, 59, 59));
    }
    
    private boolean isYesterday(LocalDateTime dateTimeToday, LocalDateTime dateTimeYesterday) {
        return isTomorrow(dateTimeYesterday, dateTimeToday);
    }

    private boolean isSameDay(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        return dateTime1.toLocalDate().equals(dateTime2.toLocalDate());
    }
    
    private boolean isSameYear(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        return dateTime1.getYear() == dateTime2.getYear();
    }
    
    public boolean isOverdue(LocalDateTime endTime) {
        if (endTime == null) {
            logger.log(Level.WARNING, "endTime in isOverdue(...) is null.");
            return false;
        }
        return endTime.isBefore(LocalDateTime.now(clock));
    }
    
```
###### \src\main\java\seedu\todo\logic\commands\TagCommand.java
``` java
/**
 * This class handles all tagging command
 */
public class TagCommand extends BaseCommand {
    /* Constants */
    private static final String ERROR_INCOMPLETE_PARAMETERS
            = "You have not supplied sufficient parameters to run a Tag command.";
    private static final String ERROR_INPUT_INDEX_REQUIRED
            = "A task index is required.";
    private static final String ERROR_INPUT_ADD_TAGS_REQUIRED
            = "A list of tags \"tag1, tag2, ...\" to add is required.";
    private static final String ERROR_INPUT_DELETE_TAGS_REQUIRED
            = "A list of tags \"tag1, tag2, ...\" to delete is required.";
    private static final String ERROR_TAGS_DUPLICATED
            = "You might have keyed in duplicated tag names.";
    private static final String ERROR_TAGS_ILLEGAL_CHAR
            = "Tags may only include alphanumeric characters, including dashes and underscores.";

    private static final String SUCCESS_ADD_TAGS = " - tagged successfully";
    private static final String SUCCESS_DELETE_TAGS = " - removed successfully";

    private static final String DESCRIPTION_ADD_TAGS = "Add tags to a task";
    private static final String DESCRIPTION_DELETE_TAGS = "Delete tags from tasks";
    private static final String ARGUMENTS_ADD_TAGS = "index /a tag1 [, tag2, ...]";
    private static final String ARGUMENTS_DELETE_TAGS = "[index] /d tag1 [, tag2, ...]";

    private static final Pattern TAG_VALIDATION_REGEX = Pattern.compile("^[\\w\\d_-]+$");

    /* Variables */
    private Argument<Integer> index = new IntArgument("index");

    private Argument<String> addTags = new StringArgument("/a")
            .flag("a");

    private Argument<String> deleteTags = new StringArgument("/d")
            .flag("d");

    @Override
    public Parameter[] getArguments() {
        return new Parameter[] {
            index, deleteTags, addTags
        };
    }

    @Override
    protected void setPositionalArgument(String argument) {
        String[] tokens = argument.trim().split(" ", 2);
        boolean isFirstArgNumber = StringUtil.isUnsignedInteger(tokens[0]);

        if (isFirstArgNumber) {
            try {
                index.setValue(tokens[0]);
            } catch (IllegalValueException e) {
                errors.put(index.getName(), e.getMessage());
            }
        }
    }

    @Override
    public String getCommandName() {
        return "tag";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(
            new CommandSummary(DESCRIPTION_ADD_TAGS, getCommandName(), ARGUMENTS_ADD_TAGS),
            new CommandSummary(DESCRIPTION_DELETE_TAGS, getCommandName(), ARGUMENTS_DELETE_TAGS)
        );
    }

    @Override
    protected void validateArguments() {
        //Check if we have enough input arguments
        if (!isInputParametersAvailable()) {
            handleUnavailableInputParameters();
        }

        //Check arguments for add tags case
        if (isAddTagsToTask()) {
            String[] tagsToAdd = StringUtil.splitString(addTags.getValue());
            checkForIllegalCharInTagNames(addTags.getName(), tagsToAdd);
            checkForDuplicatedTagNames(addTags.getName(), tagsToAdd);
        }

        //Check arguments for delete tags case
        if (isDeleteTagsFromTask()) {
            String[] tagsToDelete = StringUtil.splitString(deleteTags.getValue());
            checkForDuplicatedTagNames(deleteTags.getName(), tagsToDelete);
        }
        super.validateArguments();
    }

    @Override
    public CommandResult execute() throws ValidationException {
        //Obtain values for manipulation
        Integer displayedIndex = index.getValue();
        String[] tagsToAdd = StringUtil.splitString(addTags.getValue());
        String[] tagsToDelete = StringUtil.splitString(deleteTags.getValue());

        //Performs the actual execution with the data
        if (isAddTagsToTask()) {
            model.addTagsToTask(displayedIndex, tagsToAdd);
            return new CommandResult(StringUtil.convertListToString(tagsToAdd) + SUCCESS_ADD_TAGS);

        } else if (isDeleteTagsFromTask()) {
            model.deleteTagsFromTask(displayedIndex, tagsToDelete);
            return new CommandResult(StringUtil.convertListToString(tagsToDelete) + SUCCESS_DELETE_TAGS);

        } else {
            //Invalid case, should not happen, as we have checked it validateArguments.
            //However, for completeness, a command result is returned.
            throw new ValidationException(ERROR_INCOMPLETE_PARAMETERS);
        }
    }

    /* Input Parameters Validation */
    /**
     * Returns true if the command matches the action of adding tag(s) to a task.
     */
    private boolean isAddTagsToTask() {
        return index.hasBoundValue() && addTags.hasBoundValue();
    }

    /**
     * Returns true if the command matches the action of deleting tag(s) from a task.
     */
    private boolean isDeleteTagsFromTask() {
        return index.hasBoundValue() && deleteTags.hasBoundValue();
    }

    /**
     * Returns true if the command matches the action of deleting tag(s) from all tasks.
     */
    private boolean isDeleteTagsFromAllTasks() {
        return !index.hasBoundValue() && deleteTags.hasBoundValue();
    }

    /**
     * Returns true if the correct input parameters are available.
     * This method do not check validity of each input.
     */
    private boolean isInputParametersAvailable() {
        return BooleanUtils.xor(
                new boolean[] {isAddTagsToTask(), isDeleteTagsFromTask(), isDeleteTagsFromAllTasks()});
    }

    /**
     * Sets error messages for insufficient input parameters, dependent on input parameters supplied.
     */
    private void handleUnavailableInputParameters() {
        boolean hasIndex = index.hasBoundValue();
        boolean hasAddTags = addTags.hasBoundValue();
        boolean hasDeleteTags = deleteTags.hasBoundValue();

        //Validation for all inputs.
        if (!hasIndex && !hasAddTags && !hasDeleteTags) {
            errors.put(index.getName(), ERROR_INPUT_INDEX_REQUIRED);
            errors.put(addTags.getName(), ERROR_INPUT_ADD_TAGS_REQUIRED);
            errors.put(deleteTags.getName(), ERROR_INPUT_DELETE_TAGS_REQUIRED);

        } else if (!hasIndex && hasAddTags) {
            errors.put(index.getName(), ERROR_INPUT_INDEX_REQUIRED);

        } else if (hasIndex && !hasAddTags && !hasDeleteTags) {
            errors.put(addTags.getName(), ERROR_INPUT_ADD_TAGS_REQUIRED);
            errors.put(deleteTags.getName(), ERROR_INPUT_DELETE_TAGS_REQUIRED);
        }
    }

    /**
     * Checks if the given tag names have duplicated entries.
     */
    private void checkForDuplicatedTagNames(String argumentName, String[] tagNames) {
        if (!CollectionUtil.elementsAreUnique(Arrays.asList(tagNames))) {
            errors.put(argumentName, ERROR_TAGS_DUPLICATED);
        }
    }

    /**
     * Check if the given tag names are alphanumeric, which also can contain dashes and underscores.
     */
    private void checkForIllegalCharInTagNames(String argumentName, String[] tagNames) {
        for (String tagName : tagNames) {
            if (!isValidTagName(tagName)) {
                errors.put(argumentName, ERROR_TAGS_ILLEGAL_CHAR);
            }
        }
    }

    /* Helper Methods */
    /**
     * Returns true if a given string is a valid tag name (alphanumeric, can contain dashes and underscores)
     * Originated from {@link Tag}
     */
    private static boolean isValidTagName(String test) {
        return TAG_VALIDATION_REGEX.matcher(test).matches();
    }
}
```
###### \src\main\java\seedu\todo\model\Model.java
``` java
    /**
     * Adds the supplied list of tags (using tag names) to the specified task.
     *
     * @param index The task displayed index.
     * @param tagNames The list of tag names to be added.
     * @throws ValidationException when the given index is invalid, or the given {@code tagNames} contain
     *                             illegal characters.
     */
    void addTagsToTask(int index, String[] tagNames) throws ValidationException;

    /**
     * Deletes a list of tags (using tag names) from the specified task.
     *
     * @param index The task displayed index.
     * @param tagNames The list of tag names to be deleted.
     * @throws ValidationException when the given index is invalid, or when there is duplicates.
     */
    void deleteTagsFromTask(int index, String[] tagNames) throws ValidationException;
}
```
###### \src\main\java\seedu\todo\model\tag\Tag.java
``` java
/**
 * Represents a Tag in a task.
 *
 * Guarantees: immutable, only {@link UniqueTagCollection} can modify
 * the package private {@link Tag#rename(String)}.
 *
 * However, since alphanumeric name is not critical to {@link Tag},
 * the validation is done at {@link seedu.todo.model.TodoModel}
 */
public class Tag {
    /* Variables */
    //Stores a unique tag name, that is alphanumeric, and contains dashes and underscores.
    private String tagName;

    /**
     * Constructs a new tag with the given tag name.
     *
     * This class is intentional to be package private, so only {@link UniqueTagCollection}
     * can construct new tags.
     */
    public Tag(String name) {
        this.tagName = name;
    }

    /* Methods */
```
###### \src\main\java\seedu\todo\model\tag\UniqueTagCollection.java
``` java
/**
 * A list of tags that enforces no nulls and uniqueness between its elements.
 * Also supports minimal set of list operations for the app's features.
 *
 * Note: This class will disallow external access to {@link #uniqueTagsToTasksMap} so to
 * maintain uniqueness of the tag names.
 */
public class UniqueTagCollection implements Iterable<Tag>, UniqueTagCollectionModel {
    /*
        Stores a list of tags with unique tag names.
        TODO: ImmutableTask does not have consistent hashing.
        TODO: So, duplicated ImmutableTask may be found in the set of each Tag.
     */
    private final Map<Tag, Set<ImmutableTask>> uniqueTagsToTasksMap = new HashMap<>();

    /* Interfacing Methods */
    @Override
    public void update(ObservableList<ImmutableTask> globalTaskList) {
        uniqueTagsToTasksMap.clear();
        globalTaskList.forEach(task -> task.getTags().forEach(tag -> associateTaskToTag(task, tag)));
    }

    @Override
    public void notifyTaskDeleted(ImmutableTask task) {
        task.getTags().forEach(tag -> dissociateTaskFromTag(task, tag));
    }

    @Override
    public Tag registerTagWithTask(ImmutableTask task, String tagName) {
        Tag tag = getTagWithName(tagName);
        associateTaskToTag(task, tag);
        return tag;
    }

    @Override
    public Tag unregisterTagWithTask(ImmutableTask task, String tagName) {
        //TODO: Throw an error if the tag is not found.
        Tag tag = getTagWithName(tagName);
        dissociateTaskFromTag(task, tag);
        return tag;
    }

    @Override
    public void renameTag(String originalName, String newName) {
        Tag tag = getTagWithName(originalName);
        Set<ImmutableTask> setOfTasks = uniqueTagsToTasksMap.remove(tag);
        tag.rename(newName);
        uniqueTagsToTasksMap.put(tag, setOfTasks);
    }

    /* Helper Methods */
    /**
     * Links a {@code task} to the {@code tag} in the {@link #uniqueTagsToTasksMap}.
     */
    private void associateTaskToTag(ImmutableTask task, Tag tag) {
        Set<ImmutableTask> setOfTasks = uniqueTagsToTasksMap.get(tag);
        if (setOfTasks == null) {
            setOfTasks = new HashSet<>();
            uniqueTagsToTasksMap.put(tag, setOfTasks);
        }
        setOfTasks.add(task);
    }

    /**
     * Removes the association between the {@code task} from the {@code tag} in
     * the {@link #uniqueTagsToTasksMap}.
     */
    private void dissociateTaskFromTag(ImmutableTask task, Tag tag) {
        Set<ImmutableTask> setOfTasks = uniqueTagsToTasksMap.get(tag);
        if (setOfTasks != null) {
            setOfTasks.remove(task);
        }
    }

    /**
     * Obtains an instance of {@link Tag} with the supplied {@code tagName} from the
     * {@link #uniqueTagsToTasksMap}.
     *
     * Note: If such an instance is not found, a new {@link Tag} instance will be added to the
     *       {@link #uniqueTagsToTasksMap}.
     *
     * @param tagName The name of the {@link Tag}.
     * @return A {@link Tag} object that has the name {@code tagName}.
     */
    private Tag getTagWithName(String tagName) {
        Optional<Tag> possibleTag = uniqueTagsToTasksMap.keySet().stream()
                .filter(tag -> tag.getTagName().equals(tagName)).findAny();

        Tag targetTag;
        if (possibleTag.isPresent()) {
            targetTag = possibleTag.get();
        } else {
            targetTag = new Tag(tagName);
            uniqueTagsToTasksMap.put(targetTag, new HashSet<>());
        }
        return targetTag;
    }

    /**
     * Simply finds a tag with the {@code tagName}.
     */
    private Optional<Tag> findTagWithName(String tagName) {
        return uniqueTagsToTasksMap.keySet().stream()
                .filter(tag -> tag.getTagName().equals(tagName)).findAny();
    }

    /* Interfacing Getters */
    @Override
    public List<Tag> getUniqueTagList() {
        return new ArrayList<>(uniqueTagsToTasksMap.keySet());
    }

    @Override
    public List<ImmutableTask> getTasksLinkedToTag(String tagName) {
        Optional<Tag> possibleTag = findTagWithName(tagName);
        if (possibleTag.isPresent()) {
            Set<ImmutableTask> tasks = uniqueTagsToTasksMap.get(possibleTag.get());
            return new ArrayList<>(tasks);
        } else {
            return new ArrayList<>();
        }
    }

```
###### \src\main\java\seedu\todo\model\tag\UniqueTagCollectionModel.java
``` java
/**
 * An interface that spells out the available methods for maintaining a unique tag list.
 */
public interface UniqueTagCollectionModel {

    /* Model Interfacing Methods*/
    /**
     * Update the {@link UniqueTagCollectionModel} with the main to-do list {@code globalTaskList}
     * stored in {@link seedu.todo.model.TodoModel}, for a new set of {@link Tag}
     *
     * @param globalTaskList To extract the unique list of {@link Tag}s from.
     */
    void update(ObservableList<ImmutableTask> globalTaskList);

    /**
     * Notifies the {@link UniqueTagCollectionModel} that the given {@code task} is deleted,
     * so that the {@link UniqueTagCollectionModel} can update the relations accordingly.
     */
    void notifyTaskDeleted(ImmutableTask task);

    /* Tag Command Interfacing Methods */
    /**
     * Registers the given {@code task} to a {@link Tag} in the {@link UniqueTagCollectionModel}.
     *
     * @param task The task to be attached under the {@link Tag}.
     * @param tagName The name of the {@link Tag}.
     * @return Returns the corresponding {@link Tag} object with {@code tagName}
     *         so this tag can be added to the {@code task}.
     */
    Tag registerTagWithTask(ImmutableTask task, String tagName);

    /**
     * Unregistere the given {@code task} from the {@link Tag} in the {@link UniqueTagCollectionModel}.
     *
     * @param task The task to be detached from the {@link Tag}.
     * @param tagName The name of the {@link Tag}.
     * @return Returns the corresponding {@link Tag} object with {@code tagName}
     *         so this tag can be removed from the {@code task}.
     */
    Tag unregisterTagWithTask(ImmutableTask task, String tagName);

    /**
     * Renames a {@link Tag} with the given {@code originalName} with the {@code newName}
     */
    void renameTag(String originalName, String newName) throws ValidationException;

    /**
     * Gets a copy of the list of tags.
     */
    List<Tag> getUniqueTagList();

    /**
     * Gets a copy of list of task associated with the {@link Tag} with the name {@code tagName}
     */
    List<ImmutableTask> getTasksLinkedToTag(String tagName);
}
```
###### \src\main\java\seedu\todo\model\TodoModel.java
``` java
    @Override
    public void addTagsToTask(int index, String[] tagNames) throws ValidationException {
        saveUndoState();
        update(index, mutableTask -> {
            Set<Tag> tagsFromTask = new HashSet<>(mutableTask.getTags());
            for (String tagName : tagNames) {
                Tag newTag = uniqueTagCollection.registerTagWithTask(mutableTask, tagName);
                tagsFromTask.add(newTag);
            }
            mutableTask.setTags(tagsFromTask);
        });
    }

    @Override
    public void deleteTagsFromTask(int index, String[] tagNames) throws ValidationException {
        saveUndoState();
        update(index, mutableTask -> {
            Set<Tag> tagsFromTask = new HashSet<>(mutableTask.getTags());
            for (String tagName : tagNames) {
                Tag deletedTag = uniqueTagCollection.unregisterTagWithTask(mutableTask, tagName);
                tagsFromTask.remove(deletedTag);
            }
            mutableTask.setTags(tagsFromTask);
        });
    }
}
```
###### \src\main\java\seedu\todo\ui\controller\CommandController.java
``` java
/**
 * Processes the input command from {@link CommandInputView}, pass it to {@link seedu.todo.logic.Logic}
 * and hands the {@link seedu.todo.logic.commands.CommandResult} to {@link CommandFeedbackView} and
 * {@link CommandErrorView}
 */
public class CommandController {
    /* Variables */
    private Logic logic;
    private CommandInputView inputView;
    private CommandPreviewView previewView;
    private CommandFeedbackView feedbackView;
    private CommandErrorView errorView;

    /* Private Constructor */
    private CommandController() {}

    /**
     * Constructs a link between the classes defined in the parameters.
     */
    public static CommandController constructLink(Logic logic, CommandInputView inputView,
            CommandPreviewView previewView, CommandFeedbackView feedbackView, CommandErrorView errorView) {

        CommandController controller = new CommandController();
        controller.logic = logic;
        controller.inputView = inputView;
        controller.previewView = previewView;
        controller.feedbackView = feedbackView;
        controller.errorView = errorView;
        controller.start();
        return controller;
    }

    /**
     * Asks {@link #inputView} to start listening for a new key strokes.
     * Once the callback returns a command, {@link #handleInput(KeyCode, String)} will process the input.
     */
    private void start() {
        inputView.listenToInput(this::handleInput);
    }

```
###### \src\main\java\seedu\todo\ui\controller\CommandController.java
``` java
    /**
     * Displays error in the respective UI elements
     * @param errorBag group of errors to display
     */
    private void viewDisplayError(ErrorBag errorBag) {
        inputView.flagError();
        feedbackView.flagError();
        errorView.displayErrors(errorBag);
    }

    /**
     * Displays success behaviour in the respective UI elements
     */
    private void viewDisplaySuccess() {
        inputView.resetViewState();
        feedbackView.unFlagError();
        errorView.hideCommandErrorView();
    }

    /**
     * Displays a message with regards to the user's input
     * @param message to be displayed to user
     */
    private void displayMessage(String message) {
        feedbackView.displayMessage(message);
    }
}
```
###### \src\main\java\seedu\todo\ui\UiManager.java
``` java
    @Subscribe
    private void handleExpandCollapseTaskEvent(ExpandCollapseTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTodoListView().toggleExpandCollapsed(event.task);
    }

```
###### \src\main\java\seedu\todo\ui\UiManager.java
``` java
    @Subscribe
    private void handleShowPreviewEvent(ShowPreviewEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getHelpView().hideHelpPanel();
        mainWindow.getCommandPreviewView().displayCommandSummaries(event.getPreviewInfo());
    }

    @Subscribe
    private void handleCommandInputEnterEvent(CommandInputEnterEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getHelpView().hideHelpPanel();
        mainWindow.getCommandFeedbackView().clearMessage();
    }

    @Subscribe
    private void handleHighlightTaskEvent(HighlightTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTodoListView().scrollAndSelect(event.getTask());
    }

```
###### \src\main\java\seedu\todo\ui\util\FxViewUtil.java
``` java
/**
 * Contains generic utility methods for JavaFX views
 */
public class FxViewUtil {

```
###### \src\main\java\seedu\todo\ui\util\FxViewUtil.java
``` java
    /**
     * Hides a specified UI element, and ensures that it does not occupy any space.
     */
    public static void setCollapsed(Node node, boolean isCollapsed) {
        node.setVisible(!isCollapsed);
        node.setManaged(!isCollapsed);
    }
    
    /**
     * Set the text to UI element when available, collapse the UI element when not.
     */
    public static void displayTextWhenAvailable(Label labelToDisplay, Node nodeToHide,
                                                Optional<String> optionalString) {
        if (optionalString.isPresent()) {
            labelToDisplay.setText(optionalString.get());
        } else {
            labelToDisplay.setText("");
            setCollapsed(nodeToHide, true);
        }
    }

    /**
     * Sets a recurring task on the UI specified in handler to repeat every specified seconds.
     * Does not start until the user executes .play()
     * @param seconds duration between each repeats
     * @param handler method to run is specified here
     * @return {@link Timeline} object to run.
     */
    public static Timeline setRecurringUiTask(int seconds, EventHandler<ActionEvent> handler) {
        Timeline recurringTask = new Timeline(new KeyFrame(Duration.seconds(seconds), handler));
        recurringTask.setCycleCount(Timeline.INDEFINITE);
        return recurringTask;
    }

    /**
     * Converts an index from a list to the index that is displayed to the user via the Ui
     */
    public static int convertToListIndex(int uiIndex) {
        return uiIndex - 1;
    }

    /**
     * Converts an index displayed on the Ui to the user, to the index used on the list
     */
    public static int convertToUiIndex(int listIndex) {
        return listIndex + 1;
    }
}
```
###### \src\main\java\seedu\todo\ui\util\UiPartLoaderUtil.java
``` java
    /**
     * Attaches only one children view element to a specified placeholder.
     * However, if either one of the params is null, it will result in no-op.
     * Also, if there are any other children in the placeholder, they will be cleared first.
     *
     * @param placeholder to add the childrenView to, no-op if null
     * @param childrenView to be attached to the placeholder, no-op if null
     */
    private static void attachToPlaceholder(AnchorPane placeholder, Node childrenView) {
        if (placeholder != null && childrenView != null) {
            ObservableList<Node> placeholderChildren = placeholder.getChildren();
            placeholderChildren.clear();
            placeholderChildren.add(childrenView);
        }
    }
}
```
###### \src\main\java\seedu\todo\ui\util\ViewGeneratorUtil.java
``` java
/**
 * A utility class that generates commonly used UI elements, such as Labels.
 */
public class ViewGeneratorUtil {

    /**
     * Generates a {@link Text} object with the class style applied onto the object.
     * @param string to be wrapped in the {@link Text} object
     * @param classStyle css style to be applied to the label
     * @return a {@link Text} object
     */
    public static Text constructText(String string, String classStyle) {
        Text text = new Text(string);
        ViewStyleUtil.addClassStyles(text, classStyle);
        return text;
    }

    /**
     * Constructs a label view with a dark grey rounded background.
     */
    public static Label constructRoundedText(String string) {
        Label label = constructLabel(string, "roundLabel");
        label.setPadding(new Insets(0, 8, 0, 8));
        return label;
    }

    /**
     * Generates a {@link Label} object with the class style applied onto the object.
     * @param string to be wrapped in the {@link Label} object
     * @param classStyle css style to be applied to the label
     * @return a {@link Label} object
     */
    public static Label constructLabel(String string, String classStyle) {
        Label label = new Label(string);
        ViewStyleUtil.addClassStyles(label, classStyle);
        return label;
    }

    /**
     * Place all the specified texts into a {@link TextFlow} object.
     */
    public static TextFlow placeIntoTextFlow(Text... texts) {
        return new TextFlow(texts);
    }
}
```
###### \src\main\java\seedu\todo\ui\util\ViewStyleUtil.java
``` java
/**
 * Deals with the CSS styling of View elements
 */
public class ViewStyleUtil {

    /* Style Classes Constants */
    public static final String STYLE_COLLAPSED = "collapsed";
    public static final String STYLE_COMPLETED = "completed";
    public static final String STYLE_OVERDUE = "overdue";
    public static final String STYLE_SELECTED = "selected";
    public static final String STYLE_TEXT_4 = "text4";
    public static final String STYLE_ERROR = "error";
    public static final String STYLE_CODE = "code";
    public static final String STYLE_BOLDER = "bolder";
    public static final String STYLE_UNDERLINE = "underline";
    public static final String STYLE_ONGOING = "ongoing";

    /*Static Helper Methods*/
    /**
     * Adds only one instance of all the class styles to the node object
     * @param node view object to add the class styles to
     * @param classStyles all the class styles that is to be added to the node
     */
    public static void addClassStyles(Node node, String... classStyles) {
        for (String classStyle : classStyles) {
            addClassStyle(node, classStyle);
        }
    }

    /**
     * Remove all instance of all the class styles to the node object
     * @param node view object to add the class styles to
     * @param classStyles all the class styles that is to be removed from the node
     */
    public static void removeClassStyles(Node node, String... classStyles) {
        for (String classStyle : classStyles) {
            removeClassStyle(node, classStyle);
        }
    }

    /**
     * Adds or removes class style based on a boolean parameter
     * @param isAdding true to add, false to remove
     * @param node view object to add the class styles to
     * @param classStyles all the class styles that is to be added to/removed from the node
     */
    public static void addRemoveClassStyles(boolean isAdding, Node node, String... classStyles) {
        for (String classStyle : classStyles) {
            if (isAdding) {
                addClassStyles(node, classStyle);
            } else {
                removeClassStyles(node, classStyle);
            }
        }
    }

    /**
     * Toggles one style class to the node:
     * If supplied style class is available, remove it. Else, add one instance of it.
     *
     * @return true if toggled from OFF -> ON
     */
    public static boolean toggleClassStyle(Node node, String classStyle) {
        boolean wasPreviouslyOff = !node.getStyleClass().contains(classStyle);
        if (wasPreviouslyOff) {
            addClassStyles(node, classStyle);
        } else {
            removeClassStyles(node, classStyle);
        }
        return wasPreviouslyOff;
    }

    /* Private Helper Methods */
    /**
     * Adds only one instance of a single class style to the node object
     */
    private static void addClassStyle(Node node, String classStyle) {
        if (!node.getStyleClass().contains(classStyle)) {
            node.getStyleClass().add(classStyle);
        }
    }

    /**
     * Removes all instances of a single class style from the node object
     */
    private static void removeClassStyle(Node node, String classStyle) {
        while (node.getStyleClass().contains(classStyle)) {
            node.getStyleClass().remove(classStyle);
        }
    }
}
```
###### \src\main\java\seedu\todo\ui\view\CommandErrorView.java
``` java
/**
 * A view class that displays specific command errors in greater detail.
 */
public class CommandErrorView extends UiPart {
    /* Constants */
    private static final String FXML = "CommandErrorView.fxml";

    /* Variables */
    private final Logger logger = LogsCenter.getLogger(CommandFeedbackView.class);

    /* Layouts */
    private AnchorPane placeholder;
    private VBox errorViewBox;
    @FXML private VBox nonFieldErrorBox;
    @FXML private VBox fieldErrorBox;
    @FXML private GridPane nonFieldErrorGrid;
    @FXML private GridPane fieldErrorGrid;

```
###### \src\main\java\seedu\todo\ui\view\CommandErrorView.java
``` java
    /**
     * Configure the UI layout of {@link CommandErrorView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(errorViewBox, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(nonFieldErrorBox, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(fieldErrorBox, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(fieldErrorGrid, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(nonFieldErrorGrid, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Displays both field and non-field errors to the user
     * @param errorBag that contains both field and non-field errors
     */
    public void displayErrors(ErrorBag errorBag) {
        showCommandErrorView();
        clearOldErrorsFromViews();
        displayFieldErrors(errorBag.getFieldErrors());
        displayNonFieldErrors(errorBag.getNonFieldErrors());
    }

    /**
     * Feeds non field errors to the {@link #nonFieldErrorGrid}.
     * If there are no non-field errors, then {@link #nonFieldErrorBox} will be hidden.
     * @param nonFieldErrors that stores a list of non-field errors
     */
    private void displayNonFieldErrors(List<String> nonFieldErrors) {
        if (nonFieldErrors.isEmpty()) {
            hideErrorBox(nonFieldErrorBox);
        } else {
            int rowCounter = 0;
            for (String error : nonFieldErrors) {
                addRowToGrid(nonFieldErrorGrid, rowCounter++, rowCounter + ".", error);
            }
        }
    }

    /**
     * Feeds field errors to the {@link #fieldErrorGrid}.
     * If there are no field errors, then {@link #fieldErrorBox} will be hidden.
     * @param fieldErrors that stores the field errors
     */
    private void displayFieldErrors(Map<String, String> fieldErrors) {
        if (fieldErrors.isEmpty()) {
            hideErrorBox(fieldErrorBox);
        } else {
            int rowCounter = 0;
            for (Map.Entry<String, String> fieldError : fieldErrors.entrySet()) {
                addRowToGrid(fieldErrorGrid, rowCounter++, fieldError.getKey(), fieldError.getValue());
            }
        }
    }

    /* Override Methods */
    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeholder = placeholder;
    }

    @Override
    public void setNode(Node node) {
        this.errorViewBox = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    /*Helper Methods*/
    /**
     * Adds a row of text to the targetGrid
     * @param targetGrid to add a row of text on
     * @param rowIndex which row to add this row of text
     * @param leftText text for the first column
     * @param rightText text for the second column
     */
    private void addRowToGrid(GridPane targetGrid, int rowIndex, String leftText, String rightText) {
        Label leftLabel = ViewGeneratorUtil.constructLabel(leftText, ViewStyleUtil.STYLE_TEXT_4);
        Label rightLabel = ViewGeneratorUtil.constructLabel(rightText, ViewStyleUtil.STYLE_TEXT_4);
        targetGrid.addRow(rowIndex, leftLabel, rightLabel);
    }

    /**
     * Clears all elements in the given grid.
     */
    private void clearGrid(GridPane gridPane) {
        gridPane.getChildren().clear();
    }

    /**
     * Hides a field or non-field error box.
     * @param vBox can be either {@link #fieldErrorBox} or {@link #nonFieldErrorBox}
     */
    private void hideErrorBox(VBox vBox) {
        FxViewUtil.setCollapsed(vBox, true);
    }

    /**
     * Shows a field or non-field error box.
     * @param vBox can be either {@link #fieldErrorBox} or {@link #nonFieldErrorBox}
     */
    private void showErrorBox(VBox vBox) {
        FxViewUtil.setCollapsed(vBox, false);
    }

    /**
     * Hides the entire {@link CommandErrorView}
     */
    public void hideCommandErrorView() {
        FxViewUtil.setCollapsed(placeholder, true);
    }

    /**
     * Displays the entire {@link CommandErrorView}
     */
    private void showCommandErrorView() {
        FxViewUtil.setCollapsed(placeholder, false);
    }

    /**
     * Clears previous errors from the grid, and then unhide all the error boxes.
     */
    private void clearOldErrorsFromViews() {
        clearGrid(nonFieldErrorGrid);
        clearGrid(fieldErrorGrid);
        showErrorBox(nonFieldErrorBox);
        showErrorBox(fieldErrorBox);
    }
}
```
###### \src\main\java\seedu\todo\ui\view\CommandFeedbackView.java
``` java
/**
 * Display textual feedback to command input via this view with {@link #displayMessage(String)}.
 */
public class CommandFeedbackView extends UiPart {
    /* Constants */
    private static final String FXML = "CommandFeedbackView.fxml";

    /* Variables */
    private final Logger logger = LogsCenter.getLogger(CommandFeedbackView.class);

    /* Layout Elements */
    @FXML private Label commandFeedbackLabel;
    private AnchorPane textContainer;

```
###### \src\main\java\seedu\todo\ui\view\CommandFeedbackView.java
``` java
    /* Interfacing Methods */
    /**
     * Displays a message onto the {@link #commandFeedbackLabel}.
     * @param message The feedback message to be shown to the user.
     */
    public void displayMessage(String message) {
        commandFeedbackLabel.setText(message);
    }

    /**
     * Clears any message in {@link #commandFeedbackLabel}.
     */
    public void clearMessage() {
        commandFeedbackLabel.setText("");
    }

    /**
     * Indicate an error visually on the {@link #commandFeedbackLabel}.
     */
    public void flagError() {
        ViewStyleUtil.addClassStyles(commandFeedbackLabel, ViewStyleUtil.STYLE_ERROR);
    }

    /**
     * Remove the error flag visually on the {@link #commandFeedbackLabel}.
     */
    public void unFlagError() {
        ViewStyleUtil.removeClassStyles(commandFeedbackLabel, ViewStyleUtil.STYLE_ERROR);
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        this.textContainer = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \src\main\java\seedu\todo\ui\view\CommandInputView.java
``` java
/**
 * A view class that handles the Input text box directly.
 */
public class CommandInputView extends UiPart {
    /* Constants */
    private static final String FXML = "CommandInputView.fxml";

    /* Variables */
    private final Logger logger = LogsCenter.getLogger(CommandInputView.class);

    /* Layout Elements */
    private AnchorPane commandInputPane;
    @FXML private TextArea commandTextField;

```
###### \src\main\java\seedu\todo\ui\view\CommandInputView.java
``` java
    /**
     * Configure the UI properties of {@link CommandInputView}
     */
    private void configureProperties() {
        setCommandInputHeightAutoResizeable();
        unflagErrorWhileTyping();
        listenAndRaiseEnterEvent();
    }

```
###### \src\main\java\seedu\todo\ui\view\CommandInputView.java
``` java
    /**
     * Listens for Enter keystrokes, and raises an event when it happens.
     */
    public void listenAndRaiseEnterEvent() {
        this.commandTextField.addEventHandler(KeyEvent.KEY_PRESSED, event -> {
            if (event.getCode() == KeyCode.ENTER) {
                EventsCenter.getInstance().post(new CommandInputEnterEvent());
                event.consume(); //To prevent commandTextField from printing a new line.
            }
        });
    }

    /* UI Methods */
    /**
     * Resets the text box by {@link #unflagError()} after a key is pressed
     */
    private void unflagErrorWhileTyping() {
        this.commandTextField.addEventFilter(KeyEvent.KEY_PRESSED, event -> unflagError());
    }

    /**
     * Allow {@link #commandTextField} to adjust automatically with the height of the content of the
     * text area itself.
     */
    private void setCommandInputHeightAutoResizeable() {
        new TextAreaResizer(commandTextField);
    }

    /**
     * Resets the state of the text box, by clearing the text box and clear the errors.
     */
    public void resetViewState() {
        unflagError();
        clear();
    }

    /**
     * Indicate an error visually on the {@link #commandTextField}
     */
    public void flagError() {
        ViewStyleUtil.addClassStyles(commandTextField, ViewStyleUtil.STYLE_ERROR);
    }

    /**
     * Remove the error flag visually on the {@link #commandTextField}
     */
    private void unflagError() {
        ViewStyleUtil.removeClassStyles(commandTextField, ViewStyleUtil.STYLE_ERROR);
    }

    /**
     * Clears the texts inside the text box
     */
    private void clear() {
        commandTextField.clear();
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        commandInputPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

```
###### \src\main\java\seedu\todo\ui\view\FilterBarView.java
``` java
/**
 * Shows a row of filter categories via {@link TaskViewFilter}
 * to filter the tasks in {@link TodoListView}
 */
public class FilterBarView extends UiPart {
    /* Constants */
    private final Logger logger = LogsCenter.getLogger(FilterBarView.class);
    private static final String FXML = "FilterBarView.fxml";

    /* Layout Views */
    private FlowPane filterViewPane;

    /* Variables */
    private Map<TaskViewFilter, HBox> taskFilterBoxesMap = new HashMap<>();

    /* Layout Initialisation */
    /**
     * Loads and initialise the {@link #filterViewPane} to the {@link seedu.todo.ui.MainWindow}
     * @param primaryStage of the application
     * @param placeholder where the view element {@link #filterViewPane} should be placed
     * @return an instance of this class
     */
    public static FilterBarView load(Stage primaryStage, AnchorPane placeholder,
                                     ObservableValue<TaskViewFilter> filter) {

        FilterBarView filterView = UiPartLoaderUtil
                .loadUiPart(primaryStage, placeholder, new FilterBarView());
        filterView.configureLayout();
        filterView.configureProperties();
        filterView.bindListener(filter);
        return filterView;
    }

    /**
     * Configure the UI layout of {@link FilterBarView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(filterViewPane, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Initialise and configure the UI properties of {@link FilterBarView}
     */
    private void configureProperties() {
        initialiseAllViewFilters();
        selectOneViewFilter(TaskViewFilter.DEFAULT);
    }

    /**
     * Display all the {@link TaskViewFilter} on the {@link #filterViewPane}
     */
    private void initialiseAllViewFilters() {
        for (TaskViewFilter filter : TaskViewFilter.all()) {
            appendEachViewFilter(filter);
        }
    }

    /**
     * Add one {@link TaskViewFilter} on the {@link #filterViewPane}
     * and save an instance to the {@link #taskFilterBoxesMap}
     * @param filter to add onto the pane
     */
    private void appendEachViewFilter(TaskViewFilter filter) {
        HBox textContainer = constructViewFilterBox(filter);
        taskFilterBoxesMap.put(filter, textContainer);
        filterViewPane.getChildren().add(textContainer);
    }

    /**
     * Given a filter, construct a view element to be displayed on the {@link #filterViewPane}
     * @param filter to be displayed
     * @return a view element
     */
    private HBox constructViewFilterBox(TaskViewFilter filter) {
        String filterName = WordUtils.capitalize(filter.name);
        String[] partitionedText = StringUtil.partitionStringAtPosition(filterName, filter.shortcutCharPosition);

        Label leftLabel = new Label(partitionedText[0]);
        Label centreLabel = new Label(partitionedText[1]);
        Label rightLabel = new Label(partitionedText[2]);
        ViewStyleUtil.addClassStyles(centreLabel, ViewStyleUtil.STYLE_UNDERLINE);

        return new HBox(leftLabel, centreLabel, rightLabel);
    }

    /**
     * Binds this component with the {@link TaskViewFilter} property it listens to
     */
    private void bindListener(ObservableValue<TaskViewFilter> filter) {
        filter.addListener((observable, oldValue, newValue) -> selectOneViewFilter(newValue));
    }
    
    /**
     * Select exactly one filter from {@link #filterViewPane}
     */
    public void selectOneViewFilter(TaskViewFilter filter) {
        clearAllViewFiltersSelection();
        selectViewFilter(filter);
    }

    /* Helper Methods */
    /**
     * Clears all selection from the {@link #filterViewPane}
     */
    private void clearAllViewFiltersSelection() {
        for (HBox filterBox : taskFilterBoxesMap.values()) {
            ViewStyleUtil.removeClassStyles(filterBox, ViewStyleUtil.STYLE_SELECTED);
        }
    }

    /**
     * Mark the filter as selected on {@link #filterViewPane}
     * However, if filter is null, nothing is done.
     */
    private void selectViewFilter(TaskViewFilter filter) {
        if (filter != null) {
            HBox filterBox = taskFilterBoxesMap.get(filter);
            ViewStyleUtil.addClassStyles(filterBox, ViewStyleUtil.STYLE_SELECTED);
        }
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        this.filterViewPane = (FlowPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \src\main\java\seedu\todo\ui\view\HelpView.java
``` java
/**
 * A view that displays all the help commands in a single view.
 */
public class HelpView extends UiPart {

    /* Constants */
    private static final String FXML = "HelpView.fxml";

    /* Variables */
    private final Logger logger = LogsCenter.getLogger(HelpView.class);

    /*Layouts*/
    private VBox helpPanelView;

    @FXML private GridPane helpGrid;

    /**
     * Loads and initialise the feedback view element to the placeHolder
     * @param primaryStage of the application
     * @param placeholder where the view element {@link #helpPanelView} should be placed
     * @return an instance of this class
     */
    public static HelpView load(Stage primaryStage, AnchorPane placeholder) {
        HelpView helpView = UiPartLoaderUtil.loadUiPart(primaryStage, placeholder, new HelpView());
        helpView.configureLayout();
        helpView.hideHelpPanel();
        return helpView;
    }

    /**
     * Configure the UI layout of {@link CommandErrorView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(helpPanelView, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(helpGrid, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Displays a list of commands into the helpPanelView
     */
    public void displayCommandSummaries(List<CommandSummary> commandSummaries) {
        this.showHelpPanel();
        helpGrid.getChildren().clear();
        int rowIndex = 0;
        for (CommandSummary commandSummary : commandSummaries) {
            appendCommandSummary(rowIndex++, commandSummary);
        }
    }

    /**
     * Add a command summary to each row of the helpGrid
     * @param rowIndex the row number to which the command summary should append to
     * @param commandSummary to be displayed
     */
    private void appendCommandSummary(int rowIndex, CommandSummary commandSummary) {
        Text commandScenario = ViewGeneratorUtil
                .constructText(commandSummary.scenario, ViewStyleUtil.STYLE_TEXT_4);
        Text commandName = ViewGeneratorUtil
                .constructText(commandSummary.command, ViewStyleUtil.STYLE_TEXT_4);
        Text commandArgument = ViewGeneratorUtil
                .constructText(" " + commandSummary.arguments, ViewStyleUtil.STYLE_TEXT_4);

        ViewStyleUtil.addClassStyles(commandArgument, ViewStyleUtil.STYLE_CODE);
        ViewStyleUtil.addClassStyles(commandName, ViewStyleUtil.STYLE_CODE, ViewStyleUtil.STYLE_BOLDER);

        TextFlow combinedCommand = ViewGeneratorUtil.placeIntoTextFlow(commandName, commandArgument);
        helpGrid.addRow(rowIndex, commandScenario, combinedCommand);
    }

    /* Ui Methods */
    public void hideHelpPanel() {
        FxViewUtil.setCollapsed(helpPanelView, true);
    }

    private void showHelpPanel() {
        FxViewUtil.setCollapsed(helpPanelView, false);
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        this.helpPanelView = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \src\main\java\seedu\todo\ui\view\TaskCardView.java
``` java
/**
 * This class links up with TaskCardView.fxml layout to display details of a given
 * ReadOnlyTask to users via the TaskListPanel.fxml.
 */
public class TaskCardView extends UiPart {
    /*Constants*/
    private static final String FXML = "TaskCardView.fxml";

    private static final String TASK_TYPE = "Task";
    private static final String EVENT_TYPE = "Event";

    /*Static Field*/
    /*
        Provides a global reference between an ImmutableTask to the wrapper TaskCardView class,
        since we have no direct access of TaskCardView from the ListView object.
     */
    private static final Map<ImmutableTask, TaskCardView> taskCardMap = new HashMap<>();

```
###### \src\main\java\seedu\todo\ui\view\TaskCardView.java
``` java
    /**
     * Displays all other view elements, including title, type label, pin image, description and location texts.
     */
    private void displayEverythingElse() {
        titleLabel.setText(String.valueOf(displayedIndex) + ". " + task.getTitle());
        pinImage.setVisible(task.isPinned());
        typeLabel.setText(task.isEvent() ? EVENT_TYPE : TASK_TYPE);
        FxViewUtil.displayTextWhenAvailable(descriptionLabel, descriptionBox, task.getDescription());
        FxViewUtil.displayTextWhenAvailable(locationLabel, locationBox, task.getLocation());
    }
    
    /**
     * Displays the tags in lexicographical order, ignoring case.
     */
    private void displayTags(){
        List<Tag> tagList = new ArrayList<>(task.getTags());
        if (tagList.isEmpty()) {
            FxViewUtil.setCollapsed(tagsBox, true);
        } else {
            tagList.sort((o1, o2) -> o1.toString().compareToIgnoreCase(o2.toString()));
            for (Tag tag : tagList) {
                Label tagLabel = ViewGeneratorUtil.constructRoundedText(tag.getTagName());
                tagsBox.getChildren().add(tagLabel);
            }
        }
    }
    
    /**
     * Sets style according to the status (e.g. completed, overdue, etc) of the task.
     */
    private void setStyle() {
        boolean isCompleted = task.isCompleted();
        boolean isOverdue = task.getEndTime().isPresent()
                && timeUtil.isOverdue(task.getEndTime().get()) && !task.isEvent();
        boolean isOngoing = task.isEvent()
                && timeUtil.isOngoing(task.getStartTime().get(), task.getEndTime().get());
        
        if (isCompleted) {
            ViewStyleUtil.addClassStyles(taskCard, ViewStyleUtil.STYLE_COMPLETED);
        } else if (isOverdue) {
            ViewStyleUtil.addClassStyles(taskCard, ViewStyleUtil.STYLE_OVERDUE);
        } else if (isOngoing){
            ViewStyleUtil.addClassStyles(taskCard, ViewStyleUtil.STYLE_ONGOING);
        }
    }

    /**
     * Initialise the view to show collapsed state if it can be collapsed,
     * else hide the {@link #moreInfoLabel} otherwise.
     */
    private void initialiseCollapsibleView() {
        ViewStyleUtil.addRemoveClassStyles(true, taskCard, ViewStyleUtil.STYLE_COLLAPSED);
        FxViewUtil.setCollapsed(moreInfoLabel, !isTaskCollapsible());
        FxViewUtil.setCollapsed(tagsBox, isTaskCollapsible());
    }
    
    /**
     * Displays formatted task or event timings in the time field.
     */
    private void displayTimings() {
        String displayTimingOutput;
        Optional<LocalDateTime> startTime = task.getStartTime();
        Optional<LocalDateTime> endTime = task.getEndTime();
        boolean isEventWithTime = task.isEvent() && startTime.isPresent() && endTime.isPresent();
        boolean isTaskWithTime = !task.isEvent() && endTime.isPresent();
        
        if (isEventWithTime) {
            displayTimingOutput = timeUtil.getEventTimeText(startTime.get(), endTime.get());
        } else if (isTaskWithTime) {
            displayTimingOutput = timeUtil.getTaskDeadlineText(endTime.get());
        } else {
            FxViewUtil.setCollapsed(dateBox, true);
            return;
        }
        dateLabel.setText(displayTimingOutput);
    }

    /**
     * Allows timing, and deadline highlight style to be updated automatically.
     */
    private void setTimingAutoUpdate() {
        Timeline timeline = FxViewUtil.setRecurringUiTask(30, event -> {
            displayTimings();
            setStyle();
        });
        timeline.play();
    }

    /* Methods interfacing with UiManager*/
    /**
     * Toggles the task card's collapsed or expanded state, only if this card is collapsible.
     */
    public void toggleCardCollapsing() {
        if (isTaskCollapsible()) {
            //Sets both the collapsed style of the card, and mark the visibility of the "more" label.
            boolean isCollapsing = ViewStyleUtil.toggleClassStyle(taskCard, ViewStyleUtil.STYLE_COLLAPSED);
            FxViewUtil.setCollapsed(moreInfoLabel, !isCollapsing);
            FxViewUtil.setCollapsed(tagsBox, isCollapsing);
        }
    }

    /**
     * Displays in the Ui whether this card is selected
     * @param isSelected true when the card is selected
     */
    public void markAsSelected(boolean isSelected) {
        ViewStyleUtil.addRemoveClassStyles(isSelected, taskCard, ViewStyleUtil.STYLE_SELECTED);
    }

    /* Helper Methods */
    /**
     * Returns true if this task card can be collapsed, based on the information given from the
     * {@link ImmutableTask}
     */
    private boolean isTaskCollapsible() {
        boolean hasDescription = task.getDescription().isPresent();
        boolean hasTags = !task.getTags().isEmpty();
        return hasDescription || hasTags;
    }

    /* Getters */
    /**
     * Gets the mapped {@link TaskCardView} object from an {@link ImmutableTask} object
     * @param task that is being wrapped by the {@link TaskCardView} object
     * @return a {@link TaskCardView} object that contains this task (can be null if not available)
     */
    public static TaskCardView getTaskCard(ImmutableTask task) {
        return taskCardMap.get(task);
    }

    public int getDisplayedIndex() {
        return displayedIndex;
    }

    public VBox getLayout() {
        return taskCard;
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        taskCard = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \src\main\java\seedu\todo\ui\view\TodoListView.java
``` java
/**
 * A panel that holds all the tasks inflated from TaskCardView.
 */
public class TodoListView extends UiPart {
    /*Constants*/
    private static final String FXML = "TodoListView.fxml";
    
    /*Variables*/
    private final Logger logger = LogsCenter.getLogger(TodoListView.class);
    private VBox panel;
    
    /*Layout Declarations*/
    @FXML
    private ListView<ImmutableTask> todoListView;

```
###### \src\main\java\seedu\todo\ui\view\TodoListView.java
``` java
    /* Ui Methods */
    /**
     * Toggles the expanded/collapsed view of a task card.
     *
     * @param task The specific to be expanded or collapsed from view.
     */
    public void toggleExpandCollapsed(ImmutableTask task) {
        TaskCardView taskCardView = TaskCardView.getTaskCard(task);
        if (taskCardView != null) {
            taskCardView.toggleCardCollapsing();
        }
    }

    /**
     * Scrolls the {@link #todoListView} to the particular task card at the listIndex.
     */
    public void scrollAndSelect(int listIndex) {
        Platform.runLater(() -> {
            todoListView.scrollTo(listIndex);
            todoListView.getSelectionModel().clearAndSelect(listIndex);
        });
    }

    /**
     * Scrolls the {@link #todoListView} to the particular task card.
     *
     * @param task for the list to scroll to.
     */
    public void scrollAndSelect(ImmutableTask task) {
        TaskCardView taskCardView = TaskCardView.getTaskCard(task);
        int listIndex = FxViewUtil.convertToListIndex(taskCardView.getDisplayedIndex());
        scrollAndSelect(listIndex);
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

```
###### \src\main\java\seedu\todo\ui\view\TodoListView.java
``` java
        /**
         * Sets the style properties of a cell on the to-do list, that cannot be done in any other places.
         */
        private void setTaskCardStyleProperties(TaskCardView taskCardView) {
            this.setPadding(Insets.EMPTY);
            this.selectedProperty().addListener((observable, oldValue, newValue)
                    -> taskCardView.markAsSelected(newValue));
        }
    }
}
```
###### \src\main\resources\style\DefaultStyle.css
``` css
.main {
    -fx-background-color: #2D2D2D;
    -fx-border-color: #00A4FF;
    -fx-border-width: 1px;
    -fx-padding: 12;
    -fx-spacing: 4;
}

.text1 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI Black";
    -fx-font-size: 17pt;
}

.text2 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI Semibold";
    -fx-font-size: 15pt;
}

.text3 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI Semibold";
    -fx-font-size: 13pt;
}

.text4 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI";
    -fx-font-size: 12pt;
}

.code {
    -fx-font-family: "Consolas";
}

.bolder {
    -fx-font-weight: bolder;
}

.underline {
    -fx-underline: true;
}

.gridPanel {
    -fx-hgap: 16pt;
    -fx-vgap: 2pt;
    -fx-background-color: #3D3D3D;
    -fx-padding: 8 8 8 8;
}

.spacingBig {
    -fx-spacing: 16px;
    -fx-hgap: 16px;
    -fx-vgap: 16px;
}

.spacing {
    -fx-spacing: 8px;
    -fx-hgap: 8px;
    -fx-vgap: 8px;
}

.spacingSmall {
    -fx-spacing: 2px;
    -fx-hgap: 2px;
    -fx-vgap: 2px;
}

.subheadingPadding {
    -fx-padding: 0 0 0 2;
}


.commandFeedback{
    -fx-text-fill: #FFFFFF;
    -fx-font-family: "Segoe UI";
    -fx-font-size: 12pt;
}

.commandFeedback.error {
    -fx-text-fill: #FF6464;
}

.commandInput {
    -fx-font-family: "Consolas";
    -fx-font-size: 20px;
}

.commandInput.error {
    -fx-border-color: #FF6464;
    -fx-border-width: 2px;
    -fx-text-fill: #FF6464;
}

.commandError {
    -fx-text-fill: #FFFFFF;
    -fx-font-family: "Segoe UI";
    -fx-font-size: 12pt;
    -fx-wrap-text: true;
}

.roundLabel {
    -fx-background-radius: 10;
    -fx-text-fill: #ffffff;
    -fx-background-color: #2D2D2D;
    -fx-font-size: 10pt;
    -fx-font-family: "Segoe UI Semilight";
}

/***View Filter Styles Start***/
.viewFilter .label{
    -fx-font-family: "Segoe UI";
    -fx-font-size: 14pt;
    -fx-text-fill: #FFFFFF;
}

.viewFilter .selected {
    -fx-background-color: #FFFFFF;
    -fx-background-radius: 100;
    -fx-padding: 0 8 0 8;
}

.viewFilter .selected .label {
    -fx-text-fill: #2D2D2D;
    -fx-font-family: "Segoe UI Semibold";
}

```
###### \src\main\resources\style\DefaultStyle.css
``` css
/***TaskCardView Styles Start***/
/*Default and Base*/
.taskCard .label {
    -fx-font-smoothing-type: lcd;
}

.taskCard .titleLabel {
    -fx-font-size: 16pt;
    -fx-font-family: "Segoe UI Semibold";
}

.taskCard .descriptionLabel {
    -fx-font-size: 12pt;
    -fx-font-family: "Segoe UI";
}

.taskCard .footnoteLabel {
    -fx-font-size: 10pt;
    -fx-font-family: "Segoe UI Semilight";
    -fx-font-style: italic;
}

.taskCard .highlightedBackground {
    -fx-background-color: #00A4FF;
}

.taskCard .lightBackground {
    -fx-background-color: #d2d2d2;
}

.taskCard .pinImage {
    -fx-image: url("../images/star_gold.png");
    -fx-fit-to-width: 30px;
    -fx-fit-to-height: 30px;
}

.taskCard .dateImage {
    -fx-image: url("../images/clock_black.png");
    -fx-fit-to-width: 20px;
    -fx-fit-to-height: 20px;
}

.taskCard .locationImage {
    -fx-image: url("../images/location_black.png");
    -fx-fit-to-width: 20px;
    -fx-fit-to-height: 20px;
}

/*Completed*/
.completed .label{
    -fx-text-fill: #7F7F7F;
}

.completed .titleLabel .text {
    -fx-strikethrough: true;
}

.completed .roundLabel {
    -fx-background-color: #7F7F7F;
    -fx-text-fill: #ffffff;
}

.completed .pinImage {
    -fx-image: url("../images/star_grey.png");
}

.completed .dateImage {
    -fx-image: url("../images/clock_grey.png");
}

.completed .locationImage {
    -fx-image: url("../images/location_grey.png");
}

/*Overdue*/
.overdue {
    -fx-background-color: #FF6464;
}

.overdue .label {
    -fx-text-fill: #FFFFFF;
}

.overdue .roundLabel {
    -fx-background-color: #FFFFFF;
    -fx-text-fill: #FF6464;
}

.overdue .pinImage {
    -fx-image: url("../images/star_white.png");
}

.overdue .dateImage {
    -fx-image: url("../images/clock_white.png");
}

.overdue .locationImage {
    -fx-image: url("../images/location_white.png");
}


```
###### \src\main\resources\style\DefaultStyle.css
``` css
/*Selected*/
.selected {
    -fx-background-color: #00A4FF;
}

.selected .label {
    -fx-text-fill: #FFFFFF;
}

.selected .roundLabel {
    -fx-background-color: #FFFFFF;
    -fx-text-fill: #00A4FF;
}

.selected .pinImage {
    -fx-image: url("../images/star_white.png");
}

.selected .dateImage {
    -fx-image: url("../images/clock_white.png");
}

.selected .locationImage {
    -fx-image: url("../images/location_white.png");
}

/*Collapse*/
.collapsed .collapsible {
    visibility: collapse;
    -fx-pref-height: 0px;
    -fx-min-height: 0px;
}

/***TaskCardView Styles End***/

```
###### \src\test\java\guitests\AddCommandTest.java
``` java
/**
 * Test the add command via GUI.
 * Note:
 *      Order-ness of the tasks is not tested.
 *      Invalid command input is not tested.
 */
public class AddCommandTest extends TodoListGuiTest {

    @Test
    public void add_initialData() {
        //Test if the data has correctly loaded the data into view.
        assertTrue(todoListView.isDisplayedCorrectly());
    }

    @Test
    public void add_addTasks() {
        //Add a task
        ImmutableTask task1 = TaskFactory.task();
        executeAddTestHelper(task1);

        //Add another task
        ImmutableTask task2 = TaskFactory.task();
        executeAddTestHelper(task2);

        //Add duplicated task
        executeAddTestHelper(task2);
    }

    @Test
    public void add_addEvents() {
        //Add an event
        ImmutableTask event1 = TaskFactory.event();
        executeAddTestHelper(event1);

        //Add another event
        ImmutableTask event2 = TaskFactory.event();
        executeAddTestHelper(event2);

        //Add duplicated task
        executeAddTestHelper(event1);
    }

    @Test
    public void add_addManyRandom() {
        //Add a long list of random task, which in the end spans at least 2 pages.
        List<ImmutableTask> randomTaskList = TaskFactory.list(15, 25);
        randomTaskList.forEach(this::executeAddTestHelper);
    }

    /* Helper Methods */
    /**
     * Gets the index of the newly added task.
     */
    private int getNewlyAddedTaskIndex() {
        return TestUtil.compareAndGetIndex(previousTasksFromView, todoListView.getImmutableTaskList());
    }

    /**
     * A helper method to run the entire add command process and testing.
     */
    private void executeAddTestHelper(ImmutableTask task) {
        updatePreviousTaskListFromView();
        executeAddCommand(task);
        assertCorrectnessHelper(task);
    }

    /**
     * Executes an add command given a {@code task}
     */
    private void executeAddCommand(ImmutableTask task) {
        String commandText = CommandGeneratorUtil.generateAddCommand(task);
        runCommand(commandText);
    }

    private void assertCorrectnessHelper(ImmutableTask newTask) {
        int addedIndex = getNewlyAddedTaskIndex();
        TaskCardViewHandle taskCardHandle = todoListView.getTaskCardViewHandle(addedIndex);

        assertAddSuccess(taskCardHandle, newTask, addedIndex);
        assertCorrectFeedbackDisplayed(newTask);
        assertCollapsed(taskCardHandle);
    }

    /**
     * Check the two following areas:
     *      1. If the {@code task} added to the view is reflected correctly in it's own task card view.
     *      2. If the remaining task cards are present and still displayed correctly in their own
     *         respective card views.
     */
    private void assertAddSuccess(TaskCardViewHandle newTaskHandle, ImmutableTask newTask, int addedListIndex) {
        int expectedDisplayedIndex = UiTestUtil.convertToUiIndex(addedListIndex);

        //Test for the newly added task.
        assertTrue(newTaskHandle.isDisplayedCorrectly(expectedDisplayedIndex, newTask));

        //Test for remaining tasks.
        assertTrue(todoListView.isDisplayedCorrectly());
    }

    /**
     * Check if the correct feedback message for adding has been displayed to the user.
     */
    private void assertCorrectFeedbackDisplayed(ImmutableTask task) {
        assertFeedbackMessage("\'" + task.getTitle() + "\' successfully added!");
    }

    /**
     * Tasks should be collapsed when newly added.
     * Checks the case where if the task is collapsible,
     * then the task is in the collapsed state when newly added.
     */
    private void assertCollapsed(TaskCardViewHandle newTask) {
        if (newTask.isTaskCollapsible()) {
            assertTrue(newTask.isTaskCardCollapsed());
        }
    }
}
```
###### \src\test\java\guitests\DeleteCommandTest.java
``` java
/**
 * Test the delete command via GUI.
 * Note:
 *      Invalid indices are not tested.
 */
public class DeleteCommandTest extends TodoListGuiTest {

    @Override
    protected TodoList getInitialData() {
        return getInitialDataHelper(10, 20);
    }

    @Test
    public void delete_correctBoundary() {
        //delete the last item in the list
        executeDeleteHelper(initialTaskData.size());

        //delete the first in the list (note that we initialised the size to be > 2.
        executeDeleteHelper(1);

    }

    @Test
    public void delete_allTasks() {
        //delete all the elements, until you have none left.
        Random random = new Random();
        int remainingTasks = initialTaskData.size();
        while (remainingTasks > 0) {
            int randomChoice = random.nextInt(remainingTasks--) + 1;
            executeDeleteHelper(randomChoice);
        }
    }

    /**
     * A helper method to run the entire delete command process and testing.
     */
    private void executeDeleteHelper(int displayedIndex) {
        ImmutableTask deletedTask = executeDeleteCommand(displayedIndex);
        assertDeleteSuccess(deletedTask);
        assertCorrectFeedbackDisplayed(deletedTask);
    }

    /**
     * Deletes a task from the to-do list view, and returns the deleted task for verification.
     */
    private ImmutableTask executeDeleteCommand(int displayedIndex) {
        int listIndex = UiTestUtil.convertToListIndex(displayedIndex);
        String commandText = CommandGeneratorUtil.generateDeleteCommand(displayedIndex);
        ImmutableTask deletedTask = todoListView.getTask(listIndex);

        runCommand(commandText);
        return deletedTask;
    }

    /**
     * Check if the {@code task} deleted from the view is reflected correctly (i.e. it's no longer there)
     * and check if the remaining tasks are displayed correctly.
     */
    private void assertDeleteSuccess(ImmutableTask deletedTask) {
        //Check if the task is really deleted.
        assertFalse(todoListView.getImmutableTaskList().contains(deletedTask));

        //Test if the remaining list is correct.
        assertTrue(todoListView.isDisplayedCorrectly());
    }

    /**
     * Check if the correct feedback message for deleting has been displayed to the user.
     */
    private void assertCorrectFeedbackDisplayed(ImmutableTask task) {
        assertFeedbackMessage("\'" + task.getTitle() + "\' successfully deleted!");
    }

}
```
###### \src\test\java\guitests\guihandles\CommandFeedbackViewHandle.java
``` java
/**
 * A handler for retrieving feedback to user via {@link CommandFeedbackView}
 */
public class CommandFeedbackViewHandle extends GuiHandle {
    /* Constants */
    public static final String FEEDBACK_VIEW_LABEL_ID = "#commandFeedbackLabel";

    /**
     * Constructs a handle to the {@link CommandFeedbackViewHandle}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public CommandFeedbackViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /**
     * Get the feedback {@link Label} object.
     */
    private Label getFeedbackLabel() {
        return (Label) getNode(FEEDBACK_VIEW_LABEL_ID);
    }

    /**
     * Get the text that is displayed on this {@link #getFeedbackLabel()} object.
     */
    public String getText() {
        return getFeedbackLabel().getText();
    }

    /**
     * Returns true if the {@code feedbackMessage} matches the displayed message in the view.
     */
    public boolean doesFeedbackMessageMatch(String feedbackMessage) {
        return this.getText().equals(feedbackMessage);
    }

    /**
     * Returns true if this feedback view has error style applied.
     */
    public boolean isErrorStyleApplied() {
        return UiTestUtil.containsStyleClass(getFeedbackLabel(), "error");
    }
}
```
###### \src\test\java\guitests\guihandles\CommandInputViewHandle.java
``` java
/**
 * A handle to the {@link CommandInputView}'s command text box in the GUI.
 */
public class CommandInputViewHandle extends GuiHandle {
    /* Constants */
    private static final String COMMAND_INPUT_FIELD_ID = "#commandTextField";

    /**
     * Constructs a handle to the {@link CommandInputView}
     *
     * @param guiRobot {@link GuiRobot} for the current GUI test.
     * @param primaryStage The stage where the views for this handle is located.
     */
    public CommandInputViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /* Interfacing Methods */
    /**
     * Types in the supplied command into the text box in {@link CommandInputView}.
     *      Note: any existing text in the text box will be replaced.
     *      Note: this method will not execute the command. See {@link #runCommand(String)}.
     * @param command Command text to be supplied into the text box.
     */
    public void enterCommand(String command) {
        setTextAreaText(COMMAND_INPUT_FIELD_ID, command);
    }

    /**
     * Gets the command text that is inside the text box in {@link CommandInputView}.
     * @return A command text.
     */
    public String getCommandInput() {
        return getTextAreaText(COMMAND_INPUT_FIELD_ID);
    }

```
###### \src\test\java\guitests\guihandles\TaskCardViewHandle.java
``` java
/**
 * Provides a handle to a {@link TaskCardView}
 * that exists in {@link TodoListView}
 */
public class TaskCardViewHandle extends GuiHandle {

    /* Constants */
    private static final String TITLE_LABEL_ID = "#titleLabel";
    private static final String DESCRIPTION_LABEL_ID = "#descriptionLabel";
    private static final String DATE_LABEL_ID = "#dateLabel";
    private static final String LOCATION_LABEL_ID = "#locationLabel";

    private static final String DESCRIPTION_BOX_ID = "#descriptionBox";
    private static final String DATE_BOX_ID = "#dateBox";
    private static final String LOCATION_BOX_ID = "#locationBox";

    private static final String PIN_IMAGE_ID = "#pinImage";

    private static final String TYPE_LABEL_ID = "#typeLabel";
    private static final String MOREINFO_LABEL_ID = "#moreInfoLabel";

    /* Variables */
    private Node rootNode;

    /**
     * Constructs a handle for {@link TaskCardView}.
     *
     * @param guiRobot The GUI test robot.
     * @param primaryStage The main stage that is executed from the application's UI.
     * @param rootNode Node that houses the contents of this Task Card.
     */
    public TaskCardViewHandle(GuiRobot guiRobot, Stage primaryStage, Node rootNode){
        super(guiRobot, primaryStage, null);
        this.rootNode = rootNode;
    }

    /* Task Property Getters */
    public String getDisplayedTitle() {
        return getTextFromLabel(TITLE_LABEL_ID);
    }

    public String getDisplayedDescription() {
        return getTextFromLabel(DESCRIPTION_LABEL_ID);
    }

    public String getDisplayedDateText() {
        return getTextFromLabel(DATE_LABEL_ID);
    }

    public String getDisplayedLocation() {
        return getTextFromLabel(LOCATION_LABEL_ID);
    }

    public String getDisplayedTypeLabel() {
        return getTextFromLabel(TYPE_LABEL_ID);
    }

    public boolean getMoreInfoLabelVisibility() {
        Node moreInfoLabel = getNode(MOREINFO_LABEL_ID);
        return UiTestUtil.isDisplayed(moreInfoLabel);
    }

    public boolean getDescriptionBoxVisibility() {
        Node descriptionBox = getNode(DESCRIPTION_BOX_ID);
        return UiTestUtil.isDisplayed(descriptionBox);
    }

    public boolean getDateBoxVisibility() {
        Node dateBox = getNode(DATE_BOX_ID);
        return UiTestUtil.isDisplayed(dateBox);
    }

    public boolean getLocationBoxVisibility() {
        Node locationBox = getNode(LOCATION_BOX_ID);
        return UiTestUtil.isDisplayed(locationBox);
    }

    public boolean getPinImageVisibility() {
        Node pinImage = getNode(PIN_IMAGE_ID);
        return UiTestUtil.isDisplayed(pinImage);
    }

    public boolean isSelectedStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "selected");
    }

    public boolean isCompletedStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "completed");
    }

    public boolean isOverdueStyleApplied() {
        return UiTestUtil.containsStyleClass(rootNode, "overdue");
    }

    public boolean isTaskCardCollapsed() {
        return UiTestUtil.containsStyleClass(rootNode, "collapsed");
    }

    public boolean isTaskCollapsible() {
        return !getDisplayedDescription().isEmpty();
    }

    /* General Methods */
    /**
     * Checks if the supplied index matches to what this node displays.
     * To be used for nodes filtering.
     */
    public boolean matchesTask(int displayedIndex) {
        return getDisplayedTitle().startsWith(displayedIndex + ". ");
    }

    /**
     * Given an {@link ImmutableTask} and a displayed index, check if this view is displayed correctly.
     * @param displayedIndex Index displayed in the view.
     * @param task Task displayed in the view.
     * @return Returns true only if and only if the elements in this view is displayed correctly.
     * TODO: Maybe we do not need this at all.
     */
    public boolean isDisplayedCorrectly(int displayedIndex, ImmutableTask task) {
        //JUnit Assertion Test: To know which test are failing in detail
        assertTrue(isTitleCorrect(displayedIndex, task));
        assertTrue(isDescriptionCorrect(task));
        assertTrue(isTaskCardCollapsedStateCorrect());
        assertTrue(isCompletedDisplayCorrect(task));
        assertTrue(isDateTextCorrect(task));
        assertTrue(isLocationCorrect(task));
        assertTrue(isTypeDisplayCorrect(task));
        assertTrue(isPinDisplayCorrect(task));
        assertTrue(isOverdueDisplayCorrect(task));
        return true;
    }

    private boolean isTitleCorrect(int displayedIndex, ImmutableTask task) {
        String expected = convertToDisplayedTitle(displayedIndex, task.getTitle());
        String actual = getDisplayedTitle();
        return expected.equals(actual);
    }

    private boolean isDescriptionCorrect(ImmutableTask task) {
        java.util.Optional<String> description = task.getDescription();

        if (description.isPresent()) {
            //If there is a task description, it should match with the displayed description.
            String expected = description.get();
            String actual = getDisplayedDescription();
            return expected.equals(actual);
        } else {
            //Description should be hidden when there is no description.
            boolean expected = false;
            boolean actual = getDescriptionBoxVisibility();
            return expected == actual;
        }
    }

    private boolean isDateTextCorrect(ImmutableTask task) {
        java.util.Optional<LocalDateTime> startTime = task.getStartTime();
        java.util.Optional<LocalDateTime> endTime = task.getEndTime();

        TimeUtil timeUtil = new TimeUtil();

        String displayedDateText = getDisplayedDateText();
        String expectedDateText;

        if (!startTime.isPresent() && !endTime.isPresent()) {
            //Date box should be hidden when there is no start and end time.
            return !getDateBoxVisibility();
        } else if (startTime.isPresent() && endTime.isPresent()) {
            //When start and end date are available, expect event format
            expectedDateText = timeUtil.getEventTimeText(startTime.get(), endTime.get());
        } else if (endTime.isPresent()) {
            //When only end time is present, expect deadline format
            expectedDateText = timeUtil.getTaskDeadlineText(endTime.get());
        } else {
            //Otherwise, illegal date state.
            throw new IllegalStateException("Start time is present, but end time is not.");
        }
        return expectedDateText.equals(displayedDateText);
    }

    private boolean isLocationCorrect(ImmutableTask task) {
        java.util.Optional<String> location = task.getLocation();

        if (location.isPresent()) {
            //If there is a location, it should match with the displayed location.
            String expected = location.get();
            String actual = getDisplayedLocation();
            return expected.equals(actual);
        } else {
            //Description should be hidden when there is no description.
            boolean expected = false;
            boolean actual = getLocationBoxVisibility();
            return expected == actual;
        }
    }

    private boolean isPinDisplayCorrect(ImmutableTask task) {
        boolean expected = task.isPinned();
        boolean actual = getPinImageVisibility();
        return expected == actual;
    }

    private boolean isCompletedDisplayCorrect(ImmutableTask task) {
        boolean expected = task.isCompleted();
        boolean actual = isCompletedStyleApplied();
        return expected == actual;
    }

    private boolean isOverdueDisplayCorrect(ImmutableTask task) {
        java.util.Optional<LocalDateTime> endTime = task.getEndTime();
        boolean actual = isOverdueStyleApplied();
        boolean expected;

        if (endTime.isPresent() && !task.isEvent()) {
            expected = seedu.todo.testutil.TimeUtil.isOverdue(endTime.get());
        } else {
            expected = false;
        }
        return expected == actual;
    }

    private boolean isTypeDisplayCorrect(ImmutableTask task) {
        String actual = getDisplayedTypeLabel();
        String expected;

        if (task.isEvent()) {
            expected = "Event";
        } else {
            expected = "Task";
        }

        return expected.equals(actual);
    }

    public boolean isTaskCardCollapsedStateCorrect() {
        boolean collapsedStyleApplied = UiTestUtil.containsStyleClass(rootNode, "collapsed");
        boolean moreInfoLabelDisplayed = UiTestUtil.isDisplayed(getNode(MOREINFO_LABEL_ID));

        if (isTaskCollapsible()) {
            return collapsedStyleApplied == moreInfoLabelDisplayed;
        } else {
            return !moreInfoLabelDisplayed;
        }
    }

    /* View Elements Helper Methods */
```
###### \src\test\java\guitests\guihandles\TaskCardViewHandle.java
``` java
    /**
     * Gets a text from the node with {@code fieldId}.
     *
     * @param fieldId To get the node's text from.
     * @return Returns the text presented in the node.
     */
    private String getTextFromLabel(String fieldId) {
        return ((Label) getNode(fieldId)).getText();
    }

    /**
     * Converts {@code actualTitle} to a displayed title with the relevant {@code displayedIndex}.
     * @param displayedIndex The index that is shown on the title displayed to the user.
     * @param actualTitle The actual title of the task.
     * @return Returns a title text that is actually displayed to the user.
     */
    private String convertToDisplayedTitle(int displayedIndex, String actualTitle) {
        return displayedIndex + ". " + actualTitle;
    }

```
###### \src\test\java\guitests\guihandles\TodoListViewHandle.java
``` java
/**
 * Provides a handle for the {@link TodoListView}
 * containing a list of tasks.
 */
public class TodoListViewHandle extends GuiHandle {

    /* Constants */
    public static final int NOT_FOUND = -1;
    private static final String TASK_CARD_ID = "#taskCard";
    private static final String TODO_LIST_VIEW_ID = "#todoListView";

```
###### \src\test\java\guitests\guihandles\TodoListViewHandle.java
``` java
    /**
     * Gets a list of {@link ImmutableTask}
     */
    public List<ImmutableTask> getImmutableTaskList() {
        return getTodoListView().getItems();
    }

    /**
     * Gets a set of task card nodes in this to-do list.
     */
    public Set<Node> getAllTaskCardNodes() {
        return guiRobot.lookup(TASK_CARD_ID).queryAll();
    }

    /**
     * Gets a specific task from the list of tasks stored in the view by the list index.
     */
    public ImmutableTask getTask(int listIndex) {
        return getImmutableTaskList().get(listIndex);
    }

    /**
     * Gets the first occurring element from {@link #getImmutableTaskList()}
     * where the detail matches the {@code task} param.
     *
     * @return Returns a value bounded from 0 to length - 1.
     *         Also returns {@code NOT_FOUND} (value of -1) if not found in the list.
     */
    public int getFirstTaskIndex(ImmutableTask task) {
        List<ImmutableTask> tasks = getImmutableTaskList();
        for (int listIndex = 0; listIndex < tasks.size(); listIndex++) {
            ImmutableTask taskInList = tasks.get(listIndex);
            if (TestUtil.isShallowEqual(task, taskInList)) {
                return listIndex;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a {@link TaskCardViewHandle} object with the position {@code listIndex} located in the to-do list view.
     * Guaranteed unique result for identical tasks.
     * Inherits the behaviour from {@link #getTaskCardViewNode(int)}.
     *
     * @param listIndex Index of the {@link #getImmutableTaskList()}.
     * @return An instance of the handle.
     */
    public TaskCardViewHandle getTaskCardViewHandle(int listIndex) {
        Node taskCardNode = getTaskCardViewNode(listIndex);
        if (taskCardNode != null) {
            return new TaskCardViewHandle(guiRobot, primaryStage, taskCardNode);
        } else {
            return null;
        }
    }

    /**
     * Gets a {@link Node} object with the position {@code listIndex} located in the to-do list view.
     * Guarantees:
     *      -  Unique result for identical tasks, because we are referencing from the index displayed
     *         in the UI.
     *      -  The object returned will never be null.
     *         This means if I can't find the object, an exception will be thrown.
     * Behaviour:
     *      Because a task card node is only drawn when the task card is shown on the screen,
     *      this method will automatically scroll the to-do list view to the position where the
     *      node is drawn.
     *
     * @param listIndex Index of the {@link #getImmutableTaskList()}
     *                  (must be a valid value from 0 to length of task list - 1,
     *                  else {@link RuntimeException} is thrown.
     * @return An instance of the node. Guarantees non-null.
     * @throws NodeFinderException if we can't find the node after finite attempts.
     */
    private Node getTaskCardViewNode(int listIndex) throws NodeFinderException {
        int displayedIndex = UiTestUtil.convertToUiIndex(listIndex);
        Optional<Node> possibleNode;
        int attemptCounter = 0;

        do {
            Platform.runLater(() -> getTodoListView().scrollTo(listIndex));
            guiRobot.sleep(50 * attemptCounter++); //Allow the new nodes to be loaded from scrolling.

            Set<Node> taskCardNodes = getAllTaskCardNodes();
            possibleNode = taskCardNodes.stream().filter(node -> {
                TaskCardViewHandle taskCardView = new TaskCardViewHandle(guiRobot, primaryStage, node);
                return taskCardView.matchesTask(displayedIndex);
            }).findFirst();
        } while (!possibleNode.isPresent() && attemptCounter < 50);

        if (possibleNode.isPresent()) {
            return possibleNode.get();
        } else {
            String errorMessage
                    = "Either the node fails to draw on the screen, or you provided an invalid index "
                    + listIndex + " where the number of nodes is " + getAllTaskCardNodes().size();
            throw new NodeFinderException(errorMessage, NodeFinderException.ErrorType.NO_NODES_FOUND);
        }
    }

    /**
     * Checks if all the tasks stored inside the to-do list are displayed correctly.
     * Note: This does not check the sorted-ness of the list.
     * @return True if all the items are correctly displayed.
     */
    public boolean isDisplayedCorrectly() {
        return doesTodoListMatch();
    }

    /**
     * Given a list of tasks, check if all the tasks in the list are displayed correctly in the
     * {@link TodoListView}.
     * Note: this does not check the sorted-ness of the list.
     *
     * @return True if all the tasks in the {@code tasks} are displayed correctly.
     */
    public boolean doesTodoListMatch() {
        boolean outcome = true;
        List<ImmutableTask> tasks = getImmutableTaskList();
        for (int listIndex = 0; listIndex < tasks.size(); listIndex++) {
            ImmutableTask task = tasks.get(listIndex);
            TaskCardViewHandle handle = getTaskCardViewHandle(listIndex);
            int displayedIndex = UiTestUtil.convertToUiIndex(listIndex);
            outcome &= handle.isDisplayedCorrectly(displayedIndex, task);
        }
        return outcome;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point= TestUtil.getScreenMidPoint(getTodoListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code tasks} appear as the sub list (in that order) at position
     * {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ImmutableTask... tasks) {
        List<ImmutableTask> taskList = getImmutableTaskList();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + tasks.length > taskList.size()){
            return false;
        }

        // Return false if any of the task doesn't match
        for (int i = 0; i < tasks.length; i++) {
            ImmutableTask taskInView = taskList.get(i);
            ImmutableTask taskInList = tasks[i];
            if (!taskInView.equals(taskInList)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Navigates the {@link TodoListView} to display and select the task.
     * @param listIndex Index of the list that the list view should navigate to.
     * @return Handle of the selected task.
     */
    public TaskCardViewHandle navigateToTask(int listIndex) {
        guiRobot.interact(() -> {
            getTodoListView().scrollTo(listIndex);
            guiRobot.sleep(150);
            getTodoListView().getSelectionModel().select(listIndex);
        });
        guiRobot.sleep(100);
        return getTaskCardViewHandle(listIndex);
    }
}
```
###### \src\test\java\seedu\todo\commons\util\StringUtilTest.java
``` java
    @Test
    public void partitionStringAtPosition_emptyString() {
        String[] expected = {"", "", ""};

        //Tests null string
        testPartitionStringAtPositionHelper(null, 0, expected);

        //Test empty String
        testPartitionStringAtPositionHelper("", 0, expected);
    }

    @Test
    public void partitionStringAtPosition_positionOutOfBounds() {
        String input = "I have a Pikachu";
        String[] expected = {"", "", ""};

        //Tests position too low
        testPartitionStringAtPositionHelper(input, -1, expected);

        //Tests position too high
        testPartitionStringAtPositionHelper(input, 16, expected);
    }

    @Test
    public void partitionStringAtPosition_partitionCorrectly() {
        String input = "I have a Pikachu";

        //Test lower bound
        testPartitionStringAtPositionHelper(input, 0, new String[] {"", "I", " have a Pikachu"});

        //Test upper bound
        testPartitionStringAtPositionHelper(input, 15, new String[] {"I have a Pikach", "u", ""});

        //Test normal partition
        testPartitionStringAtPositionHelper(input, 5, new String[] {"I hav", "e", " a Pikachu"});
    }

    /**
     * Helper method to test partitionStringAtPosition(...).
     * @param input String to be partitioned.
     * @param position Position where partition should take place.
     * @param expected Expected output as String array.
     */
    private void testPartitionStringAtPositionHelper(String input, int position, String[] expected) {
        String[] outcome = StringUtil.partitionStringAtPosition(input, position);
        assertArrayEquals(expected, outcome);
    }

    @Test
    public void splitString_emptyInput() {
        String[] expected = new String[0];

        //Test null input.
        testSplitStringHelper(null, expected);

        //Test empty input.
        testSplitStringHelper("", expected);

        //Test only space and commas.
        testSplitStringHelper(" , ,   ,,, ,,,, , , ,,, , ,", expected);
    }

    @Test
    public void splitString_validInput() {
        //Input does not include space and comma
        testSplitStringHelper("!@(*&$!R#@%", new String[]{"!@(*&$!R#@%"});

        //Test one element
        testSplitStringHelper("Pichu-Pikachu_RAICHU's", new String[] {"Pichu-Pikachu_RAICHU's"});

        //Test multiple element split by space and comma
        testSplitStringHelper("an apple a, day, keeps , , doctor ,,, away",
                new String[] {"an", "apple", "a", "day", "keeps", "doctor", "away"});
    }

    /**
     * Helper method to test splitString(...).
     * @param input String to be split.
     * @param expected Expected output as String array.
     */
    private void testSplitStringHelper(String input, String[] expected) {
        String[] outcome = StringUtil.splitString(input);
        assertArrayEquals(expected, outcome);
    }

    @Test
    public void testConvertListToString_emptyList() {
        String expected = "";

        //Test null list
        testConvertListToStringHelper(null, expected);

        //Test empty list
        testConvertListToStringHelper(new String[0], expected);
    }

    @Test
    public void testConvertListToString_validInput() {
        //Test one element
        testConvertListToStringHelper(new String[]{"applepie123!"}, "applepie123!");

        //Test several elements
        testConvertListToStringHelper(new String[]{"this", "is", "apple", "pen"}, "this, is, apple, pen");
    }

    /**
     * Helper method to test splitString(...).
     * @param input String to be split.
     * @param expected Expected output as String array.
     */
    private void testConvertListToStringHelper(String[] input, String expected) {
        String outcome = StringUtil.convertListToString(input);
        assertEquals(expected, outcome);
    }

```
###### \src\test\java\seedu\todo\commons\util\TimeUtilTest.java
``` java
/**
 * Tests the TimeUtil class
 */
public class TimeUtilTest {

    /**
     * A subclass of TimeUtil that provides the ability to override the current system time, 
     * so that time sensitive components can be conveniently tested. 
     */
    private class ModifiedTimeUtil extends TimeUtil {
        
        /**
         * Construct a ModifiedTimeUtil object overriding the current time with Clock object.
         * Is only used for dependency injection in testing time sensitive components.
         */
        private ModifiedTimeUtil(Clock clock) {
            this.clock = clock;
        }
        
        /**
         * Construct a ModifiedTimeUtil object overriding the current time with LocalDateTime object.
         * Is only used for dependency injection in testing time sensitive components.
         */
        public ModifiedTimeUtil(LocalDateTime pseudoCurrentTime) {
            this(Clock.fixed(pseudoCurrentTime.toInstant(
                    ZoneId.systemDefault().getRules().getOffset(pseudoCurrentTime)), ZoneId.systemDefault()));
        }
    }
    
    /**
     * Aids to test taskDeadlineText with a current time and due time, against an expected output.
     */
    private void testTaskDeadlineTextHelper(String expectedOutput, LocalDateTime currentTime,
                                            LocalDateTime dueTime) {
        TimeUtil timeUtil = new ModifiedTimeUtil(currentTime);
        String generatedOutput = timeUtil.getTaskDeadlineText(dueTime);
        assertEquals(expectedOutput, generatedOutput);
    }

    /**
     * Aids to test eventTimeText with a current time, startTime and endTime, against an expected output.
     */
    private void testEventTimeTextHelper(String expectedOutput, LocalDateTime currentTime,
                                         LocalDateTime startTime, LocalDateTime endTime) {
        TimeUtil timeUtil = new ModifiedTimeUtil(currentTime);
        String generatedOutput = timeUtil.getEventTimeText(startTime, endTime);
        assertEquals(expectedOutput, generatedOutput);
    }
        
    @Test
    public void getTaskDeadlineString_nullEndTime() {
        testTaskDeadlineTextHelper("", LocalDateTime.now(), null);
    }
    
    @Test
    public void getTaskDeadlineText_dueNow() {
        String expectedOutput = "due now";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Lower Bound: 0th second
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0), dueTime);
        //Upper Bound: 59th second
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 59), dueTime);
        //In the middle: 30th second
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 30), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_dueLessThanAMinute() {
        String expectedOutput = "in less than a minute";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Lower bound: 59 seconds left
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 1), dueTime);
        //Upper bound: 1 second left
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 59), dueTime);
        //In the middle: 30 seconds left
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 30), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_aMinuteBeforeDeadline() {
        String expectedOutput = "in 1 minute";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Upper Bound
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 59, 0), dueTime);
        //In the middle
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 58, 30), dueTime);
        //Lower Bound
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 11, 58, 1), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_aMinuteAfterDeadline() {
        String expectedOutput = "1 minute ago";
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Lower Bound
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 1, 0), dueTime);
        //Middle
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 1, 30), dueTime);
        //Upper Bound
        testTaskDeadlineTextHelper(expectedOutput, LocalDateTime.of(2016, Month.MARCH, 20, 12, 1, 59), dueTime);
    }
    
    @Test
    public void getTaskDeadlineText_minutesBeforeDeadline() {
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Test 2 min to 59 min
        for (int minutesLeft = 2; minutesLeft <= 59; minutesLeft++) {
            String expectedOutput = "in " + minutesLeft + " minutes";
            
            testTaskDeadlineTextHelper(expectedOutput, dueTime.minusMinutes(minutesLeft), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.minusMinutes(minutesLeft).minusSeconds(30), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.minusMinutes(minutesLeft).minusSeconds(59), dueTime);
        }
    }
    
    @Test
    public void getTaskDeadlineText_minutesAfterDeadline() {
        LocalDateTime dueTime = LocalDateTime.of(2016, Month.MARCH, 20, 12, 0, 0);

        //Test 2 min to 59 min
        for (int minutesLater = 2; minutesLater <= 59; minutesLater++) {
            String expectedOutput = minutesLater + " minutes ago";
            
            testTaskDeadlineTextHelper(expectedOutput, dueTime.plusMinutes(minutesLater), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.plusMinutes(minutesLater).plusSeconds(30), dueTime);
            testTaskDeadlineTextHelper(expectedOutput, dueTime.plusMinutes(minutesLater).plusSeconds(59), dueTime);
        }
    }
    
    @Test
    public void getTaskDeadlineText_todayBeforeDeadline() {
        testTaskDeadlineTextHelper("by today, 5:59 PM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 10, 45), LocalDateTime.of(2016, Month.MARCH, 20, 17, 59));
        testTaskDeadlineTextHelper("by tonight, 6:00 PM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 11, 58), LocalDateTime.of(2016, Month.MARCH, 20, 18, 0));
        testTaskDeadlineTextHelper("in 30 minutes", 
                LocalDateTime.of(2016, Month.MARCH, 20, 0, 0), LocalDateTime.of(2016, Month.MARCH, 20, 0, 30));
    }
    
    @Test
    public void getTaskDeadlineText_todayAfterDeadline() {
        testTaskDeadlineTextHelper("since today, 12:00 PM",
                LocalDateTime.of(2016, Month.MARCH, 20, 18, 45), LocalDateTime.of(2016, Month.MARCH, 20, 12, 0));
        testTaskDeadlineTextHelper("since tonight, 6:50 PM",
                LocalDateTime.of(2016, Month.MARCH, 20, 23, 58), LocalDateTime.of(2016, Month.MARCH, 20, 18, 50));
        testTaskDeadlineTextHelper("30 minutes ago", 
                LocalDateTime.of(2016, Month.MARCH, 20, 0, 30), LocalDateTime.of(2016, Month.MARCH, 20, 0, 0));
    }
    
    @Test
    public void getTaskDeadlineText_tomorrowBeforeDeadline() {
        testTaskDeadlineTextHelper("by tomorrow, 12:00 PM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 12, 0), LocalDateTime.of(2016, Month.MARCH, 21, 12, 0));
        testTaskDeadlineTextHelper("by tomorrow, 12:51 AM", 
                LocalDateTime.of(2016, Month.MARCH, 20, 23, 50), LocalDateTime.of(2016, Month.MARCH, 21, 0, 51));
        testTaskDeadlineTextHelper("in 20 minutes", 
                LocalDateTime.of(2016, Month.MARCH, 20, 23, 50), LocalDateTime.of(2016, Month.MARCH, 21, 0, 10));
    }
    
    @Test
    public void getTaskDeadlineText_yesterdayAfterDeadline() {
        testTaskDeadlineTextHelper("since yesterday, 12:00 PM", 
                LocalDateTime.of(2016, Month.MARCH, 21, 12, 0), LocalDateTime.of(2016, Month.MARCH, 20, 12, 0));
        testTaskDeadlineTextHelper("since yesterday, 12:51 AM",
                LocalDateTime.of(2016, Month.MARCH, 21, 23, 50), LocalDateTime.of(2016, Month.MARCH, 20, 0, 51));
        testTaskDeadlineTextHelper("20 minutes ago", 
                LocalDateTime.of(2016, Month.MARCH, 21, 0, 10), LocalDateTime.of(2016, Month.MARCH, 20, 23, 50));
    }
    
    @Test
    public void getTaskDeadlineText_thisYearBeforeDeadline() {
        testTaskDeadlineTextHelper("by 12 August, 12:55 PM", 
                LocalDateTime.of(2016, Month.JANUARY, 21, 12, 0),
                LocalDateTime.of(2016, Month.AUGUST, 12, 12, 55));

        testTaskDeadlineTextHelper("by 15 September, 12:00 AM",
                LocalDateTime.of(2016, Month.SEPTEMBER, 13, 23, 59),
                LocalDateTime.of(2016, Month.SEPTEMBER, 15, 0, 0));
    }
    
    @Test
    public void getTaskDeadlineText_thisYearAfterDeadline() {
        testTaskDeadlineTextHelper("since 21 January, 8:47 PM", 
                LocalDateTime.of(2016, Month.AUGUST, 12, 12, 55),
                LocalDateTime.of(2016, Month.JANUARY, 21, 20, 47));

        testTaskDeadlineTextHelper("since 13 September, 11:59 PM",
                LocalDateTime.of(2016, Month.SEPTEMBER, 15, 0, 0),
                LocalDateTime.of(2016, Month.SEPTEMBER, 13, 23, 59));
    }
    
    @Test
    public void getTaskDeadlineText_differentYearBeforeDeadline() {
        testTaskDeadlineTextHelper("in 1 minute", 
                LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59),
                LocalDateTime.of(2017, Month.JANUARY, 1, 0, 0));
        testTaskDeadlineTextHelper("by tomorrow, 1:15 AM",
                LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 0),
                LocalDateTime.of(2017, Month.JANUARY, 1, 1, 15));
        testTaskDeadlineTextHelper("by 31 January 2017, 1:05 AM",
                LocalDateTime.of(2016, Month.JUNE, 30, 22, 0),
                LocalDateTime.of(2017, Month.JANUARY, 31, 1, 5));
        testTaskDeadlineTextHelper("by 31 August 2020, 12:35 PM",
                LocalDateTime.of(2016, Month.FEBRUARY, 13, 13, 0),
                LocalDateTime.of(2020, Month.AUGUST, 31, 12, 35));
    }
    
    @Test
    public void getTaskDeadlineText_differentYearAfterDeadline() {
        testTaskDeadlineTextHelper("1 minute ago", 
                LocalDateTime.of(2017, Month.JANUARY, 1, 0, 0),
                LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59));
        testTaskDeadlineTextHelper("since yesterday, 12:00 AM",
                LocalDateTime.of(2017, Month.JANUARY, 1, 0, 0),
                LocalDateTime.of(2016, Month.DECEMBER, 31, 0, 0));
        testTaskDeadlineTextHelper("since 30 June 2016, 10:00 PM",
                LocalDateTime.of(2017, Month.JANUARY, 31, 1, 5),
                LocalDateTime.of(2016, Month.JUNE, 30, 22, 0));
        testTaskDeadlineTextHelper("since 13 February 2016, 1:00 PM",
                LocalDateTime.of(2020, Month.AUGUST, 31, 12, 35),
                LocalDateTime.of(2016, Month.FEBRUARY, 13, 13, 0));
    }
    
    @Test
    public void getEventTimeText_nullStartTime() {
        testEventTimeTextHelper("", LocalDateTime.now(), null, LocalDateTime.now().plusMinutes(1));
    }
    
    @Test
    public void getEventTimeText_nullEndTime() {
        testEventTimeTextHelper("", LocalDateTime.now(), LocalDateTime.now().plusMinutes(1), null);
    }

    @Test
    public void getEventTimeText_sameDay() {
        LocalDateTime currentTime = LocalDateTime.of(2016, 10, 20, 12, 00);
        testEventTimeTextHelper("yesterday, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2016, 10, 19, 20, 30));
        testEventTimeTextHelper("today, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 16, 50), LocalDateTime.of(2016, 10, 20, 20, 30));
        testEventTimeTextHelper("tonight, from 6:00 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 18, 00), LocalDateTime.of(2016, 10, 20, 20, 30));
        testEventTimeTextHelper("tomorrow, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 21, 16, 50), LocalDateTime.of(2016, 10, 21, 20, 30));
        testEventTimeTextHelper("21 November, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2016, 11, 21, 16, 50), LocalDateTime.of(2016, 11, 21, 20, 30));
        testEventTimeTextHelper("21 November 2017, from 4:50 PM to 8:30 PM", currentTime,
                LocalDateTime.of(2017, 11, 21, 16, 50), LocalDateTime.of(2017, 11, 21, 20, 30));
    }

    @Test
    public void getEventTimeText_differentDay() {
        LocalDateTime currentTime = LocalDateTime.of(2016, 10, 20, 12, 00);
        testEventTimeTextHelper("from yesterday, 4:50 PM to today, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2016, 10, 20, 14, 30));
        testEventTimeTextHelper("from yesterday, 4:50 PM to tonight, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2016, 10, 20, 20, 30));
        testEventTimeTextHelper("from today, 4:50 PM to tomorrow, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 16, 50), LocalDateTime.of(2016, 10, 21, 20, 30));
        testEventTimeTextHelper("from tonight, 6:50 PM to tomorrow, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 20, 18, 50), LocalDateTime.of(2016, 10, 21, 20, 30));
        testEventTimeTextHelper("from tomorrow, 6:50 PM to 22 October, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 21, 18, 50), LocalDateTime.of(2016, 10, 22, 20, 30));
        testEventTimeTextHelper("from 18 October, 6:50 PM to 22 October, 8:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 18, 18, 50), LocalDateTime.of(2016, 10, 22, 20, 30));
    }

    @Test
    public void getEventTimeText_differentYear() {
        LocalDateTime currentTime = LocalDateTime.of(2016, 12, 31, 12, 00);
        testEventTimeTextHelper("from 19 October, 4:50 PM to 3 January 2017, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2017, 1, 3, 14, 30));
        testEventTimeTextHelper("from 19 October, 4:50 PM to tomorrow, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 10, 19, 16, 50), LocalDateTime.of(2017, 1, 1, 14, 30));
        testEventTimeTextHelper("from today, 4:50 PM to 4 January 2017, 2:30 PM", currentTime,
                LocalDateTime.of(2016, 12, 31, 16, 50), LocalDateTime.of(2017, 1, 4, 14, 30));
    }
    
    @Test
    public void isOverdue_nullEndTime() {
        TimeUtil timeUtil = new TimeUtil();
        assertFalse(timeUtil.isOverdue(null));
    }
    
    @Test
    public void isOverdue_endTimeAfterNow() {
        TimeUtil timeUtil = new ModifiedTimeUtil(LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 34));
        LocalDateTime laterEndTime = LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 35);
        assertFalse(timeUtil.isOverdue(laterEndTime));
    }
    
    @Test
    public void isOverdue_endTimeBeforeNow() {
        TimeUtil timeUtil = new ModifiedTimeUtil(LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 36));
        LocalDateTime laterEndTime = LocalDateTime.of(2016, Month.DECEMBER, 12, 12, 35);
        assertTrue(timeUtil.isOverdue(laterEndTime));
    }

```
###### \src\test\java\seedu\todo\testutil\TaskFactory.java
``` java
    /**
     * Generates a list of random tasks with a random size between {@code lowerBound}
     * and {@code upperBound} inclusive.
     *
     * @return Returns a randomly generated list.
     */
    public static List<ImmutableTask> list(int lowerBound, int upperBound) {
        int size = lowerBound + random.nextInt(upperBound - lowerBound + 1);
        ArrayList<ImmutableTask> tasks = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            tasks.add(random());
        }
        return tasks;
    }
}
```
###### \src\test\java\seedu\todo\testutil\TimeUtil.java
``` java
    /**
     * Checks against system time if the provided dueTime is before system time.
     *
     * @param dueTime The due time to check against with the current system time.
     * @return Returns true if the provided dueTime is before system time.
     */
    public static boolean isOverdue(LocalDateTime dueTime) {
        return dueTime.isBefore(LocalDateTime.now());
    }

    /**
     * Gets the complete date time text in the following format:
     *      12 August 2015, 12:34 PM
     */
    public static String getDateTimeText(LocalDateTime dateTime) {
        return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_FULL_DATE));
    }
}
```
###### \src\test\java\seedu\todo\testutil\UiTestUtil.java
``` java
/**
 * This class stores all the commonly used helper functions that aids in GUI testing.
 */
public class UiTestUtil {

    /**
     * Checks if the node is displayed on the user interface by checking its properties.
     *
     * @param node The node to be tested for whether it is displayed on the UI.
     * @return Returns true if the node is displayed, false otherwise.
     */
    public static boolean isDisplayed(Node node) {
        //Checks if the node is hidden programatically
        boolean isVisible = node.isVisible();

        //Otherwise, check if the node is hidden with CSS styling
        boolean isCollapsed = parentContainsStyleClass(node, "collapsed");
        boolean isCollapsible = containsStyleClass(node, "collapsible");

        return isVisible && !(isCollapsed && isCollapsible);
    }

    public static boolean containsStyleClass(Node node, String styleClass) {
        return node.getStyleClass().contains(styleClass);
    }

    public static boolean parentContainsStyleClass(Node node, String styleClass) {
        return node.getStyleableParent().getStyleClass().contains(styleClass);
    }

    /**
     * Converts an index from a list to the index that is displayed to the user via the Ui
     */
    public static int convertToListIndex(int uiIndex) {
        return uiIndex - 1;
    }

    /**
     * Converts an index displayed on the Ui to the user, to the index used on the list
     */
    public static int convertToUiIndex(int listIndex) {
        return listIndex + 1;
    }

}
```
