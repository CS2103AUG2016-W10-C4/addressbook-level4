# A0135817B
###### \build\resources\main\style\DefaultStyle.css
``` css
.searchStatus {
    -fx-padding: 4px;
}

.searchStatus Text {
    -fx-font-size: 14px;
    -fx-fill: #fff;
}

.searchStatus .searchLabel {
}

.searchStatus .searchTerm {
    -fx-font-weight: bold;
}

.searchStatus .searchCount {
    -fx-text-alignment: right;
}

```
###### \classes\production\main\style\DefaultStyle.css
``` css
.searchStatus {
    -fx-padding: 4px;
}

.searchStatus Text {
    -fx-font-size: 14px;
    -fx-fill: #fff;
}

.searchStatus .searchLabel {
}

.searchStatus .searchTerm {
    -fx-font-weight: bold;
}

.searchStatus .searchCount {
    -fx-text-alignment: right;
}



```
###### \src\main\java\seedu\todo\commons\util\StringUtil.java
``` java
    /**
     * Returns true if the string is null, of length zero, or contains only whitespace 
     */
    public static boolean isEmpty(String s) {
        return s == null || s.length() == 0 || CharMatcher.whitespace().matchesAllOf(s);
    }

```
###### \src\main\java\seedu\todo\commons\util\TimeUtil.java
``` java
    /**
     * Translates input string from International date format (DD/MM/YYYY) to American
     * date format (MM/DD/YYYY), because Natty only recognizes the later 
     */
    public static String toAmericanDateFormat(String input) {
        return DATE_REGEX.matcher(input).replaceAll("$3$2$1");
    }
    
```
###### \src\main\java\seedu\todo\logic\arguments\Argument.java
``` java
abstract public class Argument<T> implements Parameter {
    private static final String REQUIRED_ERROR_FORMAT = "The %s parameter is required";
    private static final String TYPE_ERROR_FORMAT = "The %s should be a %s. You gave '%s'.";
    
    protected static final String OPTIONAL_ARGUMENT_FORMAT = "[%s]";
    protected static final String FLAG_ARGUMENT_FORMAT = "%s%s %s";
    
    private String name;
    private String description;
    private String flag;
    private boolean optional = true;
    private boolean boundValue = false;
    
    protected T value;
    
    private String requiredErrorMessage;
    
    private static final Logger logger = LogsCenter.getLogger(Argument.class);
    
    public Argument(String name) {
        this.name = name;
    }
    
    public Argument(String name, T defaultValue) {
        this.name = name;
        this.value = defaultValue;
    }
    
    /**
     * Binds a value to this parameter. Implementing classes MUST override AND 
     * call the parent class function so that the dirty bit is set for required
     * parameter validation to work
     */
    @Override
    public void setValue(String input) throws IllegalValueException {
        boundValue = true;
    }
    
    public T getValue() {
        return value;
    }
    
    @Override
    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public Argument<T> description(String description) {
        this.description = description;
        return this;
    }

    public String getFlag() {
        return flag;
    }
    
    public Argument<T> flag(String flag) {
        this.flag = flag.trim().toLowerCase();
        
        if (!this.flag.equals(flag)) {
            logger.warning("Flag argument has uppercase or whitespace characters. These have been ignored.");
        }
        
        return this;
    }

    public boolean isOptional() {
        return optional;
    }
    
    public boolean hasBoundValue() {
        return boundValue;
    }
    
    /**
     * Sets the field as required
     */
    public Argument<T> required() {
        this.optional = false;
        return this;
    }
    
    /**
     * Sets the field as required and specify an error message to show if it is not provided
     * @param errorMessage shown to the user when the parameter is not provided 
     */
    public Argument<T> required(String errorMessage) {
        requiredErrorMessage = errorMessage;
        this.optional = false;
        return this;
    }
    
    @Override
    public boolean isPositional() {
        return flag == null;
    }
    
    @Override
    public void checkRequired() throws IllegalValueException {
        if (!isOptional() && !hasBoundValue()) {
            String error = requiredErrorMessage == null ? 
                    String.format(Argument.REQUIRED_ERROR_FORMAT, name) : requiredErrorMessage;
            throw new IllegalValueException(error);
        }
    }

    /**
     * Throws an IllegalValueException for a type mismatch between user input and what 
     * the argument expect 
     * @param field     name of the argument 
     * @param expected  the expected type for the argument 
     * @param actual    what the user actually gave 
     */
    protected void typeError(String field, String expected, String actual) throws IllegalValueException {
        throw new IllegalValueException(String.format(Argument.TYPE_ERROR_FORMAT, field, expected, actual));
    }
    
    @Override
    public String toString() {
        return toString(name);
    }
    
    public String toString(String name) {
        if (!isPositional()) {
            name = String.format(FLAG_ARGUMENT_FORMAT, TodoParser.FLAG_TOKEN, flag, name);
        }

        if (isOptional()) {
            name = String.format(OPTIONAL_ARGUMENT_FORMAT, name);
        }

        return name;
    }
}
```
###### \src\main\java\seedu\todo\logic\arguments\DateRange.java
``` java
/**
 * Utility container class for the output from DateRangeArgument
 */
public class DateRange {
    private final LocalDateTime endTime; 
    private LocalDateTime startTime;
    
    public DateRange(LocalDateTime endTime) {
        this.endTime = endTime;
    }
    
    public DateRange(LocalDateTime startTime, LocalDateTime endTime) {
        this(endTime);
        this.startTime = startTime;
    }

    public LocalDateTime getEndTime() {
        return endTime;
    }

    public LocalDateTime getStartTime() {
        return startTime;
    }
    
    public boolean isRange() {
        return startTime != null;
    }
}
```
###### \src\main\java\seedu\todo\logic\arguments\DateRangeArgument.java
``` java
public class DateRangeArgument extends Argument<DateRange> {
    private static final PrettyTimeParser parser = new PrettyTimeParser();
    private static final TimeUtil timeUtil = new TimeUtil();
    
    // TODO: Review all error messages to check for user friendliness 
    private static final String TOO_MANY_DATES_FORMAT = "You specified too many time - we found: %s";
    private static final String NO_DATE_FOUND_FORMAT = "%s does not seem to contain a date";
    
    public DateRangeArgument(String name) {
        // Makes sure that there is a default value, so that callers won't get null when they getValue()
        super(name, new DateRange(null));
    }

    public DateRangeArgument(String name, DateRange defaultValue) {
        super(name, defaultValue);
    }
    
    @Override
    public void setValue(String input) throws IllegalValueException {
        super.setValue(input);
        
        if (StringUtil.isEmpty(input)) {
            return;
        }
        
        input = TimeUtil.toAmericanDateFormat(input);
        List<Date> dateGroups = parser.parse(input);
        
        List<LocalDateTime> dates = dateGroups.stream()
            .map(TimeUtil::asLocalDateTime)
            .sorted()
            .collect(Collectors.toList());

        if (dates.size() > 2) {
            tooManyDatesError(dates);
        } else if (dates.size() == 0) {
            throw new IllegalValueException(String.format(DateRangeArgument.NO_DATE_FOUND_FORMAT, input));
        }
        
        if (dates.size() == 1) {
            value = new DateRange(dates.get(0));
        } else {
            value = new DateRange(dates.get(0), dates.get(1));
        }
    }
    
    private void tooManyDatesError(List<LocalDateTime> dates) throws IllegalValueException {
        StringJoiner sj = new StringJoiner(", ");
        for (LocalDateTime d : dates) {
            sj.add(timeUtil.getTaskDeadlineText(d));
        }
        String message = String.format(DateRangeArgument.TOO_MANY_DATES_FORMAT, sj.toString());
        throw new IllegalValueException(message);
    }
    
}
```
###### \src\main\java\seedu\todo\logic\arguments\FlagArgument.java
``` java
public class FlagArgument extends Argument<Boolean> {

    public FlagArgument(String name) {
        super(name);
        flag(name.substring(0, 1).toLowerCase());
        this.value = false;
    }

    public FlagArgument(String name, boolean defaultValue) {
        super(name, defaultValue);
        flag(name.substring(0, 1).toLowerCase());
    }

    @Override
    public void setValue(String input) throws IllegalValueException {
        this.value = true;
        super.setValue(input);
    }
    
    @Override
    public String toString(String name) {
        String flag = TodoParser.FLAG_TOKEN + getFlag();
        return isOptional() ? String.format(Argument.OPTIONAL_ARGUMENT_FORMAT, flag) : flag;
    }
}
```
###### \src\main\java\seedu\todo\logic\arguments\IntArgument.java
``` java
public class IntArgument extends Argument<Integer> {

    public IntArgument(String name) {
        super(name);
    }
    
    public IntArgument(String name, int defaultValue) {
        super(name, defaultValue);
    }

    @Override
    public void setValue(String input) throws IllegalValueException {
        try {
            value = Integer.parseInt(input);
            super.setValue(input);
        } catch (NumberFormatException e) {
            typeError(this.getName(), "integer", input);
        }
    }

}
```
###### \src\main\java\seedu\todo\logic\arguments\Parameter.java
``` java
/**
 * Represents a single command parameter that the parser will try to feed the user 
 * input into. The Parameter interface is needed because the Argument base class is 
 * typed, so this interface contains all of the non-typed methods that are common to 
 * all argument subclasses
 */
public interface Parameter {
    void setValue(String input) throws IllegalValueException;
    
    boolean isPositional();
    
    boolean hasBoundValue();
    
    boolean isOptional();
    
    String getFlag();
    
    String getName();
    
    String getDescription();
    
    void checkRequired() throws IllegalValueException;
}
```
###### \src\main\java\seedu\todo\logic\arguments\StringArgument.java
``` java
public class StringArgument extends Argument<String> {

    public StringArgument(String name) {
        super(name);
    }
    
    public StringArgument(String name, String defaultValue) {
        super(name, defaultValue);
    }

    @Override
    public void setValue(String input) throws IllegalValueException {
        input = input.trim();
        
        // Ignore empty strings
        if (input.length() > 0) {
            this.value = input;
        }
        
        super.setValue(input);
    }

}
```
###### \src\main\java\seedu\todo\logic\commands\AddCommand.java
``` java
public class AddCommand extends BaseCommand {
    private static final String VERB = "added";
    
    private Argument<String> title = new StringArgument("title").required();
    
    private Argument<String> description = new StringArgument("description")
            .flag("m");
    
    private Argument<Boolean> pin = new FlagArgument("pin")
            .flag("p");
    
    private Argument<String> location = new StringArgument("location")
            .flag("l");
    
    private Argument<DateRange> date = new DateRangeArgument("deadline")
            .flag("d");

    @Override
    public Parameter[] getArguments() {
        return new Parameter[] {
            title, date, description, location, pin,
        };
    }

    @Override
    public String getCommandName() {
        return "add";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        String eventArguments = Joiner.on(" ").join(title, "/d start and end time", description, location, pin);
        
        return ImmutableList.of(
            new CommandSummary("Add task", getCommandName(), getArgumentSummary()), 
            new CommandSummary("Add event", getCommandName(), eventArguments));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        ImmutableTask addedTask = this.model.add(title.getValue(), task -> {
            task.setDescription(description.getValue());
            task.setPinned(pin.getValue());
            task.setLocation(location.getValue());
            task.setStartTime(date.getValue().getStartTime());
            task.setEndTime(date.getValue().getEndTime());
        });
        if(!model.getObservableList().contains(addedTask)) {
            model.view(TaskViewFilter.DEFAULT);
        }
        eventBus.post(new HighlightTaskEvent(addedTask));
        eventBus.post(new ExpandCollapseTaskEvent(addedTask));
        return taskSuccessfulResult(title.getValue(), AddCommand.VERB);
    }

}
```
###### \src\main\java\seedu\todo\logic\commands\BaseCommand.java
``` java
/**
 * The base class for commands. All commands need to implement an execute function 
 * and a getArguments function that collects the command arguments for the use of 
 * the help command. 
 * 
 * To perform additional validation on incoming arguments, override the validateArguments 
 * function.
 */
public abstract class BaseCommand {
    /**
     * The default message that accompanies argument errors
     */
    private static final String DEFAULT_ARGUMENT_ERROR_MESSAGE = ""; 
    
    private static final String TASK_MODIFIED_SUCCESS_MESSAGE = "'%s' successfully %s!";
    
    protected static final EventsCenter eventBus = EventsCenter.getInstance();

    protected Model model;
    
    protected ErrorBag errors = new ErrorBag(); 
    
    abstract protected Parameter[] getArguments();

    /**
     * Return the name of the command, which is used to call it
     */
    abstract public String getCommandName();

    /**
     * Returns a list of command summaries for the command. This function returns a 
     * list because commands may (rarely) be responsible for more than one thing, 
     * like the <code>add</code> command. 
     */
    abstract public List<CommandSummary> getCommandSummary();
    
    abstract public CommandResult execute() throws ValidationException;
    
    /**
     * Binds the data model to the command object
     */
    public void setModel(Model model) {
        this.model = model;
    }

    /**
     * Binds the both positional and named command arguments from the parse results 
     * to the command object itself 
     * 
     * @throws ValidationException if the arguments are invalid
     */
    public void setArguments(ParseResult arguments) throws ValidationException {
        if (arguments.getPositionalArgument().isPresent()) {
            setPositionalArgument(arguments.getPositionalArgument().get());
        }
        
        for (Entry<String, String> e : arguments.getNamedArguments().entrySet()) {
            setNameArgument(e.getKey(), e.getValue());
        }
        
        checkRequiredArguments();
        validateArguments();
        
        errors.validate(getArgumentErrorMessage());
    }
    
    /**
     * Hook allowing subclasses to implement their own validation logic for arguments
     * Subclasses should add additional errors to the errors ErrorBag
     */
    protected void validateArguments() {
        // Does no additional validation by default 
    }
    
    protected void setPositionalArgument(String argument) {
        for (Parameter p : getArguments()) {
            if (p.isPositional()) {
                try {
                    p.setValue(argument);
                } catch (IllegalValueException e) {
                    errors.put(e.getMessage());
                }
            }
        }
    }
    
    protected void setNameArgument(String flag, String argument) {
        for (Parameter p : getArguments()) {
            if (flag.equals(p.getFlag())) {
                try {
                    p.setValue(argument);
                } catch (IllegalValueException e) {
                    errors.put(p.getName(), e.getMessage());
                }
                
                return;
            }
        }
        
        // TODO: Do something for unrecognized argument?
    }
    
    private void checkRequiredArguments() {
        for (Parameter p : getArguments()) {
            try {
                p.checkRequired();
            } catch (IllegalValueException e) {
                errors.put(p.getName(), e.getMessage());
            }
        }
    }

    /**
     * Override this function if the command should return some other error 
     * message on argument validation error 
     */
    protected String getArgumentErrorMessage() {
        return BaseCommand.DEFAULT_ARGUMENT_ERROR_MESSAGE;
    }

    /**
     * Returns a generic CommandResult with a "{task} successfully {verbed}" success message. 
     * 
     * @param title the title of the task that was verbed on 
     * @param verb the action that was performed on the task, in past tense
     */
    protected CommandResult taskSuccessfulResult(String title, String verb) {
        return new CommandResult(String.format(BaseCommand.TASK_MODIFIED_SUCCESS_MESSAGE, title, verb));
    }

    /**
     * Turns the arguments into a string summary using their toString function
     */
    protected String getArgumentSummary() {
        StringJoiner sj = new StringJoiner(" ");
        for (Parameter p : getArguments()) {
            sj.add(p.toString());
        }
        return sj.toString();
    }
}
```
###### \src\main\java\seedu\todo\logic\commands\CommandMap.java
``` java
public class CommandMap {
    // List of command classes. Remember to register new commands here so that the
    // dispatcher can recognize them
    public static List<Class<? extends BaseCommand>> commandClasses = ImmutableList.of(
        AddCommand.class,
        CompleteCommand.class,
        DeleteCommand.class,
        EditCommand.class,
        ExitCommand.class,
        HelpCommand.class,
        PinCommand.class,
        UndoCommand.class,
        RedoCommand.class,
        SaveCommand.class,
        LoadCommand.class,
        ShowCommand.class,
        FindCommand.class,
        ViewCommand.class,
        TagCommand.class
    );
    
    private static Map<String, Class<? extends BaseCommand>> commandMap;
    
    private static void buildCommandMap() {
        commandMap = new LinkedHashMap<>();
        
        for (Class<? extends BaseCommand> command : CommandMap.commandClasses) {
            String commandName = getCommand(command).getCommandName().toLowerCase();
            commandMap.put(commandName, command);
        }
    }

    public static Map<String, Class<? extends BaseCommand>> getCommandMap() {
        if (commandMap == null) {
            buildCommandMap();
        }
        
        return commandMap;
    }
    
    public static BaseCommand getCommand(String key) {
        return getCommand(getCommandMap().get(key));
    }
    
    public static BaseCommand getCommand(Class<? extends BaseCommand> command) {
        try {
            return command.newInstance();
        } catch (InstantiationException|IllegalAccessException e) {
            e.printStackTrace();
            return null; // This shouldn't happen
        }
    }
}
```
###### \src\main\java\seedu\todo\logic\commands\CommandResult.java
``` java
/**
 * Represents the result of a command execution.
 */
public class CommandResult {
    private final String feedback;
    private final ErrorBag errors; 
    
    public CommandResult() {
        this.feedback = "";
        this.errors = null;
    }
    
    public CommandResult(String feedback) {
        this.feedback = feedback;
        this.errors = null;
    }
    
    public CommandResult(String feedback, ErrorBag errors) {
        this.feedback = feedback;
        this.errors = errors;
    }

    public String getFeedback() {
        return feedback;
    }

    public ErrorBag getErrors() {
        return errors;
    }
    
    public boolean isSuccessful() {
        return errors == null;
    }
}
```
###### \src\main\java\seedu\todo\logic\commands\CommandSummary.java
``` java
public class CommandSummary {
    /**
     * The scenario the summary is aiming to describe, eg. add event, delete task, etc. 
     * Keep it short but descriptive. 
     */
    public final String scenario;

    /**
     * The command to accomplish the scenario, eg. add, delete 
     */
    public final String command;

    /**
     * The parameters for the command
     */
    public final String arguments;
    
    public CommandSummary(String scenario, String command) {
        this(scenario, command, "");
    }
    
    public CommandSummary(String scenario, String command, String arguments) {
        this.scenario = scenario.trim();
        this.command = command.toLowerCase().trim();
        this.arguments = arguments.trim();
    }
}
```
###### \src\main\java\seedu\todo\logic\commands\DeleteCommand.java
``` java
public class DeleteCommand extends BaseCommand {
    private static final String VERB = "deleted";
    
    private Argument<Integer> index = new IntArgument("index").required();

    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{ index };
    }

    @Override
    public String getCommandName() {
        return "delete";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Delete task", getCommandName(), 
            getArgumentSummary()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        ImmutableTask deletedTask = this.model.delete(index.getValue());
        return taskSuccessfulResult(deletedTask.getTitle(), DeleteCommand.VERB);
    }
}
```
###### \src\main\java\seedu\todo\logic\commands\ExitCommand.java
``` java
/**
 * Terminates the program.
 */
public class ExitCommand extends BaseCommand {
    private final static String EXIT_MESSAGE = "Goodbye!";
    
    @Override
    public CommandResult execute() throws ValidationException {
        EventsCenter.getInstance().post(new ExitAppRequestEvent());
        return new CommandResult(ExitCommand.EXIT_MESSAGE);
    }

    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{};
    }

    @Override
    public String getCommandName() {
        return "exit";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Close this app :(", getCommandName()));
    }

}
```
###### \src\main\java\seedu\todo\logic\commands\HelpCommand.java
``` java
/**
 * Shows the help panel
 */
public class HelpCommand extends BaseCommand {
    private final static String HELP_MESSAGE = "Showing help...";
    
    private static List<CommandSummary> commandSummaries;

    @Override
    public CommandResult execute() throws ValidationException {
        if (commandSummaries == null) {
            commandSummaries = collectCommandSummaries();
        }
        
        EventsCenter.getInstance().post(new ShowHelpEvent(commandSummaries));
        return new CommandResult(HelpCommand.HELP_MESSAGE);
    }

    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{};
    }

    @Override
    public String getCommandName() {
        return "help";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Show help", getCommandName()));
    }
    
    private List<CommandSummary> collectCommandSummaries() {
        List<CommandSummary> summaries = new ArrayList<>();
        for (String key : CommandMap.getCommandMap().keySet()) {
            summaries.addAll(CommandMap.getCommand(key).getCommandSummary());
        }
        return summaries;
    }
}
```
###### \src\main\java\seedu\todo\logic\commands\LoadCommand.java
``` java
public class LoadCommand extends BaseCommand {
    private Argument<String> location = new StringArgument("location").required();
    
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{ location };
    }

    @Override
    public String getCommandName() {
        return "load";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Load todo list from file", getCommandName(), 
            getArgumentSummary()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        String path = location.getValue();
        model.load(path);
        return new CommandResult(String.format("File loaded from %s", path));
    }
}
```
###### \src\main\java\seedu\todo\logic\commands\RedoCommand.java
``` java
public class RedoCommand extends BaseCommand {
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[0];
    }

    @Override
    public String getCommandName() {
        return "redo";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Redo", getCommandName()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        model.redo();
        return new CommandResult("Redid last action");
    }
}
```
###### \src\main\java\seedu\todo\logic\commands\SaveCommand.java
``` java
/**
 * Saves the save file to a different location 
 */
public class SaveCommand extends BaseCommand {
    private Argument<String> location = new StringArgument("location");
    
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{ location };
    }

    @Override
    public String getCommandName() {
        return "save";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(
            new CommandSummary("Save to a different file", getCommandName(), "location"), 
            new CommandSummary("Find my todo list file", getCommandName()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        if (location.hasBoundValue()) {
            model.save(location.getValue());
            
            return new CommandResult(String.format("Todo list saved successfully to %s", location));
        } else {
            return new CommandResult(String.format("Save location: %s", model.getStorageLocation()));
        }
    }
}
```
###### \src\main\java\seedu\todo\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends BaseCommand {
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[0];
    }

    @Override
    public String getCommandName() {
        return "undo";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Undo last edit", getCommandName()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        model.undo();
        return new CommandResult("Undid last action");
    }
}
```
###### \src\main\java\seedu\todo\logic\Dispatcher.java
``` java
public interface Dispatcher {
    BaseCommand dispatch(String command) throws IllegalValueException;
}
```
###### \src\main\java\seedu\todo\logic\Logic.java
``` java
/**
 * API of the Logic component
 */
public interface Logic {
    /**
     * Executes the command and returns the result.
     * @param input The command as entered by the user.
     */
    CommandResult execute(String input);

```
###### \src\main\java\seedu\todo\logic\parser\Parser.java
``` java
public interface Parser {
    ParseResult parse(String input);
}
```
###### \src\main\java\seedu\todo\logic\parser\ParseResult.java
``` java
public interface ParseResult {

    String getCommand();

    Optional<String> getPositionalArgument();

    Map<String, String> getNamedArguments();

}
```
###### \src\main\java\seedu\todo\logic\parser\TodoParser.java
``` java
/**
 * Parses a input string into the command, positional argument and named arguments. 
 * The format looks like: 
 * 
 * <pre><code>command positional [-f or --flag named]...</code></pre>
 * 
 * There will only be one command, optionally one positional argument, and 
 * optionally many named arguments. 
 */
public class TodoParser implements Parser {
    public static String FLAG_TOKEN = "/";

    private List<String> tokenize(String input) {
        input = input.trim();
        
        return Lists.newArrayList(Splitter
            .on(" ")
            .trimResults()
            .omitEmptyStrings()
            .split(input));
    }
    
    private String parseFlag(String token) {
        return token.substring(1, token.length());
    }
    
    private boolean isFlag(String token) {
        return token.startsWith(TodoParser.FLAG_TOKEN) && token.length() > 1;
    }
    
    @Override
    public ParseResult parse(String input) {
        List<String> tokens = tokenize(input);
        Map<String, String> named = new HashMap<>();
        
        // Pull out the command, exit if there's no more things to parse
        String command = tokens.remove(0).toLowerCase();
        
        // Parse out positional argument
        StringJoiner sj = new StringJoiner(" ");
        while (!tokens.isEmpty() && !isFlag(tokens.get(0))) {
            sj.add(tokens.remove(0));
        }
        String positional = sj.toString();
        
        // If there are no more tokens return immediately
        if (tokens.isEmpty()) {
            return new TodoResult(command, positional, named);
        }
        
        // Parse out named arguments
        String flag = tokens.remove(0);
        sj = new StringJoiner(" ");
        while (!tokens.isEmpty()) {
            if (isFlag(tokens.get(0))) {
                named.put(parseFlag(flag), sj.toString());
                flag = tokens.remove(0);
                sj = new StringJoiner(" ");
            } else {
                sj.add(tokens.remove(0));
            }
        }
        named.put(parseFlag(flag), sj.toString());
        
        return new TodoResult(command, positional, named);
    }

    private class TodoResult implements ParseResult {
        private final String command;
        private final String positional;
        private final Map<String, String> named;

        public TodoResult(String command, String positional, Map<String, String> named) {
            this.command = command;
            this.positional = positional.length() > 0 ? positional : null;
            this.named = named;
        }

        @Override
        public String getCommand() {
            return command;
        }

        @Override
        public Optional<String> getPositionalArgument() {
            return Optional.ofNullable(positional);
        }

        @Override
        public Map<String, String> getNamedArguments() {
            return named;
        }

        @Override
        public String toString() {
            StringJoiner sj = new StringJoiner(" ");
            sj.add(command).add(getPositionalArgument().orElse(""));
            for (Entry<String, String> e : getNamedArguments().entrySet()) {
                sj.add(TodoParser.FLAG_TOKEN + e.getKey()).add(e.getValue());
            }
            return sj.toString();
        }
    }
}
```
###### \src\main\java\seedu\todo\logic\TodoDispatcher.java
``` java
/**
 * Selects the correct command based on the parser results
 */
public class TodoDispatcher implements Dispatcher {
    private final static String COMMAND_NOT_FOUND_FORMAT = "'%s' doesn't look like any command we know.";
    private final static String AMBIGUOUS_COMMAND_FORMAT = "Do you mean %s?";
    
    public BaseCommand dispatch(String input) throws IllegalValueException {
        // Implements character by character matching of input to the list of command names
        // Since this eliminates non-matches at every character, it is fast even though 
        // it is theoretically O(n^2) in the worst case.
        Set<String> commands = new HashSet<>(CommandMap.getCommandMap().keySet());
        
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);

            Iterator<String> s = commands.iterator();
            while (s.hasNext()) {
                String commandName = s.next();
                if (input.length() > commandName.length() || commandName.charAt(i) != c) {
                    s.remove();
                }
            }
            
            // Return immediately when there's one match left. This allow the user to 
            // type as little as possible, and is also good for autocomplete if that's 
            // on the radar
            if (commands.size() == 1) {
                String key = commands.iterator().next();
                return CommandMap.getCommand(key);
            } else if (commands.isEmpty()) {
                throw new IllegalValueException(String.format(TodoDispatcher.COMMAND_NOT_FOUND_FORMAT, input));
            }
        }
        
        String ambiguousCommands = Joiner.on(" or ").join(commands);
        throw new IllegalValueException(String.format(TodoDispatcher.AMBIGUOUS_COMMAND_FORMAT, ambiguousCommands));
    }
}
```
###### \src\main\java\seedu\todo\logic\TodoLogic.java
``` java
/**
 * Central controller for the application, abstracting application logic from the UI
 */
public class TodoLogic implements Logic {
    private final Parser parser;
    private final Model model;
    private final Dispatcher dispatcher;
    
    private static final Logger logger = LogsCenter.getLogger(TodoLogic.class);
    
    public TodoLogic(Parser parser, Model model, Dispatcher dispatcher) {
        assert parser != null;
        assert model != null;
        assert dispatcher != null;
        
        this.parser = parser;
        this.model = model;
        this.dispatcher = dispatcher;
    }
    
    public CommandResult execute(String input) {
        // Sanity check - input should not be empty 
        if (StringUtil.isEmpty(input)) {
            return new CommandResult();
        }
        
        ParseResult parseResult = parser.parse(input);
        BaseCommand command;
        logger.fine("Parsed command: " + parseResult.toString());
        
        try {
            command = dispatcher.dispatch(parseResult.getCommand());
        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage(), new ErrorBag());
        }
        
        try {
            command.setArguments(parseResult);
            command.setModel(model);
            return command.execute();
        } catch (ValidationException e) {
            logger.info(e.getMessage());
            return new CommandResult(e.getMessage(), e.getErrors());
        }
    }

```
###### \src\main\java\seedu\todo\model\ErrorBag.java
``` java
public class ErrorBag {
    private List<String> nonFieldErrors = new ArrayList<>();
    private Map<String, String> fieldErrors = new HashMap<>();
    
    /**
     * Add an error that is not related to any specific field
     * 
     * @param nonFieldError the error message
     */
    public void put(String nonFieldError) {
        nonFieldErrors.add(nonFieldError);
    }
    
    /**
     * Add an error that is related to a specific field 
     * 
     * @param field the error is for
     * @param error the error message 
     */
    public void put(String field, String error) {
        fieldErrors.put(field, error);
    }
    
    public List<String> getNonFieldErrors() {
        return nonFieldErrors;
    }
    
    public Map<String, String> getFieldErrors() {
        return fieldErrors;
    }
    
    public int size() {
        return nonFieldErrors.size() + fieldErrors.size();
    }
    
    /**
     * Throws a validation exception if the bag contains errors 
     * 
     * @param message a short message about why the validation failed
     * @throws ValidationException if the ErrorBag is not empty
     */
    public void validate(String message) throws ValidationException {
        if (size() > 0) {
            throw new ValidationException(message, this);
        }
    }
}
```
###### \src\main\java\seedu\todo\model\ImmutableTodoList.java
``` java
public interface ImmutableTodoList {
    /**
     * Get an immutable list of tasks 
     */
    List<ImmutableTask> getTasks();
}
```
###### \src\main\java\seedu\todo\model\Model.java
``` java
public interface Model {
    /**
     * Adds a new task or event with title only to the todo list.
     *
     * @param title  the title of the task
     * @return the task that was just created 
     * @throws IllegalValueException if the values set in the update predicate is invalid
     */
    ImmutableTask add(String title) throws IllegalValueException;

    /**
     * Adds a new task or event with title and other fields to the todo list.
     *
     * @param title   the title of the task 
     * @param update  a {@link MutableTask} is passed into this lambda. All other fields 
     *                should be set from inside this lambda. 
     * @return the task that was just created
     * @throws ValidationException   if the fields in the task to be updated are not valid
     */
    ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException;

    /**
     * Deletes the given task from the todo list. This change is also propagated to the 
     * underlying persistence layer.  
     *
     * @param index  the 1-indexed position of the task that needs to be deleted
     * @return the task that was just deleted
     * @throws ValidationException if the task does not exist
     */
    ImmutableTask delete(int index) throws ValidationException;

    /**
     * Replaces certain fields in the task. Mutation of the {@link Task} object should 
     * only be done in the <code>update</code> lambda. The lambda takes in one parameter, 
     * a {@link MutableTask}, and does not expect any return value. For example: 
     *
     * <pre><code>todo.update(task, t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline back by 2h
     *     t.setPin(true); // Pin this task
     * });</code></pre>
     *
     * @return the task that was just updated
     *
     * @throws ValidationException    if the task does not exist or if the fields in the 
     *                                task to be updated are not valid
     */
    ImmutableTask update(int index, Consumer<MutableTask> update) throws ValidationException;
    
    /**
     * Carries out the specified update in the fields of all visible tasks. Mutation of all {@link Task}
     * objects should only be done in the <code>update</code> lambda. The lambda takes in a single parameter,
     * a {@link MutableTask}, and does not expect any return value, as per the {@link update} command. Since
     * this represents the observable layer, the changes required to be done to the underlying layer TodoList
     * is set via getting a list of their indices in the underlying layer using a UUID map.  
     * 
     * <pre><code>todo.updateAll (t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline of all Observable tasks back by 2h
     *     t.setPin(true); // Pin all tasks in Observable view
     * });</code></pre>
     * 
     * @throws ValidationException if any updates on any of the task objects are considered invalid
     */
    void updateAll(Consumer <MutableTask> update) throws ValidationException;

    /**
     * Sets the model to the provided TaskViewFilter object. TaskViewFilters represents the
     * filter and sorting needed by each intelligent view
     */
    void view(TaskViewFilter view);

    /**
     * Filters the list of tasks by this predicate. This is filtering is ran
     * after the view predicate. No information about the search is shown to the user.
     * Setting predicate to null will reset the search.
     */
    void find(Predicate<ImmutableTask> predicate);

    /**
     * Filters the list of tasks by this predicate. This is filtering is ran
     * after the view predicate. A list of search terms is also shown to the user.
     */
    void find(Predicate<ImmutableTask> predicate, List<String> terms);

    /**
     * Undoes the last operation that modifies the todolist
     * @throws ValidationException if there are no more changes to undo
     */
    void undo() throws ValidationException;

    /**
     * Redoes the last operation that was undone
     * @throws ValidationException if there are no more changes to redo
     */
    void redo() throws ValidationException;
    
    /**
     * Changes the save path of the TodoList storage 
     * @throws ValidationException if the path is not valid
     */
    void save(String location) throws ValidationException;

    /**
     * Loads a TodoList from the path. 
     * @throws ValidationException if the path or file is invalid
     */
    void load(String location) throws ValidationException;

    /**
     * Obtains the current storage methods 
     */
    String getStorageLocation();

    /**
     * Get an observable list of tasks. Used mainly by the JavaFX UI. 
     */
    UnmodifiableObservableList<ImmutableTask> getObservableList();

    /**
     * Get the current view filter used on the model. Used mainly by the JavaFx UI. 
     */
    ObjectProperty<TaskViewFilter> getViewFilter();

    /**
     * Get the current status of the search used on the model.
     */
    ObjectProperty<SearchStatus> getSearchStatus();

```
###### \src\main\java\seedu\todo\model\task\BaseTask.java
``` java
public abstract class BaseTask implements ImmutableTask {
    protected UUID uuid = UUID.randomUUID();

    @Override
    public UUID getUUID() {
        return uuid;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof ImmutableTask)) {
            return false;
        }

        return getUUID().equals(((ImmutableTask) o).getUUID());
    }

    @Override
    public int hashCode() {
        return getUUID().hashCode();
    }

    @Override
    public String toString() {
        return getTitle();
    }
}
```
###### \src\main\java\seedu\todo\model\task\Task.java
``` java
/**
 * Represents a single task
 */
public class Task extends BaseTask implements MutableTask {
    private StringProperty title = new SimpleStringProperty();
    private StringProperty description = new SimpleStringProperty();
    private StringProperty location = new SimpleStringProperty();

    private BooleanProperty pinned = new SimpleBooleanProperty();
    private BooleanProperty completed = new SimpleBooleanProperty();

    private ObjectProperty<LocalDateTime> startTime = new SimpleObjectProperty<>();
    private ObjectProperty<LocalDateTime> endTime = new SimpleObjectProperty<>();

    private ObjectProperty<Set<Tag>> tags = new SimpleObjectProperty<>(new HashSet<Tag>());
    private LocalDateTime createdAt = LocalDateTime.now();

    /**
     * Creates a new task
     */
    public Task(String title) {
        this.setTitle(title);
    }

    /**
     * Constructs a Task from a ReadOnlyTask
     */
    public Task(ImmutableTask task) {
        this.setTitle(task.getTitle());
        this.setDescription(task.getDescription().orElse(null));
        this.setLocation(task.getLocation().orElse(null));
        this.setStartTime(task.getStartTime().orElse(null));
        this.setEndTime(task.getEndTime().orElse(null));
        this.setCompleted(task.isCompleted());
        this.setPinned(task.isPinned());
        this.setCreatedAt(task.getCreatedAt());
        this.uuid = task.getUUID();
        this.setTags(task.getTags());
    }

    @Override
    public String getTitle() {
        return title.get();
    }

    @Override
    public Optional<String> getDescription() {
        return Optional.ofNullable(description.get());
    }

    @Override
    public Optional<String> getLocation() {
        return Optional.ofNullable(location.get());
    }

    @Override
    public Optional<LocalDateTime> getStartTime() {
        return Optional.ofNullable(startTime.get());
    }

    @Override
    public Optional<LocalDateTime> getEndTime() {
        return Optional.ofNullable(endTime.get());
    }

    @Override
    public boolean isPinned() {
        return pinned.get();
    }

    @Override
    public boolean isCompleted() {
        return completed.get();
    }

    @Override
    public Set<Tag> getTags() {
        return Collections.unmodifiableSet(tags.get());
    }
    
    @Override
    public LocalDateTime getCreatedAt() { return createdAt; }

    @Override
    public void setTitle(String title) {
        this.title.set(title);
    }

    @Override
    public void setPinned(boolean pinned) {
        this.pinned.set(pinned);
    }

    @Override
    public void setCompleted(boolean completed) {
        this.completed.set(completed);
    }

    @Override
    public void setDescription(String description) {
        this.description.set(description);
    }

    @Override
    public void setLocation(String location) {
        this.location.set(location);
    }

    @Override
    public void setStartTime(LocalDateTime startTime) {
        this.startTime.set(startTime);
    }

    @Override
    public void setEndTime(LocalDateTime endTime) {
        this.endTime.set(endTime);
    }

    @Override
    public void setTags(Set<Tag> tags) {
        this.tags.set(tags);
    }
    
    public void setCreatedAt(LocalDateTime createdAt) {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        
        this.createdAt = createdAt;
    }

    public Observable[] getObservableProperties() {
        return new Observable[] {
            title, description, location, startTime, endTime, tags, completed, pinned,
        };
    }
}
```
###### \src\main\java\seedu\todo\model\TodoList.java
``` java
/**
 * Represents the todolist inside memory. While Model works as the external 
 * interface for handling data and application state, this class is internal 
 * to Model and represents only CRUD operations to the todolist. 
 */
public class TodoList implements TodoListModel {
    private static final String INCORRECT_FILE_FORMAT_FORMAT = "%s doesn't seem to be in the correct format.";
    private static final String FILE_NOT_FOUND_FORMAT = "%s does not seem to exist.";
    private static final String FILE_SAVE_ERROR_FORMAT = "Couldn't save file: %s";

    private ObservableList<Task> tasks = FXCollections.observableArrayList(Task::getObservableProperties);

    private MovableStorage<ImmutableTodoList> storage;

    private static final Logger logger = LogsCenter.getLogger(TodoList.class);
    private static final EventsCenter events = EventsCenter.getInstance();

    public TodoList(MovableStorage<ImmutableTodoList> storage) {
        this.storage = storage;
        
        try {
            setTasks(storage.read().getTasks(), false);
        } catch (FileNotFoundException | DataConversionException e) {
            logger.info("Data file not found. Will be starting with an empty TodoList");
        }
        
        // Update event status 
        new Timer().scheduleAtFixedRate(new UpdateEventTask(), 0, 60 * 1000);
    }
    
    private void updateEventStatus() {
        LocalDateTime now = LocalDateTime.now();
        boolean todoListModified = false;
        
        for (Task task : tasks) {
            boolean isIncompleteEvent = !task.isCompleted() && task.isEvent();
            if (isIncompleteEvent && now.isAfter(task.getEndTime().get())) {
                task.setCompleted(true);
                todoListModified = true;
            }
        }
        if (todoListModified) {
            saveTodoList();
        }
    }

    private void raiseStorageEvent(String message, Exception e) {
        // TODO: Have this raise an event
    }
    
    private void saveTodoList() {
        try {
            storage.save(this);
        } catch (IOException e) {
            events.post(new DataSavingExceptionEvent(e));
        }
    }

    @Override
    public ImmutableTask add(String title) {
        Task task = new Task(title);
        tasks.add(task);
        
        saveTodoList();
        return task;
    }

    @Override
    public ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException {
        ValidationTask validationTask = new ValidationTask(title);
        update.accept(validationTask);
        Task task = validationTask.convertToTask();
        tasks.add(task);

        saveTodoList();
        return task;
    }

    @Override
    public ImmutableTask delete(int index) throws ValidationException {
        Task task = tasks.remove(index);
        saveTodoList();
        return task;
    }

    @Override
    public ImmutableTask update(int index, Consumer<MutableTask> update) throws ValidationException {
        Task task = tasks.get(index);
        ValidationTask validationTask = new ValidationTask(task);
        update.accept(validationTask);
        validationTask.validate();

        // changes are validated and accepted
        update.accept(task);
        saveTodoList();
        return task;
    }

```
###### \src\main\java\seedu\todo\model\TodoListModel.java
``` java
public interface TodoListModel extends ImmutableTodoList {
    /**
     * Adds a new task or event with title only to the todo list.
     *
     * @param title  the title of the task
     * @return the task that was just created 
     * @throws IllegalValueException if the values set in the update predicate is invalid
     */
    ImmutableTask add(String title) throws IllegalValueException;

    /**
     * Adds a new task or event with title and other fields to the todo list.
     *
     * @param title   the title of the task 
     * @param update  a {@link MutableTask} is passed into this lambda. All other fields 
     *                should be set from inside this lambda. 
     * @return the task that was just created
     * @throws ValidationException   if the fields in the task to be updated are not valid
     */
    ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException;

    /**
     * Deletes the given task from the todo list. This change is also propagated to the 
     * underlying persistence layer.  
     *
     * @param index  the 1-indexed position of the task that needs to be deleted
     * @return the task that was just deleted
     * @throws ValidationException if the task does not exist
     */
    ImmutableTask delete(int index) throws ValidationException;

    /**
     * Replaces certain fields in the task. Mutation of the {@link Task} object should 
     * only be done in the <code>update</code> lambda. The lambda takes in one parameter, 
     * a {@link MutableTask}, and does not expect any return value. For example: 
     *
     * <pre><code>todo.update(task, t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline back by 2h
     *     t.setPin(true); // Pin this task
     * });</code></pre>
     *
     * @return the task that was just updated
     *
     * @throws ValidationException    if the task does not exist or if the fields in the 
     *                                task to be updated are not valid
     */
    ImmutableTask update(int index, Consumer<MutableTask> update) throws ValidationException;
    
```
###### \src\main\java\seedu\todo\model\TodoListModel.java
``` java
    /**
     * Changes the save path of the TodoList storage 
     * @throws ValidationException if the path is not valid
     */
    void save(String location) throws ValidationException;

    /**
     * Loads a TodoList from the path. 
     * @throws ValidationException if the path or file is invalid
     */
    void load(String location) throws ValidationException;

    /**
     * Replaces the tasks in list with the one in the 
     */
    void setTasks(List<ImmutableTask> todoList);

    /**
     * Get an observable list of tasks. Used mainly by the JavaFX UI. 
     */
    ObservableList<ImmutableTask> getObservableList();

}

```
###### \src\main\java\seedu\todo\model\TodoModel.java
``` java
/**
 * Represents the data layer of the application. The TodoModel handles any 
 * interaction with the application state that are not persisted, such as the
 * view (sort and filtering), undo and redo. Since this layer handles 
 * sorting and filtering, task ID must be passed through {@link #getTaskIndex}
 * to transform them into the index {@link TodoList} methods can use. 
 */
public class TodoModel implements Model {
    // Constants 
    private static final int UNDO_LIMIT = 10;
    private static final String INDEX_OUT_OF_BOUND_FORMAT = "There is no task no. %d";
    private static final String NO_MORE_UNDO_REDO_FORMAT = "There are no more steps to %s";
    
    // Dependencies
    private TodoListModel todoList;
    private UniqueTagCollectionModel uniqueTagCollection = new UniqueTagCollection();
    private MovableStorage<ImmutableTodoList> storage;
    
    // Stack of transformation that the tasks go through before being displayed to the user
    private ObservableList<ImmutableTask> tasks;
    private FilteredList<ImmutableTask> viewFilteredTasks;
    private FilteredList<ImmutableTask> findFilteredTasks;
    private SortedList<ImmutableTask> sortedTasks;
    
    // State stacks for managing un/redo
    private Deque<List<ImmutableTask>> undoStack = new ArrayDeque<>();
    private Deque<List<ImmutableTask>> redoStack = new ArrayDeque<>();

    /**
     * Contains the current view tab the user has selected. 
     * {@link #getViewFilter()} is the getter and {@link #view(TaskViewFilter)} is the setter
     */
    private ObjectProperty<TaskViewFilter> view = new SimpleObjectProperty<>();
    
    private ObjectProperty<SearchStatus> search = new SimpleObjectProperty<>();

    public TodoModel(Config config) {
        this(new TodoListStorage(config.getTodoListFilePath()));
    }
    
    public TodoModel(MovableStorage<ImmutableTodoList> storage) {
        this(new TodoList(storage), storage);
    }
    
    public TodoModel(TodoListModel todoList, MovableStorage<ImmutableTodoList> storage) {
        this.storage = storage;
        this.todoList = todoList;

        tasks = todoList.getObservableList();
        viewFilteredTasks = new FilteredList<>(tasks);
        findFilteredTasks = new FilteredList<>(viewFilteredTasks);
        sortedTasks = new SortedList<>(findFilteredTasks);
        
        // Sets the default view 
        view(TaskViewFilter.DEFAULT);
    }

    /**
     * Because the model does filtering and sorting on the tasks, the incoming index needs to be 
     * translated into it's index in the underlying todoList. The code below is not particularly
     * clean, but it works well enough. 
     * 
     * @throws ValidationException if the index is invalid
     */
    private int getTaskIndex(int index) throws ValidationException {
        int taskIndex;

        try {
            ImmutableTask task = getObservableList().get(index - 1);
            taskIndex = tasks.indexOf(task);
        } catch (IndexOutOfBoundsException e) {
            taskIndex = -1;
        }

        if (taskIndex == -1) {
            String message = String.format(TodoModel.INDEX_OUT_OF_BOUND_FORMAT, index);
            throw new ValidationException(message);
        }

        return taskIndex;
    }
    
    private void saveState(Deque<List<ImmutableTask>> stack) {
        List<ImmutableTask> tasks = todoList.getTasks().stream()
            .map(Task::new).collect(Collectors.toList());
        
        stack.addFirst(tasks);
        while (stack.size() > TodoModel.UNDO_LIMIT) {
            stack.removeLast();
        }
    }

    private void saveUndoState() {
        saveState(undoStack);
        redoStack.clear();
    }
    
    @Override
    public ImmutableTask add(String title) throws IllegalValueException {
        saveUndoState();
        return todoList.add(title);
    }

    @Override
    public ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException {
        saveUndoState();
        return todoList.add(title, update);
    }

    @Override
    public ImmutableTask delete(int index) throws ValidationException {
        saveUndoState();
        ImmutableTask taskToDelete = getObservableList().get(getTaskIndex(index));
        uniqueTagCollection.notifyTaskDeleted(taskToDelete);
        return todoList.delete(getTaskIndex(index));
    }

    @Override
    public ImmutableTask update(int index, Consumer<MutableTask> update) throws ValidationException {
        saveUndoState();
        return todoList.update(getTaskIndex(index), update);
    }

```
###### \src\main\java\seedu\todo\model\TodoModel.java
``` java
    @Override
    public void view(TaskViewFilter view) {
        viewFilteredTasks.setPredicate(view.filter);

        sortedTasks.setComparator((a, b) -> {
            int pin = Boolean.compare(b.isPinned(), a.isPinned());
            return pin != 0 || view.sort == null ? pin : view.sort.compare(a, b);
        });
        
        this.view.setValue(view);
    }
    
    @Override
    public void find(Predicate<ImmutableTask> predicate) {
        findFilteredTasks.setPredicate(predicate);
        search.setValue(null);
    }

    @Override
    public void find(Predicate<ImmutableTask> predicate, List<String> terms) {
        findFilteredTasks.setPredicate(predicate);
        search.setValue(new SearchStatus(terms, findFilteredTasks.size(), tasks.size()));
    }

    @Override
    public void undo() throws ValidationException {
        if (undoStack.isEmpty()) {
            String message = String.format(TodoModel.NO_MORE_UNDO_REDO_FORMAT, "undo");
            throw new ValidationException(message);
        }
        
        List<ImmutableTask> tasks = undoStack.removeFirst();
        uniqueTagCollection.update(todoList.getObservableList());
        saveState(redoStack);
        todoList.setTasks(tasks);
    }

    @Override
    public void redo() throws ValidationException {
        if (redoStack.isEmpty()) {
            String message = String.format(TodoModel.NO_MORE_UNDO_REDO_FORMAT, "redo");
            throw new ValidationException(message);
        }

        List<ImmutableTask> tasks = redoStack.removeFirst();
        uniqueTagCollection.update(todoList.getObservableList());
        saveState(undoStack);
        todoList.setTasks(tasks);
    }

    @Override
    public void save(String location) throws ValidationException {
        todoList.save(location);
    }

    @Override
    public void load(String location) throws ValidationException {
        todoList.load(location);
        uniqueTagCollection.update(todoList.getObservableList());
    }

    @Override
    public String getStorageLocation() {
        return storage.getLocation();
    }

    @Override
    public UnmodifiableObservableList<ImmutableTask> getObservableList() {
        return new UnmodifiableObservableList<>(sortedTasks);
    }

    @Override
    public ObjectProperty<TaskViewFilter> getViewFilter() {
        return view;
    }

    @Override
    public ObjectProperty<SearchStatus> getSearchStatus() {
        return search;
    }

```
###### \src\main\java\seedu\todo\storage\FixedStorage.java
``` java
/**
 * Represents a storage mechanism to save an object to a fixed location
 * @param <T>
 */
public interface FixedStorage<T> {
    /**
     * Reads the object from storage 
     * @return the object read from storage 
     * @throws DataConversionException if the data read was not of the expected type 
     * @throws FileNotFoundException if there was no file  
     */
    T read() throws DataConversionException, FileNotFoundException;

    /**
     * Persists an object 
     * @param object the object that needs to be persisted 
     * @throws IOException if there was any problem saving the object to storage
     */
    void save(T object) throws IOException;
}
```
###### \src\main\java\seedu\todo\storage\MovableStorage.java
``` java
/**
 * Represents an storage mechanism that allows an object to be saved to a 
 * specific location
 */
public interface MovableStorage<T> extends FixedStorage<T> {
    
    String getLocation(); 
    
    T read(String location) throws DataConversionException, FileNotFoundException;
    
    void save(T object, String newLocation) throws IOException;
}
```
###### \src\main\java\seedu\todo\ui\controller\TextAreaResizer.java
``` java
/**
 * Automatically resize a text area object such that the height fits the content of the text area
 */
public class TextAreaResizer {
    // Constants
    private static final int CHAR_AHEAD = 3; 
    private static final int PADDING_OFFSET = 5;
    
    // FXML elements
    private final TextArea textArea;
    private final Text pseudoText = new Text();
    
    // Internal variables
    private double lineHeight;
    private double charWidth;
    private double textAreaWidth;
    private int textAreaChars;
    
    public TextAreaResizer(TextArea textArea) {
        this.textArea = textArea;
        textAreaChars = textArea.getText().length();
        textAreaWidth = textArea.getWidth();
        
        pseudoText.fontProperty().addListener((observable, oldValue, newValue) -> updateCharacterWidth());
        pseudoText.fontProperty().bind(textArea.fontProperty());
        
        textArea.widthProperty().addListener((observable, oldValue, newValue) -> {
            textAreaWidth = (double) newValue - PADDING_OFFSET;
            updateTextArea();
        });
        
        textArea.textProperty().addListener((observable, oldValue, newValue) -> {
            textAreaChars = newValue.length();
            updateTextArea();
        });
    }

    private void updateCharacterWidth() {
        final int TEST_CHAR_LEN = 60;

        pseudoText.setText("");
        double initialWidth = pseudoText.getLayoutBounds().getWidth();
        pseudoText.setText(Strings.repeat("w", TEST_CHAR_LEN));
        double newWidth = pseudoText.getLayoutBounds().getWidth();
        charWidth = (newWidth - initialWidth) / TEST_CHAR_LEN;
    }
    
    private void updateTextArea() {
        // Silly hack to make sure lineHeight is available before continuing 
        if (lineHeight <= 0) {
            if ((lineHeight = textArea.getLayoutBounds().getHeight() - PADDING_OFFSET) <= 0) {
                return;
            }
        }
        
        int lines = (int) (((textAreaChars + CHAR_AHEAD) * charWidth) / textAreaWidth) + 1;
        double height = lines * lineHeight + PADDING_OFFSET;
        
        Platform.runLater(() -> {
            textArea.setMaxHeight(height);
            textArea.setPrefHeight(height);
        });
    }
}
```
###### \src\main\resources\style\DefaultStyle.css
``` css
.searchStatus {
    -fx-padding: 4px;
}

.searchStatus Text {
    -fx-font-size: 14px;
    -fx-fill: #fff;
}

.searchStatus .searchLabel {
}

.searchStatus .searchTerm {
    -fx-font-weight: bold;
}

.searchStatus .searchCount {
    -fx-text-alignment: right;
}

```
###### \src\test\java\seedu\todo\logic\arguments\ArgumentTest.java
``` java
public class ArgumentTest {
    private Argument<String> arg = new TestArgument();

    @Test
    public void testRequiredErrorMessage() {
        arg.required("Hello world");
        
        try {
            arg.checkRequired();
        } catch (IllegalValueException e) {
            assertEquals("Hello world", e.getMessage());
        }
    }
    
    @Test(expected=IllegalValueException.class)
    public void testRequired() throws IllegalValueException {
        arg.required(); 
        arg.checkRequired();
    }
    
    @Test
    public void testIsOptional() {
        assertTrue(arg.isOptional());
        arg.required();
        assertFalse(arg.isOptional());
    }
    
    @Test
    public void testIsPositional() {
        assertTrue(arg.isPositional());
        arg.flag("t");
        assertFalse(arg.isPositional());
    }
    
    @Test
    public void testFlag() {
        assertNull(arg.getFlag());
        arg.flag("h");
        assertEquals("h", arg.getFlag());
        arg.flag(" H   ");
        assertEquals("h", arg.getFlag());
    }
    
    @Test
    public void testDescription() {
        assertNull(arg.getDescription());
        arg.description("Hello World");
        assertEquals("Hello World", arg.getDescription());
    }
    
    @Test
    public void testToString() {
        assertEquals("[Test]", arg.toString());
        assertEquals("[Something]", arg.toString("Something"));
        
        arg.flag("t");
        assertEquals("[/t Test]", arg.toString());
        assertEquals("[/t Something]", arg.toString("Something"));
        
        arg.required(); 
        assertEquals("/t Test", arg.toString());
        assertEquals("/t Something", arg.toString("Something"));
    }
    
    private class TestArgument extends Argument<String> {
        public TestArgument() {
            super("Test");
        }
    }
}
```
###### \src\test\java\seedu\todo\logic\arguments\DateRangeArgumentTest.java
``` java
public class DateRangeArgumentTest {
    private final Argument<DateRange> arg = new DateRangeArgument("Test");
    private final LocalDateTime tomorrow = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(0, 0));
    
    @Test
    public void testDefaultValue() throws Exception {
        assertNull(arg.getValue().getStartTime());
        assertNull(arg.getValue().getEndTime());
        assertFalse(arg.hasBoundValue());
    }
    
    @Test
    public void testEmptyInput() throws Exception {
        arg.setValue("");
        assertNull(arg.getValue().getStartTime());
        assertNull(arg.getValue().getEndTime());
        assertTrue(arg.hasBoundValue());
    }

    @Test
    public void testInternationalDate() throws Exception {
        arg.setValue("6/12/16");
        assertEquals(LocalDate.of(2016, 12, 6), arg.getValue().getEndTime().toLocalDate());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testIsoDate() throws Exception {
        arg.setValue("06-12-2016");
        assertEquals(LocalDate.of(2016, 12, 6), arg.getValue().getEndTime().toLocalDate());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testInternationalDateTime() throws Exception {
        arg.setValue("6/12/16 12:45pm");
        assertEquals(LocalDateTime.of(2016, 12, 6, 12, 45), arg.getValue().getEndTime());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testNaturalLanguageDateTime() throws Exception {
        arg.setValue("12 Oct 2014 6pm");
        assertEquals(LocalDateTime.of(2014, 10, 12, 18, 0), arg.getValue().getEndTime());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testRelativeDate() throws Exception {
        arg.setValue("tomorrow");
        assertEquals(tomorrow.toLocalDate(), arg.getValue().getEndTime().toLocalDate());
        assertFalse(arg.getValue().isRange());
    }

    @Test
    public void testRelativeDateTime() throws Exception {
        arg.setValue("tomorrow 6pm");
        assertEquals(tomorrow.withHour(18), arg.getValue().getEndTime());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testRelativeDateRange() throws Exception {
        arg.setValue("tomorrow 6 to 8pm");
        assertEquals(tomorrow.withHour(20), arg.getValue().getEndTime());
        assertEquals(tomorrow.withHour(18), arg.getValue().getStartTime());
    }
    
    @Test
    public void testFormalDateTimeRange() throws Exception {
        arg.setValue("18-12-16 1800hrs to 2000hrs");
        LocalDateTime date = LocalDateTime.of(2016, 12, 18, 0, 0);
        assertEquals(date.withHour(20), arg.getValue().getEndTime());
        assertEquals(date.withHour(18), arg.getValue().getStartTime());

        arg.setValue("18-12-16 1800hrs to 19-12-16 2000hrs");
        assertEquals(LocalDateTime.of(2016, 12, 18, 18, 0), arg.getValue().getStartTime());
        assertEquals(LocalDateTime.of(2016, 12, 19, 20, 0), arg.getValue().getEndTime());
    }
    
    @Test(expected=IllegalValueException.class)
    public void testNoDate() throws Exception {
        arg.setValue("no date here");
    }
    
    @Test(expected=IllegalValueException.class)
    public void testTooManyDates() throws Exception {
        arg.setValue("yesterday, today, tomorrow");
    }

}
```
###### \src\test\java\seedu\todo\logic\arguments\DateRangeTest.java
``` java
public class DateRangeTest {

    @Test
    public void testDateRangeLocalDateTime() {
        LocalDateTime start = LocalDateTime.now();
        DateRange range = new DateRange(start);
        assertNull(range.getStartTime());
        assertFalse(range.isRange());
    }

    @Test
    public void testDateRangeLocalDateTimeLocalDateTime() {
        LocalDateTime start = LocalDateTime.now();
        LocalDateTime end = start.plusHours(2);
        DateRange range = new DateRange(start, end);
        
        assertTrue(range.isRange());
    }

}
```
###### \src\test\java\seedu\todo\logic\arguments\FlagArgumentTest.java
``` java
public class FlagArgumentTest {
    
    private Argument<Boolean> argument;

    @Before
    public void setUp() throws Exception {
        argument = new FlagArgument("test");
    }

    @Test
    public void testDefaultValue() {
        assertEquals("t", argument.getFlag());
        assertFalse(argument.getValue());
        
        argument = new FlagArgument("Pin", true);
        assertTrue(argument.getValue());
        assertEquals("p", argument.getFlag());
    }
    
    @Test
    public void testSetEmptyValue() throws IllegalValueException {
        argument.setValue("");
        assertTrue(argument.getValue());
    }

    @Test
    public void testSetStringValue() throws IllegalValueException {
        argument.setValue("Hello World");
        assertTrue(argument.getValue());
    }
    
    @Test
    public void testToString() {
        argument.flag("t");
        assertEquals("[/t]", argument.toString());
        
        argument.required();
        assertEquals("/t", argument.toString());
    }

}
```
###### \src\test\java\seedu\todo\logic\arguments\IntArgumentTest.java
``` java
public class IntArgumentTest {
    private Argument<Integer> argument;
    
    private int setInput(String input) throws IllegalValueException {
        argument.setValue(input);
        return argument.getValue();
    }
    
    @Before
    public void setUp() {
        argument = new IntArgument("test");
    }

    @Test
    public void testParse() throws IllegalValueException {
        assertEquals(123, setInput("123"));
        assertEquals(-345, setInput("-345"));
    }
    
    @Test(expected=IllegalValueException.class)
    public void testFloatArgument() throws IllegalValueException {
        setInput("12.34");
    }
    
    @Test(expected=IllegalValueException.class)
    public void testStringArgument() throws IllegalValueException {
        setInput("random stuff");
    }
}
```
###### \src\test\java\seedu\todo\logic\arguments\StringArgumentTest.java
``` java
public class StringArgumentTest {
    
    private Argument<String> arg = new StringArgument("test");

    @Test
    public void testSetValue() throws IllegalValueException {
        arg.setValue("Hello world");
        assertTrue(arg.hasBoundValue());
        assertEquals("Hello world", arg.getValue());
    }
    
    @Test
    public void testTrimValue() throws IllegalValueException {
        arg.setValue("  Hello world ");
        assertTrue(arg.hasBoundValue());
        assertEquals("Hello world", arg.getValue());
    }
    
    @Test
    public void testEmptyValue() throws IllegalValueException {
        arg.setValue("  ");
        assertTrue(arg.hasBoundValue());
        assertEquals(arg.getValue(), null);
    }
}
```
###### \src\test\java\seedu\todo\logic\commands\BaseCommandTest.java
``` java
public class BaseCommandTest extends CommandTest {
    private Argument<String> requiredArgument = mock(StringArgument.class);
    private Argument<Boolean> flagArgument = mock(FlagArgument.class);
    private Argument<Integer> intArgument = mock(IntArgument.class);
    private Argument<String> stringArgument = mock(StringArgument.class);
    
    private StubCommand stubCommand;

    @Override
    protected BaseCommand commandUnderTest() {
        stubCommand = new StubCommand();
        return stubCommand;
    }
    
    @Before
    public void setUp() throws Exception {
        when(requiredArgument.isPositional()).thenReturn(true);
        when(requiredArgument.toString()).thenReturn("required");
        
        when(flagArgument.isOptional()).thenReturn(true);
        when(flagArgument.getFlag()).thenReturn("f");
        when(flagArgument.toString()).thenReturn("flag");
        
        when(intArgument.isOptional()).thenReturn(true);
        when(intArgument.getFlag()).thenReturn("i");
        when(intArgument.toString()).thenReturn("int");
        
        when(stringArgument.isOptional()).thenReturn(true);
        when(stringArgument.getFlag()).thenReturn("s");
        when(stringArgument.toString()).thenReturn("string");
    }
    
    @Test
    public void testSetParameter() throws Exception {
        this.setParameter("required")
            .setParameter("f", "")
            .setParameter("i", "20")
            .setParameter("s", "Hello World");
        
        execute(true);
        
        verify(requiredArgument).setValue("required");
        verify(flagArgument).setValue("");
        verify(intArgument).setValue("20");
        verify(stringArgument).setValue("Hello World");
    }
    
    @Test
    public void testCustomArgumentError() throws Exception {
        command = new CommandWithOverrideMethods();
        
        try {
            execute(false);
            fail();
        } catch (ValidationException e) {
            assertEquals("Test error message", e.getMessage());
            assertTrue(e.getErrors().getNonFieldErrors().contains("Test error"));
        }
    }
    
    @Test
    public void getArgumentSummary() {
        assertEquals("required flag int string", stubCommand.getArgumentSummaryResult());
    }

    @Test(expected=ValidationException.class)
    public void testMissingRequiredArgument() throws Exception {
        IllegalValueException e = mock(IllegalValueException.class);
        doThrow(e).when(requiredArgument).checkRequired();
        
        execute(false);
    }

    private class StubCommand extends BaseCommand {
        @Override
        protected Parameter[] getArguments() {
            return new Parameter[]{ requiredArgument, flagArgument, intArgument, stringArgument };
        }

        @Override
        public String getCommandName() {
            return "stub";
        }

        @Override
        public List<CommandSummary> getCommandSummary() {
            return ImmutableList.of(mock(CommandSummary.class));
        }

        @Override
        public CommandResult execute() throws ValidationException {
            // Does nothing
            return new CommandResult("Great Success!");
        }
        
        public String getArgumentSummaryResult() {
            return getArgumentSummary();
        }
    }
    
    private class CommandWithOverrideMethods extends StubCommand {
        @Override
        protected String getArgumentErrorMessage() {
            return "Test error message";
        }

        @Override
        protected void validateArguments() {
            errors.put("Test error");
        }
    }
}
```
###### \src\test\java\seedu\todo\logic\commands\CommandSummaryTest.java
``` java
public class CommandSummaryTest {
    @Test
    public void testConstructor() {
        CommandSummary summary = new CommandSummary(" Hello  ", "World");
        // Check trim 
        assertEquals("Hello", summary.scenario);
        // Check command is lowercase 
        assertEquals("world", summary.command);
        // Check constructor without third argument
        assertEquals("", summary.arguments);
    }
}
```
###### \src\test\java\seedu\todo\logic\commands\CommandTest.java
``` java
/**
 * Base test case for testing commands. All command tests should extend this class. 
 * Provides a simple interface for setting up command testing as well as a number 
 * of assertions to inspect the model. 
 */
public abstract class CommandTest {
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    protected Model model;
    protected TodoList todolist;
    @Mock protected MovableStorage<ImmutableTodoList> storage;
    @Mock protected ImmutableTodoList storageData;
    protected BaseCommand command;
    protected StubParseResult params;
    protected CommandResult result;
    
    abstract protected BaseCommand commandUnderTest();

    @Before
    public void setUpCommand() throws Exception {
        when(storage.read()).thenReturn(storageData);
        when(storageData.getTasks()).thenReturn(Collections.emptyList());
        
        todolist = new TodoList(storage);
        model = new TodoModel(todolist, storage);
        params = new StubParseResult();
        command = commandUnderTest();
    }
    
    /**
     * Returns the task visible in the model at 1-indexed position, mimicking user input
     */
    protected ImmutableTask getTaskAt(int index) {
        return model.getObservableList().get(index - 1);
    }
    
    /**
     * Asserts that the model has this number of tasks stored in internal storage (visible and not visible)
     */
    
    protected void assertTotalTaskCount(int size) {
        assertEquals(size, todolist.getTasks().size());
    }
    
    /**
     * Asserts that the model has this number of tasks visible
     */
    protected void assertVisibleTaskCount(int size) {
        assertEquals(size, model.getObservableList().size());
    }
    
    /**
     * Asserts that the task exists in memory
     */
    protected void assertTaskExist(ImmutableTask task) {
        if (!todolist.getTasks().contains(task)) {
            throw new AssertionError("Task not found in model");
        }
    }
    

    /**
     * Asserts that the task does not exist in memory
     */
    protected void assertTaskNotExist(ImmutableTask task) {
        if (todolist.getTasks().contains(task)) {
            throw new AssertionError("Task found in model");
        }
    }
    
    /**
     * Asserts that the task is visible to the user through the model
     */
    protected void assertTaskVisible(ImmutableTask task) {
        if (!model.getObservableList().contains(task)) {
            throw new AssertionError("Task is not visible");
        }
    }

    /**
     * Asserts that the task is visible to the user through the model. 
     * This can also mean the task is simply not in memory. Use {@link #assertTaskHidden}
     * to assert that the task exists, but is not visible
     */
    protected void assertTaskNotVisible(ImmutableTask task) {
        if (model.getObservableList().contains(task)) {
            throw new AssertionError("Task is visible");
        }
    }
    
    /**
     * Asserts that the task exists, but is not visible to the user through 
     * the model
     */
    protected void assertTaskHidden(ImmutableTask task) {
        assertTaskExist(task); 
        assertTaskNotVisible(task);
    }

    /**
     * Sets the positional parameter for command execution. Can be chained. 
     */
    protected CommandTest setParameter(String positional) {
        params.positional = positional;
        return this;
    }
    
    /**
     * Sets the named argument for command execution. Can be chained. 
     */
    protected CommandTest setParameter(String flag, String value) {
        params.named.put(flag, value);
        return this;
    }
    
    @Test
    public void testCommonProperties() {
        assertNotNull(command.getArguments());
        assertThat(command.getCommandName(), not(containsString(" ")));
        assertThat(command.getCommandSummary().size(), greaterThan(0));
    }
    
    /**
     * Executes the command
     */
    protected void execute(boolean expectSuccess) throws ValidationException {
        command.setArguments(params);
        command.setModel(model);
        result = command.execute();
        
        assertEquals(expectSuccess, result.isSuccessful());
        
        // Resets the command object for re-execution
        command = commandUnderTest();
        params = new StubParseResult();
    }

    private class StubParseResult implements ParseResult {
        public String command;
        public String positional;
        public Map<String, String> named = new HashMap<>();

        @Override
        public String getCommand() {
            return command;
        }

        @Override
        public Optional<String> getPositionalArgument() {
            return Optional.ofNullable(positional);
        }

        @Override
        public Map<String, String> getNamedArguments() {
            return named;
        }
    }
}
```
###### \src\test\java\seedu\todo\logic\commands\ExitCommandTest.java
``` java
public class ExitCommandTest extends CommandTest {
    @Override
    protected BaseCommand commandUnderTest() {
        return new ExitCommand();
    }
    
    @Test
    public void testExecute() throws IllegalValueException, ValidationException {
        EventsCollector eventCollector = new EventsCollector();
        execute(true);
        assertThat(eventCollector.get(0), instanceOf(ExitAppRequestEvent.class));
    }

}
```
###### \src\test\java\seedu\todo\logic\commands\FindCommandTest.java
``` java
    @Test
    public void testFindWithFilter() throws ValidationException {
        TaskViewFilter filter = new TaskViewFilter("test", t -> t.getTitle().contains("CS2101"), null);
        model.view(filter);
        
        setParameter("Task");
        execute(true);
        assertVisibleTaskCount(1);
    }

    @Test
    public void testDismissFind() throws ValidationException {
        setParameter("project");
        execute(true);
        assertVisibleTaskCount(2);
        assertNotNull(model.getSearchStatus().getValue());

        setParameter("");
        execute(true);
        assertVisibleTaskCount(4);
        assertNull(model.getSearchStatus().getValue());
    }
}
```
###### \src\test\java\seedu\todo\logic\commands\HelpCommandTest.java
``` java
public class HelpCommandTest extends CommandTest {
    @Override
    protected BaseCommand commandUnderTest() {
        return new HelpCommand();
    }
    
    @Test
    public void testExecute() throws Exception {
        EventsCollector eventsCollector = new EventsCollector();
        execute(true);
        assertThat(eventsCollector.get(0), instanceOf(ShowHelpEvent.class));
    }

}
```
###### \src\test\java\seedu\todo\logic\commands\LoadCommandTest.java
``` java
/**
 * This is an integration test for the {@code load} command. For tests on the 
 * load functionality itself, see {@link seedu.todo.storage.TodoListStorageTest}
 */
public class LoadCommandTest extends CommandTest {
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();
    
    @Mock private ImmutableTodoList tasks;
    
    @Override
    protected BaseCommand commandUnderTest() {
        return new LoadCommand();
    }
    
    @Test
    public void testSaveLocation() throws Exception {
        setParameter("new file");
        when(storage.read("new file")).thenReturn(tasks);
        when(tasks.getTasks()).thenReturn(ImmutableList.of(new Task("Hello world")));
            
        execute(true);
        assertEquals("Hello world", getTaskAt(1).getTitle());
    }

    @Test(expected = ValidationException.class)
    public void testHandleFileError() throws Exception {
        setParameter("new file");
        doThrow(new FileNotFoundException()).when(storage).read("new file");
        execute(false);
    }

}
```
###### \src\test\java\seedu\todo\logic\commands\RedoCommandTest.java
``` java
public class RedoCommandTest extends CommandTest {
    @Override
    protected BaseCommand commandUnderTest() {
        return new RedoCommand();
    }
    
    /**
     * This is an integration test for the redo command. For a more detailed test on the model itself 
     * {@link seedu.todo.model.TodoModelTest#testRedo} and other related tests 
     */
    @Test
    public void testExecute() throws Exception {
        model.add("Test task");
        model.undo();
        execute(true);
        assertEquals("Test task", getTaskAt(1).getTitle());
    }
    
    @Test(expected = ValidationException.class)
    public void testIncorrectExecute() throws Exception {
        execute(false);
    }
}
```
###### \src\test\java\seedu\todo\logic\commands\SaveCommandTest.java
``` java
public class SaveCommandTest extends CommandTest {
    @Test
    public void testGetStorageLocation() throws Exception {
        when(storage.getLocation()).thenReturn("test location");
        execute(true);
        
        assertThat(result.getFeedback(), containsString("test location"));
        verify(storage, never()).save(eq(todolist), anyString());
    }
    
    @Test
    public void testSaveLocation() throws Exception {
        setParameter("new file");
        execute(true);
        verify(storage).save(todolist, "new file");
    }
    
    @Test(expected = ValidationException.class)
    public void testHandleFileError() throws Exception {
        setParameter("new file");
        doThrow(new IOException()).when(storage).save(todolist, "new file");
        execute(false);
    }
    
    @Override
    protected BaseCommand commandUnderTest() {
        return new SaveCommand();
    }
}
```
###### \src\test\java\seedu\todo\logic\commands\UndoCommandTest.java
``` java
public class UndoCommandTest extends CommandTest {

    @Override
    protected BaseCommand commandUnderTest() {
        return new UndoCommand();
    }

    /**
     * This is an integration test for the redo command. For a more detailed test on the model itself 
     * {@link TodoModelTest#testUndo} and other related tests 
     */
    @Test
    public void testUndo() throws Exception {
        model.add("Test task");
        execute(true);
    }
    
    @Test(expected = ValidationException.class)
    public void testEmptyUndo() throws Exception {
        execute(false);
    }
}
```
###### \src\test\java\seedu\todo\logic\parser\TodoParserTest.java
``` java
public class TodoParserTest {
    private Parser parser = new TodoParser();
    
    @Test
    public void testParse() {
        ParseResult p;
        
        p = parser.parse("hello");
        assertEquals("hello", p.getCommand());
        
        p = parser.parse("HeLLo");
        assertEquals("hello", p.getCommand());
        
        p = parser.parse("HELLO");
        assertEquals("hello", p.getCommand());
        
        p = parser.parse("hello world");
        assertEquals("hello", p.getCommand());
        
        p = parser.parse("  hello ");
        assertEquals("hello", p.getCommand());
    }
    
    @Test
    public void testPositionalArgument() {
        ParseResult p;
        
        p = parser.parse("hello world");
        assertEquals("world", p.getPositionalArgument().get());
        
        p = parser.parse("hello one two three");
        assertEquals("one two three", p.getPositionalArgument().get());
        
        p = parser.parse("hello   one   two  three  ");
        assertEquals("one two three", p.getPositionalArgument().get());
    }
    
    @Test
    public void testNamedArguments() {
        ParseResult p;
        
        p = parser.parse("hello /f");
        assertEquals(1, p.getNamedArguments().size());
        assertTrue(p.getNamedArguments().containsKey("f"));
        
        p = parser.parse("hello /f Hello");
        assertEquals(1, p.getNamedArguments().size());
        assertEquals("Hello", p.getNamedArguments().get("f"));
        
        p = parser.parse("hello  /f   Hello ");
        assertEquals(1, p.getNamedArguments().size());
        assertEquals("Hello", p.getNamedArguments().get("f"));
        
        p = parser.parse("hello /all Hello");
        assertEquals(1, p.getNamedArguments().size());
        assertEquals("Hello", p.getNamedArguments().get("all"));
        
        p = parser.parse("hello /f Hello /p /all");
        assertEquals(3, p.getNamedArguments().size());
        assertEquals("Hello", p.getNamedArguments().get("f"));
        assertTrue(p.getNamedArguments().containsKey("p"));
        assertTrue(p.getNamedArguments().containsKey("all"));
    }
    
    @Test
    public void testInvalidFlags() {
        ParseResult p;
        
        p = parser.parse("hello /");
        assertTrue(p.getPositionalArgument().isPresent());
        assertEquals(0, p.getNamedArguments().size());
    }

}
```
###### \src\test\java\seedu\todo\logic\TodoDispatcherTest.java
``` java
public class TodoDispatcherTest {
    private Dispatcher d = new TodoDispatcher();
    
    @Test
    public void testFullCommand() throws Exception {
        assertThat(d.dispatch("add"), instanceOf(AddCommand.class));
        assertThat(d.dispatch("exit"), instanceOf(ExitCommand.class));
    }
    
    @Test
    public void testPartialCommand() throws Exception {
        assertThat(d.dispatch("ed"), instanceOf(EditCommand.class));
        assertThat(d.dispatch("a"), instanceOf(AddCommand.class));
    }
    
    @Test(expected = IllegalValueException.class)
    public void testAmbiguousCommand() throws Exception {
        d.dispatch("e");
    }
    
    @Test(expected = IllegalValueException.class)
    public void testNonExistentCommand() throws Exception {
        d.dispatch("applejack");
    }
}
```
###### \src\test\java\seedu\todo\logic\TodoLogicTest.java
``` java
public class TodoLogicTest {
    private static final String INPUT = "input";
    private static final String COMMAND = "command";

    @Rule
    public MockitoRule rule = MockitoJUnit.rule();
    
    @Mock private Parser parser; 
    @Mock private Dispatcher dispatcher;
    @Mock private ParseResult parseResult;
    @Mock private Model model;
    @Mock private BaseCommand command;
    
    private Logic logic;

    @Before
    public void setUp() throws Exception {
        // Wire up some default behavior 
        when(parser.parse(TodoLogicTest.INPUT))
            .thenReturn(parseResult);
        when(parseResult.getCommand())
            .thenReturn(TodoLogicTest.COMMAND);
        when(dispatcher.dispatch(TodoLogicTest.COMMAND))
            .thenReturn(command);

        logic = new TodoLogic(parser, model, dispatcher);
    }
    
    private CommandResult execute() throws Exception {
        CommandResult r = logic.execute(TodoLogicTest.INPUT);

        verify(parser).parse(TodoLogicTest.INPUT);
        verify(dispatcher).dispatch(TodoLogicTest.COMMAND);
        
        return r;
    }
    
    @Test
    public void testExecute() throws Exception {
        execute();
        
        verify(command).setModel(model);
        verify(command).setArguments(parseResult);
        verify(command).execute();
        
        // Logic should not touch model directly 
        verifyZeroInteractions(model);
    }
    
    @Test
    public void testArgumentError() throws Exception {
        // Create a stub exception for setArguments to throw
        ValidationException e = mock(ValidationException.class);
        ErrorBag errors = mock(ErrorBag.class);
        
        when(e.getErrors()).thenReturn(errors);
        doThrow(e).when(command).setArguments(parseResult);
        
        CommandResult r = execute();
        
        assertFalse(r.isSuccessful());
        // Make sure the command is never executed 
        verify(command, never()).execute();
    }
    
    @Test
    public void testExecuteError() throws Exception {
        // Create a stub exception for execute to throw
        ValidationException e = mock(ValidationException.class);
        ErrorBag errors = mock(ErrorBag.class);

        when(e.getErrors()).thenReturn(errors);
        doThrow(e).when(command).execute();

        CommandResult r = execute();
        
        assertFalse(r.isSuccessful());
        assertEquals(errors, r.getErrors());
    }
    
    @Test
    public void testDispatchError() throws Exception {
        // Create a stub exception for execute to throw
        IllegalValueException e = mock(IllegalValueException.class);
        when(e.getMessage()).thenReturn("Test message");
        doThrow(e).when(dispatcher).dispatch(TodoLogicTest.COMMAND);

        CommandResult r = execute();

        assertFalse(r.isSuccessful());
        assertEquals("Test message", r.getFeedback());
    }
    
    @Test
    public void testEmptyInput() throws Exception {
        CommandResult r = logic.execute("");
        
        assertNotNull(r);
        assertNotNull(r.getFeedback());
        verifyZeroInteractions(parser);
    }
}
```
###### \src\test\java\seedu\todo\model\ErrorBagTest.java
``` java
public class ErrorBagTest {
    
    private ErrorBag errorBag = new ErrorBag();

    @Test
    public void testPutString() {
        errorBag.put("Hello World");
        errorBag.put("Another error");
        
        assertEquals(0, errorBag.getNonFieldErrors().indexOf("Hello World"));
        assertEquals(1, errorBag.getNonFieldErrors().indexOf("Another error"));
        
        assertEquals(2, errorBag.size());
        assertEquals(0, errorBag.getFieldErrors().size());
    }

    @Test
    public void testPutStringString() {
        errorBag.put("a", "Hello World");
        errorBag.put("b", "Another error");
        
        assertEquals("Hello World", errorBag.getFieldErrors().get("a"));
        assertEquals("Another error", errorBag.getFieldErrors().get("b"));
        
        assertEquals(2, errorBag.size());
        assertEquals(0, errorBag.getNonFieldErrors().size());
    }

    @Test
    public void testSize() {
        errorBag.put("Hello World");
        errorBag.put("a", "Hello World");
        
        assertEquals(2, errorBag.size());
    }

    @Test
    public void testValidateNoErrors() throws ValidationException {
        assertEquals(0, errorBag.size());
        errorBag.validate("Validation message");
    }
    

    @Test(expected=ValidationException.class)
    public void testValidateWithErrors() throws ValidationException {
        errorBag.put("Hello World");
        errorBag.put("a", "Hello World");
        
        errorBag.validate("Validation message");
    }
    
    @Test
    public void testValidationException() {
        errorBag.put("Hello World");
        errorBag.put("a", "Hello World");
        
        try {
            errorBag.validate("Validation message");
        } catch (ValidationException e) {
            assertEquals(errorBag, e.getErrors());
            assertEquals("Validation message", e.getMessage());
        }
        
    }

}
```
###### \src\test\java\seedu\todo\model\property\TaskViewFilterTest.java
``` java
public class TaskViewFilterTest {
    @Test
    public void testNoOverlappingShortcut() {
        Set<Character> shortcuts = new HashSet<>();
        
        for (TaskViewFilter filter : TaskViewFilter.all()) {
            char shortcut = filter.name.charAt(filter.shortcutCharPosition);
            assertFalse(shortcuts.contains(shortcut));
            shortcuts.add(shortcut);
        }
    }
}
```
###### \src\test\java\seedu\todo\model\task\ImmutableTaskTest.java
``` java
/**
 * This set of tests check that every implementation of ImmutableTask are equal and 
 * generates the same hashCode as each other when their copy constructor is used. 
 */
public class ImmutableTaskTest {
    private ImmutableTask reference = TaskFactory.fullEvent();
    
    private List<ImmutableTask> tasks = ImmutableList.of(
        new ValidationTask(reference), 
        new Task(reference)
    );
    
    private void permuteTasks(Function<ImmutableTask, Object> mapper) {
        Object referenceProperty = mapper.apply(reference);
        
        for (int i = 0; i < tasks.size(); i++) {
            ImmutableTask subject = tasks.get(i);
            Object subjectProperty = mapper.apply(subject);
            
            assertEquals(subjectProperty, referenceProperty);
            assertEquals(referenceProperty, subjectProperty);

            for (int j = i; j < tasks.size(); j++) {
                assertEquals(subjectProperty, mapper.apply(tasks.get(i)));
                assertEquals(mapper.apply(tasks.get(i)), subjectProperty);
            }
        }
    }
    
    @Test
    public void testEquality() {
        permuteTasks(task -> task);
    }

    @Test
    public void testHashing() {
        permuteTasks(Object::hashCode);
    }
    
    @Test
    public void testProperties() {
        permuteTasks(ImmutableTask::getTitle);
        permuteTasks(ImmutableTask::getTags);
        permuteTasks(ImmutableTask::getDescription);
        permuteTasks(ImmutableTask::getStartTime);
        permuteTasks(ImmutableTask::getEndTime);
        permuteTasks(ImmutableTask::getLocation);
        permuteTasks(ImmutableTask::isCompleted);
        permuteTasks(ImmutableTask::isEvent);
        permuteTasks(ImmutableTask::isPinned);
        permuteTasks(ImmutableTask::getCreatedAt);
    }
}
```
###### \src\test\java\seedu\todo\model\TodoModelTest.java
``` java
public class TodoModelTest {
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    @Rule
    public final ExpectedException exception = ExpectedException.none();
    
    @Mock private MovableStorage<ImmutableTodoList> storage;
    @Mock private ImmutableTodoList storageData;
    
    private TodoList todolist;
    private TodoModel model;
    private UnmodifiableObservableList<ImmutableTask> observableList;

    @Before
    public void setUp() throws Exception {
        when(storage.read()).thenReturn(storageData);
        when(storageData.getTasks()).thenReturn(Collections.emptyList());

        todolist = new TodoList(storage);
        model = new TodoModel(todolist, storage);
        observableList = model.getObservableList();
    }
    
    @Test
    public void testUpdateDateFields() throws Exception {
        model.add("Test Task");

        assertNotNull(model.update(1, t -> {
            t.setStartTime(TimeUtil.now);
            t.setEndTime(TimeUtil.now.plusHours(4));
        }));

        ImmutableTask task = observableList.get(0);
        assertEquals(TimeUtil.now, task.getStartTime().get());
        assertEquals(TimeUtil.now.plusHours(4), task.getEndTime().get());

        model.update(1, t -> t.setEndTime(TimeUtil.now));
        task = observableList.get(0);
        assertEquals(TimeUtil.now, task.getStartTime().get());
        assertEquals(TimeUtil.now, task.getEndTime().get());
    }

    @Test
    public void testPinning() throws Exception {
        model.add("Task 1");
        model.add("Task 2");
        model.add("Task 3");

        // Get the last item and pin it
        ImmutableTask lastTask = observableList.get(2);
        model.update(3, t -> t.setPinned(true));

        assertTrue(observableList.get(0).isPinned());
        assertEquals(lastTask.getTitle(), observableList.get(0).getTitle());
    }


    @Test(expected = ValidationException.class)
    public void testIllegalUpdate() throws Exception {
        model.add("Foo Bar Test");
        model.update(2, t -> t.setTitle("Test 2"));
    }

    @Test(expected = ValidationException.class)
    public void testIllegalDelete() throws Exception {
        model.add("Foo Bar Test");
        model.delete(2);
    }

    @Test
    public void testSorting() throws Exception {
        model.add("Task 3", p -> p.setEndTime(TimeUtil.now));
        model.add("Task 2", p -> p.setEndTime(TimeUtil.now.plusHours(2)));
        model.add("Task 1", p -> p.setEndTime(TimeUtil.now.plusHours(1)));

        TaskViewFilter lexi = new TaskViewFilter("lexi", 
            null, (a, b) -> a.getTitle().compareTo(b.getTitle()));
        TaskViewFilter chrono = new TaskViewFilter("chrono", 
            null, (a, b) -> a.getEndTime().get().compareTo(b.getEndTime().get()));

        // Check that the items are sorted in lexicographical order by title
        model.view(lexi);
        assertEquals("Task 1", observableList.get(0).getTitle());
        assertEquals("Task 2", observableList.get(1).getTitle());
        assertEquals(3, observableList.size());

        // Insert an item that comes before all others lexicographically
        model.add("Task 0", p -> p.setEndTime(TimeUtil.now.plusHours(3)));
        assertEquals("Task 0", observableList.get(0).getTitle());

        // Change its title and check that it has moved down
        model.update(1, t -> t.setTitle("Task 4"));
        assertEquals("Task 1", observableList.get(0).getTitle());
        assertEquals("Task 4", observableList.get(3).getTitle());

        // Check that sorting by time works
        // Chronological ordering would give us Task 3, 1, 2, 4
        model.view(chrono);
        assertEquals("Task 3", observableList.get(0).getTitle());
        assertEquals("Task 1", observableList.get(1).getTitle());
        assertEquals("Task 2", observableList.get(2).getTitle());
        assertEquals("Task 4", observableList.get(3).getTitle());
    }

    @Test
    public void testFiltering() throws Exception {
        model.add("Foo");
        model.add("FooBar");
        model.add("Bar");
        model.add("Bar Bar");

        // Give us only tasks with "Foo" in the title
        model.find(t -> t.getTitle().contains("Foo"));
        assertEquals(2, observableList.size());
    }

    @Test
    public void testSave() throws Exception {
        model.save("new location");
        verify(storage).save(todolist, "new location");
    }

    @Test
    public void testLoad() throws Exception {
        model.add("Some task");
        
        when(storageData.getTasks())
            .thenReturn(ImmutableList.of(new Task("Hello world")));
        when(storage.read("new location")).thenReturn(storageData);

        model.load("new location");
        // Check that the task list has been replaced 
        assertEquals(1, todolist.getTasks().size());
        assertEquals("Hello world", getTask(0).getTitle());
    }
    
    @Test
    public void testUndo() throws Exception {
        model.add("Test task 1");
        model.add("Test task 2");
        
        // Undo add 
        model.undo();
        assertEquals(1, todolist.getTasks().size());
        assertEquals("Test task 1", getTask(0).getTitle());
        
        // Undo edit 
        model.update(1, t -> t.setTitle("New title"));
        model.undo();
        assertEquals("Test task 1", getTask(0).getTitle());
        
        // Undo delete
        model.delete(1);
        model.undo();
        assertEquals(1, todolist.getTasks().size());
    }
    
    @Test
    public void testPersistAfterUndo() throws Exception {
        model.add("Test task 1");
        model.undo();
        verify(storage, times(2)).save(todolist);
    }
    
    @Test
    public void testUndoStackSize() throws Exception {
        final int STACK_SIZE = 10;
        
        // Add 11 items (which will add 11 to the undo stack) 
        for (int i = 0; i < STACK_SIZE + 1; i++) {
            model.add(TaskFactory.taskTitle());
        }
        
        // Undo until the undo stack is empty 
        for (int i = 0; i < STACK_SIZE; i++) {
            model.undo();
        }
        
        // Make sure the last undo throws an exception, even though 11 add 
        // events were recorded 
        exception.expect(ValidationException.class);
        model.undo();
    }
    
    @Test(expected = ValidationException.class)
    public void testOnlyUndoDataChanges() throws Exception {
        // Actions that does not cause underlying data to change should not cause 
        // undo stack to increase
        model.find(ImmutableTask::isCompleted);
        model.undo();
    }
    
    @Test(expected = ValidationException.class)
    public void testEmptyUndoStack() throws Exception {
        model.undo();
    }
    
    @Test
    public void testRedo() throws Exception {
        model.add("Test task 1");
        model.add("Test task 2");
        model.add("Test task 3");

        // Undo then redo add 
        model.undo();
        model.undo();
        assertEquals(1, todolist.getTasks().size());
        
        model.redo();
        assertEquals(2, todolist.getTasks().size());
        assertEquals("Test task 2", getTask(1).getTitle());
        
        model.redo();
        assertEquals(3, todolist.getTasks().size());
        assertEquals("Test task 3", getTask(2).getTitle());
    }

    @Test
    public void testPersistAfterRedo() throws Exception {
        model.add("Test task 1");
        model.undo();
        model.redo();
        verify(storage, times(3)).save(todolist);
    }
    
    @Test
    public void testActionAfterRedoClearsStack() throws Exception {
        model.add("Test task 1");
        model.add("Test task 2");
        model.add("Test task 3");

        // Undo then redo add 
        model.undo();
        model.undo();
        assertEquals(1, todolist.getTasks().size());

        model.redo();
        assertEquals(2, todolist.getTasks().size());
        assertEquals("Test task 2", getTask(1).getTitle());
        
        // There should be at least one more undo in this, but by performing 
        // an action we should invalidate the undo stack
        model.add("Test task 4");
        exception.expect(ValidationException.class);
        model.redo();
    }
    
    @Test(expected = ValidationException.class)
    public void testEmptyRedoStack() throws Exception {
        model.redo();
    }

    @Test
    public void testGetSaveLocation() throws Exception {
        when(storage.getLocation()).thenReturn("test location");
        assertEquals("test location", model.getStorageLocation());
    }

    /**
     * Get the task at the zero-index position in memory (reverse insertion order)
     */
    private ImmutableTask getTask(int index) {
        return todolist.getTasks().get(index);
    }

}
```
###### \src\test\java\seedu\todo\model\TodoTest.java
``` java
public class TodoTest {
    @Rule
    public final ExpectedException exception = ExpectedException.none();

    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    @Mock private MovableStorage<ImmutableTodoList> storage;
    @Mock private ImmutableTodoList storageData;
    private TodoList todo;

    @Before
    public void setUp() throws Exception {
        when(storage.read()).thenReturn(storageData);
        todo = new TodoList(storage);
    }

    @Test
    public void testEmptyStorage() throws Exception {
        when(storage.read()).thenThrow(new FileNotFoundException());
        todo = new TodoList(storage);

        assertThat(todo.getTasks(), empty());
    }

    @Test
    public void testRestoreFromStorage() {
        // Create a mock todo list, add it to mock storage and try to get
        // TodoList to retrieve it
        Task task1 = new Task("Task 1");
        Task task2 = new Task("Task 2");

        when(storageData.getTasks()).thenReturn(ImmutableList.of(task1, task2));
        todo = new TodoList(storage);

        assertEquals(2, todo.getTasks().size());
        assertTrue(todo.getTasks().contains(task1));
        assertTrue(todo.getTasks().contains(task2));
    }
    
    @Test
    public void testCompletedEvent() throws Exception {
        LocalDateTime start = LocalDateTime.now().minusHours(4);
        
        when(storageData.getTasks()).thenReturn(ImmutableList.of(
            TaskBuilder.name("Test task")
                .event(start, start.plusHours(1))
                .build()
        ));
        todo = new TodoList(storage);
        
        Thread.sleep(5);
        assertTrue(todo.getTasks().get(0).isCompleted());
    }

    @Test
    public void testAdd() throws Exception {
        assertNotNull(todo.add("Test Task 1"));
        assertEquals(1, todo.getTasks().size());
        assertFalse(getTask(0).isPinned());
        assertFalse(getTask(0).isCompleted());
        verify(storage).save(todo);

        assertNotNull(todo.add("Test Task 2"));
        assertEquals(2, todo.getTasks().size());
        assertEquals("Test Task 1", getTask(0).getTitle());
        assertEquals("Test Task 2", getTask(1).getTitle());
        verify(storage, times(2)).save(todo);
    }

    @Test
    public void testCreatedAt() throws Exception {
        LocalDateTime initialTime = LocalDateTime.now().minusSeconds(1);

        LocalDateTime firstCreatedAt = todo.add("Test Task 1").getCreatedAt();
        assertTrue(firstCreatedAt.isAfter(initialTime));

        // Delay for a bit
        Thread.sleep(1);
        LocalDateTime secondCreatedAt = todo.add("Test Task 2").getCreatedAt();
        assertTrue(secondCreatedAt.isAfter(firstCreatedAt));
    }

    @Test
    public void testUpdate() throws Exception {
        final String DESCRIPTION = "Really long description blah blah blah";
        final String TITLE = "New title";
        
        todo.add("Old Title");

        // Check that updating string fields work
        assertNotNull(todo.update(0, t -> {
            t.setTitle(TITLE);
            t.setDescription(DESCRIPTION);
        }));

        assertEquals(TITLE, getTask(0).getTitle());
        assertEquals(DESCRIPTION, getTask(0).getDescription().get());
        verify(storage, times(2)).save(todo);
    }
    
    @Test
    public void testUpdateUUID() throws Exception {
        ImmutableTask task = todo.add(TaskFactory.taskTitle());
        UUID taskUUID = task.getUUID();
        int hashCode = task.hashCode();
        
        todo.update(0, mutableTask -> {
            assertEquals(taskUUID, mutableTask.getUUID());
            assertEquals(hashCode, mutableTask.hashCode());
            assertEquals(mutableTask, task);
        });
    }

    @Test
    public void testUpdateBooleanFields() throws Exception {
        todo.add("Test Task");

        // Check that updating boolean fields work
        assertNotNull(todo.update(0, t -> t.setPinned(true)));
        assertTrue(getTask(0).isPinned());
        verify(storage, times(2)).save(todo);

        assertNotNull(todo.update(0, t -> t.setCompleted(true)));
        assertTrue(getTask(0).isCompleted());
        verify(storage, times(3)).save(todo);
    }

    @Test
    public void testDeleting() throws Exception {
        todo.add("Foo");
        todo.add("FooBar");
        todo.add("Bar");
        todo.add("Bar Bar");

        // Delete the first task, then check that it has been deleted
        ImmutableTask topTask = todo.getObservableList().get(0);
        todo.delete(0);
        assertFalse(todo.getTasks().contains(topTask));
        assertEquals(3, todo.getTasks().size());
        verify(storage, times(5)).save(todo);

        // Continue deleting the top task until the list is empty
        todo.delete(0);
        verify(storage, times(6)).save(todo);

        todo.delete(0);
        verify(storage, times(7)).save(todo);

        todo.delete(0);
        verify(storage, times(8)).save(todo);

        assertTrue(todo.getTasks().isEmpty());
    }

    @Test
    public void testEditSetEmptyTitle() throws Exception {
        todo.add("Task 1");

        try {
            todo.update(0, t -> t.setTitle(""));
            fail();
        } catch (ValidationException e) {
            // Check that the bad update didn't go through
            assertEquals("Task 1", getTask(0).getTitle());
        }
    }

    @Test
    public void testEdit() throws Exception {
        todo.add("Task 1");

        try {
            todo.update(0, t -> {
                t.setStartTime(LocalDateTime.now());
                t.setTitle("Title changed");
            });
            fail();
        } catch (ValidationException e) {
            assertEquals("Task 1", getTask(0).getTitle());
        }
    }

    @Test
    public void testAddOnlyStartDate() throws Exception {
        try {
            todo.add("Task 1", t -> t.setStartTime(LocalDateTime.now()));
            fail();
        } catch (ValidationException e) {
            // Check that the new task is not added to the list
            assertEquals(0, todo.getTasks().size());
        }
    }

    @Test(expected = ValidationException.class)
    public void testAddInvalidDateRange() throws Exception {
        todo.add("Task 1", t -> {
            t.setStartTime(LocalDateTime.now());
            t.setEndTime(LocalDateTime.now().minusHours(2));
        });
    }

    private ImmutableTask getTask(int index) {
        return todo.getTasks().get(index);
    }
}
```
###### \src\test\java\seedu\todo\testutil\TaskFactory.java
``` java
public class TaskFactory {
    private static final Faker faker = new Faker(new Locale("en", "SG"));
    private static final Random random = new Random();
    
    private static final List<String> friends = ImmutableList.of(
        "Govind", "Li Kai", "Louie", "Xien Dong", "Alex", "Jim"
    );
    
    private static final List<String> locations = ImmutableList.of(
        "LT15", "School of Computing", "Engineering Canteen", "Cafe Nowhere", 
        "Cinnamon College", "West Coast Plaza"
    );
    
    // For realism the test subject shall only have 5 modules 
    // And no Govind, he's not taking a double degree
    private static final List<String> modules = ImmutableList.of(
        "MA1521", "CS2104", "GET1025", "CS1231", "CS2100");
    
    private static final List<String> tags = ImmutableList.of(
        "urgent", "homework", "assignment", "tea_time", "pokemon_go", "to-do-12",
        "sports", "dinner", "CS2103T", "physics", "chemistry", "econs", "math"
    );
    
    private static final List<String> events = ImmutableList.of(
        "Watch {sport} match with {friend}",
        "Watch the next {superhero} movie with {friend}",
        "Attend concert with {friend}"
    );
    
    private static final List<String> tasks = ImmutableList.of(
        "Finish {module} homework {number}", 
        "Do {module} assignment #{number}", 
        "Do {module} lab #{number}", 
        "Prepare for {module} test", 
        "Discuss {module} project with {friend}",
        "Fix bug #{number}", 
        "Read new novel from {name}",
        "Research on new ways to get {power}"
    );
    
    private static <T> T choice(List<T> choices) {
        return choices.get(random.nextInt(choices.size()));
    }
    
    private static String substitute(String format) {
        return format
            .replace("{friend}", choice(friends))
            .replace("{module}", choice(modules))
            .replace("{name}", faker.name().fullName())
            .replace("{sport}", faker.team().sport())
            .replace("{superhero}", faker.superhero().name())
            .replace("{power}", faker.superhero().power())
            .replace("{number}", Integer.toString(random.nextInt(6) + 1));
    }
    
    private static LocalDateTime randomDate() {
        return TimeUtil.today()
            .plusDays(random.nextInt(20))
            .plusHours(random.nextInt(12) + 9)
            .plusMinutes(random.nextInt(3) * 15);
    }
    
    public static String taskTitle() {
        return substitute(choice(tasks));
    }
    
    public static String eventTitle() {
        return substitute(choice(events));
    }
    
    public static ImmutableTask task() {
        return TaskBuilder.name(taskTitle()).build();
    }

    public static ImmutableTask fullTask() {
        return TaskBuilder.name(taskTitle())
            .description(faker.lorem().paragraph(2))
            .due(randomDate())
            .build();
    }
    
    public static ImmutableTask event() {
        LocalDateTime start = randomDate();
        return TaskBuilder.name(eventTitle())
            .event(start, start.plusMinutes((random.nextInt(6) + 2) * 15))
            .build();
    }
    
    public static ImmutableTask fullEvent() {
        LocalDateTime start = randomDate();
        return TaskBuilder.name(eventTitle())
            .event(start, start.plusMinutes((random.nextInt(6) + 2) * 15))
            .location(choice(locations))
            .build();
    }
    
    public static ImmutableTask random() {
        switch (random.nextInt(4)) {
            case 0:
                return task();
            case 1:
                return fullTask();
            case 2:
                return event();
            default: 
                return fullEvent();
        }
    }
    
    public static List<ImmutableTask> list() {
        List<ImmutableTask> tasks = Lists.newArrayList(random());
        
        while (random.nextInt(5) != 0) {
            tasks.add(random());
        }
        
        return tasks;
    }

```
###### \src\test\java\seedu\todo\testutil\TimeUtil.java
``` java
public class TimeUtil {
    public static final LocalDateTime now = LocalDateTime.now();
    private static final String FORMAT_FULL_DATE = "d MMMM yyyy, h:mm a";
    
    public static LocalDateTime today() {
        return LocalDateTime.of(LocalDate.now(), LocalTime.of(0, 0));
    }
    
    public static LocalDateTime tomorrow() {
        return LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(0, 0));
    }

```
