# A0135805H
###### \java\seedu\todo\commons\events\ui\ExpandCollapseTaskEvent.java
``` java
/**
 * An event to tell the Ui to collapse or expand a given task in the to-do list.
 */
public class ExpandCollapseTaskEvent extends BaseEvent{

    public final ImmutableTask task;

    /**
     * Construct an event that tells the Ui to collapse or expend a given task in the to-do list.
     * @param task a single index of the task that is matching to the Ui (index 1 to num of tasks, inclusive)
     */
    public ExpandCollapseTaskEvent(ImmutableTask task) {
        this.task = task;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\todo\commons\util\StringUtil.java
``` java
    /**
     * Partitions the string into three parts:
     *      string[0 .. position - 1], string[position], string[position + 1 .. length - 1], all index inclusive
     * @param string to be partitioned
     * @param position location where the string should be partitioned
     * @return a String array containing the three elements stated above,
     *         where each element must not be null, but can have empty string.
     */
    public static String[] partitionStringAtPosition(String string, int position) {
        String[] stringArray = new String[3];
        if (string == null || string.isEmpty() || position < 0 || position >= string.length()) {
            stringArray[0] = "";
            stringArray[1] = "";
            stringArray[2] = "";
        } else {
            stringArray[0] = string.substring(0, position);
            stringArray[1] = string.substring(position, position + 1);
            stringArray[2] = string.substring(position + 1, string.length());
        }
        return stringArray;
    }

    /**
     * Splits string at only space and comma.
     * @return Returns a String array with all the split components of the string.
     */
    public static String[] splitString(String string) {
        if (string == null || string.isEmpty()) {
            return new String[0];
        } else {
            return string.trim().split("([, ])+");
        }
    }

    /**
     * Given a string list, gets the text from the list in the following manner:
     *      apple, pear, pineapple
     */
    public static String convertListToString(String[] stringList) {
        if (stringList == null || stringList.length == 0) {
            return "";
        }
        StringJoiner stringJoiner = new StringJoiner(", ");
        for (String string : stringList) {
            stringJoiner.add(string);
        }
        return stringJoiner.toString();
    }

```
###### \java\seedu\todo\commons\util\TimeUtil.java
``` java
/**
 * Utility methods that deals with time.
 */
public class TimeUtil {

    /* Constants */
    private static final Logger logger = LogsCenter.getLogger(TimeUtil.class);

    private static final String WORD_IN = "in";
    private static final String WORD_BY = "by";
    private static final String WORD_SINCE = "since";
    private static final String WORD_AGO = "ago";
    private static final String WORD_FROM = "from";
    private static final String WORD_TO = "to";
    private static final String WORD_TOMORROW = "tomorrow";
    private static final String WORD_YESTERDAY = "yesterday";
    private static final String WORD_TODAY = "today";
    private static final String WORD_TONIGHT = "tonight";
    private static final String WORD_COMMA = ",";
    private static final String WORD_SPACE = " ";

    private static final String DUE_NOW = "due now";
    private static final String DUE_LESS_THAN_A_MINUTE = "in less than a minute";

    private static final String UNIT_MINUTES = "minutes";
    private static final String VALUE_ONE_MINUTE = "1 minute";

    private static final String FORMAT_DATE_WITH_YEAR = "d MMMM yyyy";
    private static final String FORMAT_DATE_NO_YEAR = "d MMMM";
    private static final String FORMAT_TIME = "h:mm a";
    
    private static final Pattern DATE_REGEX = Pattern.compile("\\b([0123]?\\d)([/-])([01]?\\d)(?=\\2\\d{2,4}|\\s|$)");
    
    /* Variables */
    protected Clock clock = Clock.systemDefaultZone();
    
    /**
     * Gets the task deadline expression for the UI.
     * @param endTime ending time
     * @return a formatted deadline String
     */
    public String getTaskDeadlineText(LocalDateTime endTime) {
        if (endTime == null) {
            logger.log(Level.WARNING, "endTime in getTaskDeadlineText(...) is missing.");
            return "";
        }

        LocalDateTime currentTime = LocalDateTime.now(clock);
        if (endTime.isAfter(currentTime)) {
            return getDeadlineNotOverdueText(currentTime, endTime);
        } else {
            return getDeadlineOverdueText(currentTime, endTime);
        }
    }

    /**
     * Helper method of {@link #getTaskDeadlineText(LocalDateTime)} to get deadline text
     * when it is still not overdue (currentTime < endTime).
     * @param currentTime the time now
     * @param endTime the due date and time
     * @return a formatted deadline string
     */
    private String getDeadlineNotOverdueText(LocalDateTime currentTime, LocalDateTime endTime) {
        Duration durationCurrentToEnd = Duration.between(currentTime, endTime);
        long minutesToDeadline = durationCurrentToEnd.toMinutes();
        long secondsToDeadline = durationCurrentToEnd.getSeconds();

        StringJoiner stringJoiner = new StringJoiner(WORD_SPACE);

        if (secondsToDeadline <= 59) {
            return DUE_LESS_THAN_A_MINUTE;
        } else if (minutesToDeadline <= 59) {
            stringJoiner.add(WORD_IN).add(getMinutesText(currentTime, endTime));
        } else {
            stringJoiner.add(WORD_BY).add(getDateText(currentTime, endTime) + WORD_COMMA)
                    .add(getTimeText(endTime));
        }
        return stringJoiner.toString();
    }

    /**
     * Helper method of {@link #getTaskDeadlineText(LocalDateTime)} to get deadline text
     * when it is overdue (currentTime > endTime).
     * @param currentTime the time now
     * @param endTime the due date and time
     * @return a formatted deadline string
     */
    private String getDeadlineOverdueText(LocalDateTime currentTime, LocalDateTime endTime) {
        Duration durationCurrentToEnd = Duration.between(currentTime, endTime);
        long minutesToDeadline = durationCurrentToEnd.toMinutes();
        long secondsToDeadline = durationCurrentToEnd.getSeconds();

        StringJoiner stringJoiner = new StringJoiner(WORD_SPACE);

        if (secondsToDeadline >= -59) {
            return DUE_NOW;
        } else if (minutesToDeadline >= -59) {
            stringJoiner.add(getMinutesText(currentTime, endTime)).add(WORD_AGO);
        } else {
            stringJoiner.add(WORD_SINCE).add(getDateText(currentTime, endTime) + WORD_COMMA)
                    .add(getTimeText(endTime));
        }
        return stringJoiner.toString();
    }

    /**
     * Gets the event date and time text for the UI
     * @param startTime of the event
     * @param endTime of the event
     * @return a formatted event duration string
     */
    public String getEventTimeText(LocalDateTime startTime, LocalDateTime endTime) {
        if (startTime == null || endTime == null) {
            logger.log(Level.WARNING, "Either startTime or endTime is missing in getEventTimeText(...)");
            return "";
        } else if (startTime.isAfter(endTime)) {
            logger.log(Level.WARNING, "Start time is after end time in getEventTimeText(...)");
            return "";
        }

        LocalDateTime currentTime = LocalDateTime.now(clock);
        StringJoiner joiner = new StringJoiner(WORD_SPACE);
        if (isSameDay(startTime, endTime)) {
            joiner.add(getDateText(currentTime, startTime) + WORD_COMMA)
                    .add(WORD_FROM).add(getTimeText(startTime))
                    .add(WORD_TO).add(getTimeText(endTime));
        } else {
            joiner.add(WORD_FROM).add(getDateText(currentTime, startTime) + WORD_COMMA).add(getTimeText(startTime))
                    .add(WORD_TO).add(getDateText(currentTime, endTime) + WORD_COMMA).add(getTimeText(endTime));
        }
        return joiner.toString();
    }


    /**
     * Gives a formatted text of the dateTime based on the current system time, and then returns one of the following:
     *      "Yesterday", "Today", "Tonight", "Tomorrow",
     *      full date without year if this year,
     *      full date with year if other year.
     *
     * @param dateTime to format the date with
     * @return a formatted date text described above
     */
    private String getDateText(LocalDateTime currentTime, LocalDateTime dateTime) {
        if (isYesterday(currentTime, dateTime)) {
            return WORD_YESTERDAY;
        } else if (isTonight(currentTime, dateTime)) {
            return WORD_TONIGHT;
        } else if (isToday(currentTime, dateTime)) {
            return WORD_TODAY;
        } else if (isTomorrow(currentTime, dateTime)) {
            return WORD_TOMORROW;
        } else if (isSameYear(currentTime, dateTime)) {
            return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_DATE_NO_YEAR));
        } else {
            return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_DATE_WITH_YEAR));
        }
    }

    /**
     * Returns a formatted string of the time component of dateTime
     * @param dateTime to format the time with
     * @return a formatted time text (HH:MM A/PM)
     */
    private String getTimeText(LocalDateTime dateTime) {
        return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_TIME));
    }

    /**
     * Counts the number of minutes between the two dateTimes and prints out either:
     *      "1 minute" or "X minutes", for X != 1, X >= 0.
     * @param dateTime1 the first time instance
     * @param dateTime2 the other time instance
     * @return a formatted string to tell number of minutes left (as above)
     */
    private String getMinutesText(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        Duration duration = Duration.between(dateTime1, dateTime2);
        long minutesToDeadline = Math.abs(duration.toMinutes());

        if (minutesToDeadline == 1){
            return VALUE_ONE_MINUTE;
        } else {
            return minutesToDeadline + WORD_SPACE + UNIT_MINUTES;
        }
    }

    public boolean isTomorrow(LocalDateTime dateTimeToday, LocalDateTime dateTimeTomorrow) {
        LocalDate dayBefore = dateTimeToday.toLocalDate();
        LocalDate dayAfter = dateTimeTomorrow.toLocalDate();
        return dayBefore.plusDays(1).equals(dayAfter);
    }
    
    public boolean isToday(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        LocalDate date1 = dateTime1.toLocalDate();
        LocalDate date2 = dateTime2.toLocalDate();
        return date1.equals(date2);
    }

    private boolean isTonight(LocalDateTime dateTimeToday, LocalDateTime dateTimeTonight) {
        return isToday(dateTimeToday, dateTimeTonight)
                && dateTimeTonight.toLocalTime().isAfter(LocalTime.of(17, 59, 59));
    }
    
    private boolean isYesterday(LocalDateTime dateTimeToday, LocalDateTime dateTimeYesterday) {
        return isTomorrow(dateTimeYesterday, dateTimeToday);
    }

    private boolean isSameDay(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        return dateTime1.toLocalDate().equals(dateTime2.toLocalDate());
    }
    
    private boolean isSameYear(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        return dateTime1.getYear() == dateTime2.getYear();
    }
    
    public boolean isOverdue(LocalDateTime endTime) {
        if (endTime == null) {
            logger.log(Level.WARNING, "endTime in isOverdue(...) is null.");
            return false;
        }
        return endTime.isBefore(LocalDateTime.now(clock));
    }
    
```
###### \java\seedu\todo\logic\commands\TagCommand.java
``` java
/**
 * This class handles all tagging command
 */
public class TagCommand extends BaseCommand {
    /* Constants */
    private static final String VERB = "tagged";

    private static final String ERROR_INCOMPLETE_PARAMETERS = "You have not supplied sufficient parameters to run a Tag command.";
    private static final String ERROR_INPUT_INDEX_REQUIRED = "A task index is required.";
    private static final String ERROR_INPUT_ADD_TAGS_REQUIRED = "A list of tags \"tag1, tag2, ...\" to add is required.";
    private static final String ERROR_INPUT_DELETE_TAGS_REQUIRED = "A list of tags \"tag1, tag2, ...\" to delete is required.";
    private static final String ERROR_TAGS_DUPLICATED = "You might have keyed in duplicated tag names.";
    private static final String ERROR_TAGS_ILLEGAL_CHAR = "Tags may only include alphanumeric characters, including dashes and underscores.";

    private static final String SUCCESS_ADD_TAGS = " tags have been added successfully.";
    private static final String SUCCESS_DELETE_TAGS = " tags have been removed successfully.";

    private static final Pattern TAG_VALIDATION_REGEX = Pattern.compile("^[\\w\\d_-]+$");

    /* Variables */
    private Argument<Integer> index = new IntArgument("index");

    private Argument<String> addTags = new StringArgument("/a")
            .flag("a");

    private Argument<String> deleteTags = new StringArgument("/d")
            .flag("d");

    /* Constructor */
    /**
     * Empty constructor
     */
    public TagCommand() {}

    @Override
    public Parameter[] getArguments() {
        return new Parameter[] {
            index, deleteTags, addTags
        };
    }

    @Override
    protected void setPositionalArgument(String argument) {
        String[] tokens = argument.trim().split(" ", 2);
        boolean isFirstArgNumber = StringUtil.isUnsignedInteger(tokens[0]);

        if (isFirstArgNumber) {
            try {
                index.setValue(tokens[0]);
            } catch (IllegalValueException e) {
                errors.put(index.getName(), e.getMessage());
            }
        }
    }

    @Override
    public String getCommandName() {
        return "tag";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        String addNewTagsFromTaskArgument = index.getName() + " /a tag1 [, tag2, ...]";
        String deleteTagsFromTaskArgument = "[" + index.getName() + "] /d tag1 [, tag2, ...]";

        return ImmutableList.of(
            new CommandSummary("Add tags to a task", getCommandName(), addNewTagsFromTaskArgument),
            new CommandSummary("Delete tags from tasks", getCommandName(), deleteTagsFromTaskArgument)
        );
    }

    @Override
    protected void validateArguments() {
        //Check if we have enough input arguments
        if (!isInputParametersAvailable()) {
            handleUnavailableInputParameters();
        }

        //Check arguments for add tags case
        if (isAddTagsToTask()) {
            String[] tagsToAdd = StringUtil.splitString(addTags.getValue());
            checkForIllegalCharInTagNames(addTags.getName(), tagsToAdd);
            checkForDuplicatedTagNames(addTags.getName(), tagsToAdd);
        }

        //Check arguments for delete tags case
        if (isDeleteTagsFromTask()) {
            String[] tagsToDelete = StringUtil.splitString(deleteTags.getValue());
            checkForDuplicatedTagNames(deleteTags.getName(), tagsToDelete);
        }
        super.validateArguments();
    }

    @Override
    public CommandResult execute() throws ValidationException {
        //Obtain values for manipulation
        Integer displayedIndex = index.getValue();
        String[] tagsToAdd = StringUtil.splitString(addTags.getValue());
        String[] tagsToDelete = StringUtil.splitString(deleteTags.getValue());

        //Performs the actual execution with the data
        if (isAddTagsToTask()) {
            model.addTagsToTask(displayedIndex, tagsToAdd);
            return new CommandResult(StringUtil.convertListToString(tagsToAdd) + SUCCESS_ADD_TAGS);

        } else if (isDeleteTagsFromTask()) {
            model.deleteTagsFromTask(displayedIndex, tagsToDelete);
            return new CommandResult(StringUtil.convertListToString(tagsToDelete) + SUCCESS_DELETE_TAGS);

        } else {
            //Invalid case, should not happen, as we have checked it validateArguments.
            //However, for completeness, a command result is returned.
            throw new ValidationException(ERROR_INCOMPLETE_PARAMETERS);
        }
    }

    /* Input Parameters Validation */
    /**
     * Returns true if the command matches the action of adding tag(s) to a task.
     */
    private boolean isAddTagsToTask() {
        return index.hasBoundValue() && addTags.hasBoundValue();
    }

    /**
     * Returns true if the command matches the action of deleting tag(s) from a task.
     */
    private boolean isDeleteTagsFromTask() {
        return index.hasBoundValue() && deleteTags.hasBoundValue();
    }

    /**
     * Returns true if the command matches the action of deleting tag(s) from all tasks.
     */
    private boolean isDeleteTagsFromAllTasks() {
        return !index.hasBoundValue() && deleteTags.hasBoundValue();
    }

    /**
     * Returns true if the correct input parameters are available.
     * This method do not check validity of each input.
     */
    private boolean isInputParametersAvailable() {
        boolean isAddTagsToTask = isAddTagsToTask();
        boolean isDeleteTagsFromTask = isDeleteTagsFromTask();
        boolean isDeleteTagsFromAll = isDeleteTagsFromAllTasks();
        return BooleanUtils.xor(new boolean[]{isAddTagsToTask, isDeleteTagsFromTask, isDeleteTagsFromAll});
    }

    /**
     * Sets error messages for insufficient input parameters, dependent on input parameters supplied.
     */
    private void handleUnavailableInputParameters() {
        boolean hasIndex = index.getValue() != null;
        boolean hasAddTags = addTags.getValue() != null;
        boolean hasDeleteTags = deleteTags.getValue() != null;

        //Validation for all inputs.
        if (!hasIndex && !hasAddTags && !hasDeleteTags) {
            errors.put(index.getName(), ERROR_INPUT_INDEX_REQUIRED);
            errors.put(addTags.getName(), ERROR_INPUT_ADD_TAGS_REQUIRED);
            errors.put(deleteTags.getName(), ERROR_INPUT_DELETE_TAGS_REQUIRED);

        } else if (!hasIndex && hasAddTags) {
            errors.put(index.getName(), ERROR_INPUT_INDEX_REQUIRED);

        } else if (hasIndex && !hasAddTags && !hasDeleteTags) {
            errors.put(addTags.getName(), ERROR_INPUT_ADD_TAGS_REQUIRED);
            errors.put(deleteTags.getName(), ERROR_INPUT_DELETE_TAGS_REQUIRED);
        }
    }

    /**
     * Checks if the given tag names have duplicated entries.
     */
    private void checkForDuplicatedTagNames(String argumentName, String[] tagNames) {
        if (!CollectionUtil.elementsAreUnique(Arrays.asList(tagNames))) {
            errors.put(argumentName, ERROR_TAGS_DUPLICATED);
        }
    }

    /**
     * Check if the given tag names are alphanumeric, which also can contain dashes and underscores.
     */
    private void checkForIllegalCharInTagNames(String argumentName, String[] tagNames) {
        for (String tagName : tagNames) {
            if (!isValidTagName(tagName)) {
                errors.put(argumentName, ERROR_TAGS_ILLEGAL_CHAR);
            }
        }
    }

    /* Helper Methods */
    /**
     * Returns true if a given string is a valid tag name (alphanumeric, can contain dashes and underscores)
     * Originated from {@link Tag}
     */
    private static boolean isValidTagName(String test) {
        return TAG_VALIDATION_REGEX.matcher(test).matches();
    }
}
```
###### \java\seedu\todo\model\Model.java
``` java
    /**
     * Adds the supplied list of tags (as tag names) to the specified task.
     *
     * @param index The task displayed index.
     * @param tagNames The list of tag names to be added.
     * @throws ValidationException when the given index is invalid, or the given tagNames contain illegal characters.
     */
    void addTagsToTask(int index, String[] tagNames) throws ValidationException;

    /**
     * Deletes a list of tags from the specified task.
     *
     * @param index The task displayed index.
     * @param tagNames The list of tag names to be deleted.
     * @throws ValidationException when the given index is invalid, or when there is duplicates.
     */
    void deleteTagsFromTask(int index, String[] tagNames) throws ValidationException;
}
```
###### \java\seedu\todo\model\tag\Tag.java
``` java
/**
 * Represents a Tag in a task.
 *
 * Guarantees: immutable, only {@link UniqueTagCollection} can modify
 * the package private {@link Tag#rename(String)}.
 *
 * However, since alphanumeric name is not critical to {@link Tag},
 * the validation is done at {@link seedu.todo.model.TodoModel}
 */
public class Tag {
    /* Variables */
    //Stores a unique tag name, that is alphanumeric, and contains dashes and underscores.
    private String tagName;

    /* Default Constructor */
    public Tag() {}

    /**
     * Constructs a new tag with the given tag name.
     * This class is intentional to be package private, so only {@link UniqueTagCollection} can construct new tags.
     */
    public Tag(String name) {
        this.tagName = name;
    }

    /* Methods */
    /**
     * Renames the tag with a {@code newName}.
     * This class is intentional to be package private, so only {@link UniqueTagCollection} can rename tags.
     */
    void rename(String newName) {
        this.tagName = newName;
    }

    /* Override Methods */
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag && this.tagName.equals(((Tag) other).tagName)) // if is tag
                || (other instanceof String && this.tagName.equals(other)); // if is string
                //Enables string comparison for hashing.
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    /**
     * Format state as text for viewing.
     */
    public String toString() {
        return '[' + tagName + ']';
    }

    /* Getters */
    public String getTagName() {
        return tagName;
    }
}
```
###### \java\seedu\todo\model\tag\UniqueTagCollection.java
``` java
/**
 * A list of tags that enforces no nulls and uniqueness between its elements.
 * Also supports minimal set of list operations for the app's features.
 *
 * Note: This class will disallow external access to {@link #uniqueTagsToTasksMap} so to
 * maintain uniqueness of the tag names.
 */
public class UniqueTagCollection implements Iterable<Tag>, UniqueTagCollectionModel {
    /* Constants */
    private static final String ERROR_DATA_INTEGRITY = "Data Integrity Issue: A tag is missing from the collection.";

    /* Variables */
    private final Logger logger = Logger.getLogger(UniqueTagCollection.class.getName());

    /*
        Stores a list of tags with unique tag names.
        TODO: ImmutableTask does not have consistent hashing.
        TODO: So, duplicated ImmutableTask may be found in the set of each Tag.
     */
    private final Map<Tag, Set<ImmutableTask>> uniqueTagsToTasksMap = new HashMap<>();

    /**
     * Constructs empty TagList.
     */
    public UniqueTagCollection() {}

    /* Interfacing Methods */
    @Override
    public void initialise(ObservableList<ImmutableTask> globalTaskList) {
        uniqueTagsToTasksMap.clear();
        globalTaskList.forEach(task -> task.getTags().forEach(tag -> associateTaskToTag(task, tag)));
    }

    @Override
    public Tag registerTagWithTask(ImmutableTask task, String tagName) {
        Tag tag = getTagWithName(tagName, false);
        associateTaskToTag(task, tag);
        return tag;
    }

    @Override
    public Tag unregisterTagWithTask(ImmutableTask task, String tagName) {
        Tag tag = getTagWithName(tagName, true);
        dissociateTaskFromTag(task, tag);
        return tag;
    }

    @Override
    public void notifyTaskDeleted(ImmutableTask task) {
        task.getTags().forEach(tag -> dissociateTaskFromTag(task, tag));
    }

    @Override
    public void renameTag(String originalName, String newName) {
        Tag tag = getTagWithName(originalName, true);
        Set<ImmutableTask> setOfTasks = uniqueTagsToTasksMap.remove(tag);
        tag.rename(newName);
        uniqueTagsToTasksMap.put(tag, setOfTasks);
    }

    /* Helper Methods */
    /**
     * Links a {@code task} to the {@code tag} in the {@link #uniqueTagsToTasksMap}.
     */
    private void associateTaskToTag(ImmutableTask task, Tag tag) {
        Set<ImmutableTask> setOfTasks = uniqueTagsToTasksMap.get(tag);
        if (setOfTasks == null) {
            setOfTasks = new HashSet<>();
            uniqueTagsToTasksMap.put(tag, setOfTasks);
        }
        setOfTasks.add(task);
    }

    /**
     * Removes the association between the {@code task} from the {@code tag} in
     * the {@link #uniqueTagsToTasksMap}.
     */
    private void dissociateTaskFromTag(ImmutableTask task, Tag tag) {
        Set<ImmutableTask> setOfTasks = uniqueTagsToTasksMap.get(tag);
        if (setOfTasks != null) {
            setOfTasks.remove(task);
        }
    }

    /**
     * Obtains an instance of {@link Tag} with the supplied {@code tagName} from the
     * {@link #uniqueTagsToTasksMap}.
     *
     * Note: If such an instance is not found, a new {@link Tag} instance will \be added to the
     *       {@link #uniqueTagsToTasksMap}.
     * Note: If {@code expectAvailable} is true, logger will log an error when when we can't find the
     *       tag with the tag name.
     *
     * @param tagName The name of the {@link Tag}.
     * @param expectAvailable True implies that the {@link Tag} object must be found.
     * @return A {@link Tag} object that has the name {@code tagName}.
     * TODO: Allow this method to have less responsibility.
     */
    private Tag getTagWithName(String tagName, boolean expectAvailable) {
        Optional<Tag> possibleTag = uniqueTagsToTasksMap.keySet().stream()
                .filter(tag -> tag.getTagName().equals(tagName)).findAny();

        if (!possibleTag.isPresent() && expectAvailable) {
            logger.warning(ERROR_DATA_INTEGRITY);
        }

        Tag targetTag;
        if (possibleTag.isPresent()) {
            targetTag = possibleTag.get();
        } else {
            targetTag = new Tag(tagName);
            uniqueTagsToTasksMap.put(targetTag, new HashSet<>());
        }
        return targetTag;
    }

    /**
     * Simply finds a tag with the tag name.
     */
    private Optional<Tag> findTagWithName(String tagName) {
        return uniqueTagsToTasksMap.keySet().stream()
                .filter(tag -> tag.getTagName().equals(tagName)).findAny();
    }

    /* Interfacing Getters */
    @Override
    public List<Tag> getUniqueTagList() {
        return new ArrayList<>(uniqueTagsToTasksMap.keySet());
    }

    @Override
    public List<ImmutableTask> getTasksLinkedToTag(String tagName) {
        Optional<Tag> possibleTag = findTagWithName(tagName);
        if (possibleTag.isPresent()) {
            Set<ImmutableTask> tasks = uniqueTagsToTasksMap.get(possibleTag.get());
            return new ArrayList<>(tasks);
        } else {
            return new ArrayList<>();
        }
    }

    /* Other Override Methods */
    @Override
    public Iterator<Tag> iterator() {
        return uniqueTagsToTasksMap.keySet().iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTagCollection // instanceof handles nulls
                && this.uniqueTagsToTasksMap.equals(
                ((UniqueTagCollection) other).uniqueTagsToTasksMap));
    }

    @Override
    public int hashCode() {
        return uniqueTagsToTasksMap.hashCode();
    }
}
```
###### \java\seedu\todo\model\tag\UniqueTagCollectionModel.java
``` java
/**
 * An interface that spells out the available methods for maintaining a unique tag list.
 */
public interface UniqueTagCollectionModel {

    /* Model Interfacing Methods*/
    /**
     * Instantiate the {@link UniqueTagCollectionModel} by extracting all the {@link Tag}s
     * from the global to-do list {@code globalTaskList}.
     * @param globalTaskList To extract the unique list of {@link Tag}s from.
     */
    void initialise(ObservableList<ImmutableTask> globalTaskList);

    /**
     * Registers the given {@code task} to a {@link Tag} in the {@link UniqueTagCollectionModel}.
     *
     * @param task The task to be attached under the {@link Tag}.
     * @param tagName The name of the {@link Tag}.
     * @return Returns a {@link Tag} object with the {@code tagName} so that this tag can be added to the {@code task}.
     */
    Tag registerTagWithTask(ImmutableTask task, String tagName);

    /**
     * Notifies the {@link UniqueTagCollectionModel} that the given {@code task} is deleted,
     * so that the {@link UniqueTagCollectionModel} can update the relations accordingly.
     */
    void notifyTaskDeleted(ImmutableTask task);

    /* Tag Command Interfacing Methods */
    /**
     * Unregistere the given {@code task} from the {@link Tag} in the {@link UniqueTagCollectionModel}.
     * TODO: Tags not found may throw an exception. This will be implemented next time.
     *
     * @param task The task to be detached from the {@link Tag}.
     * @param tagName The name of the {@link Tag}.
     * @return Returns a {@link Tag} object with the {@code tagName} so that this tag can be removed from the {@code task}.
     */
    Tag unregisterTagWithTask(ImmutableTask task, String tagName);

    /**
     * Renames a {@link Tag} with the given {@code originalName} with the {@code newName}
     */
    void renameTag(String originalName, String newName) throws ValidationException;

    /**
     * Gets a copy of the list of tags.
     */
    List<Tag> getUniqueTagList();

    /**
     * Gets a copy of list of task associated with the {@link Tag} with the name {@code tagName}
     */
    List<ImmutableTask> getTasksLinkedToTag(String tagName);
}
```
###### \java\seedu\todo\model\TodoModel.java
``` java
    @Override
    public void addTagsToTask(int index, String[] tagNames) throws ValidationException {
        saveUndoState();
        update(index, mutableTask -> {
            Set<Tag> tagsFromTask = new HashSet<>(mutableTask.getTags());
            for (String tagName : tagNames) {
                Tag newTag = uniqueTagCollection.registerTagWithTask(mutableTask, tagName);
                tagsFromTask.add(newTag);
            }
            mutableTask.setTags(tagsFromTask);
        });
    }

    @Override
    public void deleteTagsFromTask(int index, String[] tagNames) throws ValidationException {
        saveUndoState();
        update(index, mutableTask -> {
            Set<Tag> tagsFromTask = new HashSet<>(mutableTask.getTags());
            for (String tagName : tagNames) {
                Tag deletedTag = uniqueTagCollection.unregisterTagWithTask(mutableTask, tagName);
                tagsFromTask.remove(deletedTag);
            }
            mutableTask.setTags(tagsFromTask);
        });
    }
}
```
###### \java\seedu\todo\ui\controller\CommandController.java
``` java
/**
 * Processes the input command from {@link CommandInputView}, pass it to {@link seedu.todo.logic.Logic}
 * and hands the {@link seedu.todo.logic.commands.CommandResult}
 * to {@link CommandFeedbackView} and {@link CommandErrorView}
 */
public class CommandController {

    private Logic logic;
    private CommandInputView inputView;
    private CommandPreviewView previewView;
    private CommandFeedbackView feedbackView;
    private CommandErrorView errorView;

    /**
     * Defines a default constructor
     */
    private CommandController() {}

    /**
     * Constructs a link between the classes defined in the parameters.
     */
    public static CommandController constructLink(Logic logic,
                                                  CommandInputView inputView, CommandPreviewView previewView,
                                                  CommandFeedbackView feedbackView, CommandErrorView errorView) {
        CommandController controller = new CommandController();
        controller.logic = logic;
        controller.inputView = inputView;
        controller.previewView = previewView;
        controller.feedbackView = feedbackView;
        controller.errorView = errorView;
        controller.start();
        return controller;
    }

    /**
     * Asks {@link #inputView} to start listening for a new key strokes.
     * Once the callback returns a command, {@link #handleInput(KeyCode, String)} will process the input.
     */
    private void start() {
        inputView.listenToInput(this::handleInput);
    }

```
###### \java\seedu\todo\ui\util\FxViewUtil.java
``` java
    /**
     * Hides a specified UI element, and ensures that it does not occupy any space.
     */
    public static void setCollapsed(Node node, boolean isCollapsed) {
        node.setVisible(!isCollapsed);
        node.setManaged(!isCollapsed);
    }
    
    /**
     * Set the text to UI element when available, collapse the UI element when not.
     */
    public static void displayTextWhenAvailable(Label labelToDisplay, Node nodeToHide, Optional<String> optionalString) {
        if (optionalString.isPresent()) {
            labelToDisplay.setText(optionalString.get());
        } else {
            labelToDisplay.setText("");
            setCollapsed(nodeToHide, true);
        }
    }

    /**
     * Sets a recurring task on the UI specified in handler to repeat every specified seconds.
     * Does not start until the user executes .play()
     * @param seconds duration between each repeats
     * @param handler method to run is specified here
     * @return {@link Timeline} object to run.
     */
    public static Timeline setRecurringUiTask(int seconds, EventHandler<ActionEvent> handler) {
        Timeline recurringTask = new Timeline(new KeyFrame(Duration.seconds(seconds), handler));
        recurringTask.setCycleCount(Timeline.INDEFINITE);
        return recurringTask;
    }

    /**
     * Converts an index from a list to the index that is displayed to the user via the Ui
     */
    public static int convertToListIndex(int uiIndex) {
        return uiIndex - 1;
    }

    /**
     * Converts an index displayed on the Ui to the user, to the index used on the list
     */
    public static int convertToUiIndex(int listIndex) {
        return listIndex + 1;
    }
}
```
###### \java\seedu\todo\ui\util\UiPartLoaderUtil.java
``` java
    /**
     * Attaches only one children view element to a specified placeholder.
     * However, if either one of the params is null, it will result in no-op.
     * Also, if there are any other children in the placeholder, they will be cleared first.
     *
     * @param placeholder to add the childrenView to, no-op if null
     * @param childrenView to be attached to the placeholder, no-op if null
     */
    private static void attachToPlaceholder(AnchorPane placeholder, Node childrenView) {
        if (placeholder != null && childrenView != null) {
            ObservableList<Node> placeholderChildren = placeholder.getChildren();
            placeholderChildren.clear();
            placeholderChildren.add(childrenView);
        }
    }
}
```
###### \java\seedu\todo\ui\util\ViewGeneratorUtil.java
``` java
/**
 * A utility class that generates commonly used UI elements, such as Labels.
 */
public class ViewGeneratorUtil {

    /**
     * Generates a {@link Text} object with the class style applied onto the object.
     * @param string to be wrapped in the {@link Text} object
     * @param classStyle css style to be applied to the label
     * @return a {@link Text} object
     */
    public static Text constructText(String string, String classStyle) {
        Text text = new Text(string);
        ViewStyleUtil.addClassStyles(text, classStyle);
        return text;
    }

    /**
     * Constructs a label view with a dark grey rounded background.
     */
    public static Label constructRoundedText(String string) {
        Label label = constructLabel(string, "roundLabel");
        label.setPadding(new Insets(0, 8, 0, 8));
        return label;
    }

    /**
     * Generates a {@link Label} object with the class style applied onto the object.
     * @param string to be wrapped in the {@link Label} object
     * @param classStyle css style to be applied to the label
     * @return a {@link Label} object
     */
    public static Label constructLabel(String string, String classStyle) {
        Label label = new Label(string);
        ViewStyleUtil.addClassStyles(label, classStyle);
        return label;
    }

    /**
     * Place all the specified texts into a {@link TextFlow} object.
     */
    public static TextFlow placeIntoTextFlow(Text... texts) {
        return new TextFlow(texts);
    }
}
```
###### \java\seedu\todo\ui\util\ViewStyleUtil.java
``` java
/**
 * Deals with the CSS styling of View elements
 */
public class ViewStyleUtil {

    /* Style Classes Constants */
    public static final String STYLE_COLLAPSED = "collapsed";
    public static final String STYLE_COMPLETED = "completed";
    public static final String STYLE_OVERDUE = "overdue";
    public static final String STYLE_SELECTED = "selected";
    public static final String STYLE_TEXT_4 = "text4";
    public static final String STYLE_ERROR = "error";
    public static final String STYLE_CODE = "code";
    public static final String STYLE_BOLDER = "bolder";
    public static final String STYLE_UNDERLINE = "underline";
    public static final String STYLE_ONGOING = "ongoing";

    /*Static Helper Methods*/
    /**
     * Adds only one instance of all the class styles to the node object
     * @param node view object to add the class styles to
     * @param classStyles all the class styles that is to be added to the node
     */
    public static void addClassStyles(Node node, String... classStyles) {
        for (String classStyle : classStyles) {
            addClassStyle(node, classStyle);
        }
    }

    /**
     * Remove all instance of all the class styles to the node object
     * @param node view object to add the class styles to
     * @param classStyles all the class styles that is to be removed from the node
     */
    public static void removeClassStyles(Node node, String... classStyles) {
        for (String classStyle : classStyles) {
            removeClassStyle(node, classStyle);
        }
    }

    /**
     * Adds or removes class style based on a boolean parameter
     * @param isAdding true to add, false to remove
     * @param node view object to add the class styles to
     * @param classStyles all the class styles that is to be added to/removed from the node
     */
    public static void addRemoveClassStyles(boolean isAdding, Node node, String... classStyles) {
        for (String classStyle : classStyles) {
            if (isAdding) {
                addClassStyles(node, classStyle);
            } else {
                removeClassStyles(node, classStyle);
            }
        }
    }

    /**
     * Toggles one style class to the node:
     *      If supplied style class is available, remove it.
     *      Else, add one instance of it.
     *  @return true if toggled from OFF -> ON
     */
    public static boolean toggleClassStyle(Node node, String classStyle) {
        boolean wasPreviouslyOff = !node.getStyleClass().contains(classStyle);
        if (wasPreviouslyOff) {
            addClassStyles(node, classStyle);
        } else {
            removeClassStyles(node, classStyle);
        }
        return wasPreviouslyOff;
    }

    /* Private Helper Methods */
    /**
     * Adds only one instance of a single class style to the node object
     */
    private static void addClassStyle(Node node, String classStyle) {
        if (!node.getStyleClass().contains(classStyle)) {
            node.getStyleClass().add(classStyle);
        }
    }

    /**
     * Removes all instances of a single class style from the node object
     */
    private static void removeClassStyle(Node node, String classStyle) {
        while (node.getStyleClass().contains(classStyle)) {
            node.getStyleClass().remove(classStyle);
        }
    }
}
```
###### \java\seedu\todo\ui\view\CommandErrorView.java
``` java
/**
 * A view class that displays specific command errors in greater detail.
 */
public class CommandErrorView extends UiPart {

    private final Logger logger = LogsCenter.getLogger(CommandFeedbackView.class);
    private static final String FXML = "CommandErrorView.fxml";

    private AnchorPane placeholder;
    private VBox errorViewBox;
    @FXML private VBox nonFieldErrorBox;
    @FXML private VBox fieldErrorBox;
    @FXML private GridPane nonFieldErrorGrid;
    @FXML private GridPane fieldErrorGrid;

    /**
     * Loads and initialise the feedback view element to the placeHolder
     * @param primaryStage of the application
     * @param placeHolder where the view element {@link #errorViewBox} should be placed
     * @return an instance of this class
     */
    public static CommandErrorView load(Stage primaryStage, AnchorPane placeHolder) {
        CommandErrorView errorView = UiPartLoaderUtil.loadUiPart(primaryStage, placeHolder, new CommandErrorView());
        errorView.configureLayout();
        errorView.hideCommandErrorView();
        return errorView;
    }

    /**
     * Configure the UI layout of {@link CommandErrorView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(errorViewBox, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(nonFieldErrorBox, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(fieldErrorBox, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(fieldErrorGrid, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(nonFieldErrorGrid, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Displays both field and non-field errors to the user
     * @param errorBag that contains both field and non-field errors
     */
    public void displayErrors(ErrorBag errorBag) {
        showCommandErrorView();
        clearOldErrorsFromViews();
        displayFieldErrors(errorBag.getFieldErrors());
        displayNonFieldErrors(errorBag.getNonFieldErrors());
    }

    /**
     * Feeds non field errors to the {@link #nonFieldErrorGrid}.
     * If there are no non-field errors, then {@link #nonFieldErrorBox} will be hidden.
     * @param nonFieldErrors that stores a list of non-field errors
     */
    private void displayNonFieldErrors(List<String> nonFieldErrors) {
        if (nonFieldErrors.isEmpty()) {
            hideErrorBox(nonFieldErrorBox);
        } else {
            int rowCounter = 0;
            for (String error : nonFieldErrors) {
                addRowToGrid(nonFieldErrorGrid, rowCounter++, rowCounter + ".", error);
            }
        }
    }

    /**
     * Feeds field errors to the {@link #fieldErrorGrid}.
     * If there are no field errors, then {@link #fieldErrorBox} will be hidden.
     * @param fieldErrors that stores the field errors
     */
    private void displayFieldErrors(Map<String, String> fieldErrors) {
        if (fieldErrors.isEmpty()) {
            hideErrorBox(fieldErrorBox);
        } else {
            int rowCounter = 0;
            for (Map.Entry<String, String> fieldError : fieldErrors.entrySet()) {
                addRowToGrid(fieldErrorGrid, rowCounter++, fieldError.getKey(), fieldError.getValue());
            }
        }
    }

    /* Override Methods */
    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeholder = placeholder;
    }

    @Override
    public void setNode(Node node) {
        this.errorViewBox = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    /*Helper Methods*/
    /**
     * Adds a row of text to the targetGrid
     * @param targetGrid to add a row of text on
     * @param rowIndex which row to add this row of text
     * @param leftText text for the first column
     * @param rightText text for the second column
     */
    private void addRowToGrid(GridPane targetGrid, int rowIndex, String leftText, String rightText) {
        Label leftLabel = ViewGeneratorUtil.constructLabel(leftText, ViewStyleUtil.STYLE_TEXT_4);
        Label rightLabel = ViewGeneratorUtil.constructLabel(rightText, ViewStyleUtil.STYLE_TEXT_4);
        targetGrid.addRow(rowIndex, leftLabel, rightLabel);
    }

    /**
     * Clears all elements in the given grid.
     */
    private void clearGrid(GridPane gridPane) {
        gridPane.getChildren().clear();
    }

    /**
     * Hides a field or non-field error box.
     * @param vBox can be either {@link #fieldErrorBox} or {@link #nonFieldErrorBox}
     */
    private void hideErrorBox(VBox vBox) {
        FxViewUtil.setCollapsed(vBox, true);
    }

    /**
     * Shows a field or non-field error box.
     * @param vBox can be either {@link #fieldErrorBox} or {@link #nonFieldErrorBox}
     */
    private void showErrorBox(VBox vBox) {
        FxViewUtil.setCollapsed(vBox, false);
    }

    /**
     * Hides the entire {@link CommandErrorView}
     */
    public void hideCommandErrorView() {
        FxViewUtil.setCollapsed(placeholder, true);
    }

    /**
     * Displays the entire {@link CommandErrorView}
     */
    private void showCommandErrorView() {
        FxViewUtil.setCollapsed(placeholder, false);
    }

    /**
     * Clears previous errors from the grid, and then unhide all the error boxes.
     */
    private void clearOldErrorsFromViews() {
        clearGrid(nonFieldErrorGrid);
        clearGrid(fieldErrorGrid);
        showErrorBox(nonFieldErrorBox);
        showErrorBox(fieldErrorBox);
    }
}
```
###### \java\seedu\todo\ui\view\CommandFeedbackView.java
``` java
/**
 * Display textual feedback to command input via this view with {@link #displayMessage(String)}.
 */
public class CommandFeedbackView extends UiPart {
    /* Constants */
    private static final String FXML = "CommandFeedbackView.fxml";

    /* Variables */
    private final Logger logger = LogsCenter.getLogger(CommandFeedbackView.class);

    /* Layout Elements */
    @FXML private Label commandFeedbackLabel;
    private AnchorPane textContainer;

    /**
     * Loads and initialise the feedback view element to the placeholder.
     *
     * @param primaryStage The main stage of the application.
     * @param placeholder The place where the view element {@link #textContainer} should be placed.
     * @return An instance of this class.
     */
    public static CommandFeedbackView load(Stage primaryStage, AnchorPane placeholder) {
        CommandFeedbackView feedbackView = UiPartLoaderUtil.loadUiPart(primaryStage, placeholder, new CommandFeedbackView());
        feedbackView.configureLayout();
        return feedbackView;
    }

    /**
     * Configure the UI layout of {@link CommandFeedbackView}.
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(textContainer, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandFeedbackLabel, 0.0, 0.0, 0.0, 0.0);
    }

    /* Interfacing Methods */
    /**
     * Displays a message onto the {@link #commandFeedbackLabel}.
     * @param message The feedback message to be shown to the user.
     */
    public void displayMessage(String message) {
        commandFeedbackLabel.setText(message);
    }

    /**
     * Clears any message in {@link #commandFeedbackLabel}.
     */
    public void clearMessage() {
        commandFeedbackLabel.setText("");
    }

    /**
     * Indicate an error visually on the {@link #commandFeedbackLabel}.
     */
    public void flagError() {
        ViewStyleUtil.addClassStyles(commandFeedbackLabel, ViewStyleUtil.STYLE_ERROR);
    }

    /**
     * Remove the error flag visually on the {@link #commandFeedbackLabel}.
     */
    public void unFlagError() {
        ViewStyleUtil.removeClassStyles(commandFeedbackLabel, ViewStyleUtil.STYLE_ERROR);
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        this.textContainer = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\todo\ui\view\CommandInputView.java
``` java
/**
 * A view class that handles the Input text box directly.
 */
public class CommandInputView extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandInputView.class);
    private static final String FXML = "CommandInputView.fxml";

    private AnchorPane placeHolder;
    private AnchorPane commandInputPane;

    @FXML
    private TextArea commandTextField;

    /**
     * Loads and initialise the input view element to the placeHolder
     * @param primaryStage of the application
     * @param placeHolder where the view element {@link #commandInputPane} should be placed
     * @return an instance of this class
     */
    public static CommandInputView load(Stage primaryStage, AnchorPane placeHolder) {
        CommandInputView commandInputView = UiPartLoaderUtil.loadUiPart(primaryStage, placeHolder, new CommandInputView());
        commandInputView.configureLayout();
        commandInputView.configureProperties();
        return commandInputView;
    }

    /**
     * Configure the UI layout of {@link CommandInputView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(commandInputPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Configure the UI properties of {@link CommandInputView}
     */
    private void configureProperties() {
        setCommandInputHeightAutoResizeable();
        unflagErrorWhileTyping();
        listenAndRaiseEnterEvent();
    }

```
###### \java\seedu\todo\ui\view\FilterBarView.java
``` java
/**
 * Shows a row of filter categories via {@link TaskViewFilter}
 * to filter the tasks in {@link TodoListView}
 */
public class FilterBarView extends UiPart {
    /* Constants */
    private final Logger logger = LogsCenter.getLogger(FilterBarView.class);
    private static final String FXML = "FilterBarView.fxml";

    /* Layout Views */
    private AnchorPane placeholder;
    private FlowPane filterViewPane;

    /* Variables */
    private Map<TaskViewFilter, HBox> taskFilterBoxesMap = new HashMap<>();

    /* Layout Initialisation */
    /**
     * Loads and initialise the {@link #filterViewPane} to the {@link seedu.todo.ui.MainWindow}
     * @param primaryStage of the application
     * @param placeholder where the view element {@link #filterViewPane} should be placed
     * @return an instance of this class
     */
    public static FilterBarView load(Stage primaryStage, AnchorPane placeholder, ObservableValue<TaskViewFilter> filter) {
        FilterBarView filterView = UiPartLoaderUtil.loadUiPart(primaryStage, placeholder, new FilterBarView());
        filterView.configureLayout();
        filterView.configureProperties();
        filterView.bindListener(filter);
        return filterView;
    }

    /**
     * Configure the UI layout of {@link FilterBarView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(filterViewPane, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Initialise and configure the UI properties of {@link FilterBarView}
     */
    private void configureProperties() {
        initialiseAllViewFilters();
        selectOneViewFilter(TaskViewFilter.DEFAULT);
    }

    /**
     * Display all the {@link TaskViewFilter} on the {@link #filterViewPane}
     */
    private void initialiseAllViewFilters() {
        for (TaskViewFilter filter : TaskViewFilter.all()) {
            appendEachViewFilter(filter);
        }
    }

    /**
     * Add one {@link TaskViewFilter} on the {@link #filterViewPane}
     * and save an instance to the {@link #taskFilterBoxesMap}
     * @param filter to add onto the pane
     */
    private void appendEachViewFilter(TaskViewFilter filter) {
        HBox textContainer = constructViewFilterBox(filter);
        taskFilterBoxesMap.put(filter, textContainer);
        filterViewPane.getChildren().add(textContainer);
    }

    /**
     * Given a filter, construct a view element to be displayed on the {@link #filterViewPane}
     * @param filter to be displayed
     * @return a view element
     */
    private HBox constructViewFilterBox(TaskViewFilter filter) {
        String filterName = WordUtils.capitalize(filter.name);
        String[] partitionedText = StringUtil.partitionStringAtPosition(filterName, filter.shortcutCharPosition);

        Label leftText = new Label(partitionedText[0]);
        Label centreText = new Label(partitionedText[1]);
        Label rightText = new Label(partitionedText[2]);
        ViewStyleUtil.addClassStyles(centreText, ViewStyleUtil.STYLE_UNDERLINE);

        HBox textContainer = new HBox();
        textContainer.getChildren().add(leftText);
        textContainer.getChildren().add(centreText);
        textContainer.getChildren().add(rightText);
        return textContainer;
    }

    /**
     * Binds this component with the {@link TaskViewFilter} property it listens to
     */
    private void bindListener(ObservableValue<TaskViewFilter> filter) {
        filter.addListener((observable, oldValue, newValue) -> selectOneViewFilter(newValue));
    }
    
    /**
     * Select exactly one filter from {@link #filterViewPane}
     */
    public void selectOneViewFilter(TaskViewFilter filter) {
        clearAllViewFiltersSelection();
        selectViewFilter(filter);
    }

    /* Helper Methods */
    /**
     * Clears all selection from the {@link #filterViewPane}
     */
    private void clearAllViewFiltersSelection() {
        for (HBox filterBox : taskFilterBoxesMap.values()) {
            ViewStyleUtil.removeClassStyles(filterBox, ViewStyleUtil.STYLE_SELECTED);
        }
    }

    /**
     * Mark the filter as selected on {@link #filterViewPane}
     * However, if filter is null, nothing is done.
     */
    private void selectViewFilter(TaskViewFilter filter) {
        if (filter != null) {
            HBox filterBox = taskFilterBoxesMap.get(filter);
            ViewStyleUtil.addClassStyles(filterBox, ViewStyleUtil.STYLE_SELECTED);
        }
    }

    /* Override Methods */
    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeholder = placeholder;
    }

    @Override
    public void setNode(Node node) {
        this.filterViewPane = (FlowPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\todo\ui\view\HelpView.java
``` java
/**
 * A view that displays all the help commands in a single view.
 */
public class HelpView extends UiPart {

    private final Logger logger = LogsCenter.getLogger(HelpView.class);
    private static final String FXML = "HelpView.fxml";

    /*Layouts*/
    private AnchorPane placeholder;
    private VBox helpPanelView;

    @FXML
    private GridPane helpGrid;

    /**
     * Loads and initialise the feedback view element to the placeHolder
     * @param primaryStage of the application
     * @param placeholder where the view element {@link #helpPanelView} should be placed
     * @return an instance of this class
     */
    public static HelpView load(Stage primaryStage, AnchorPane placeholder) {
        HelpView helpView = UiPartLoaderUtil.loadUiPart(primaryStage, placeholder, new HelpView());
        helpView.configureLayout();
        helpView.hideHelpPanel();
        return helpView;
    }

    /**
     * Configure the UI layout of {@link CommandErrorView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(helpPanelView, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(helpGrid, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Displays a list of commands into the helpPanelView
     */
    public void displayCommandSummaries(List<CommandSummary> commandSummaries) {
        this.showHelpPanel();
        helpGrid.getChildren().clear();
        int rowIndex = 0;
        for (CommandSummary commandSummary : commandSummaries) {
            appendCommandSummary(rowIndex++, commandSummary);
        }
    }

    /**
     * Add a command summary to each row of the helpGrid
     * @param rowIndex the row number to which the command summary should append to
     * @param commandSummary to be displayed
     */
    private void appendCommandSummary(int rowIndex, CommandSummary commandSummary) {
        Text commandScenario = ViewGeneratorUtil.constructText(commandSummary.scenario, ViewStyleUtil.STYLE_TEXT_4);
        Text commandName = ViewGeneratorUtil.constructText(commandSummary.command, ViewStyleUtil.STYLE_TEXT_4);
        Text commandArgument = ViewGeneratorUtil.constructText(" " + commandSummary.arguments, ViewStyleUtil.STYLE_TEXT_4);

        ViewStyleUtil.addClassStyles(commandArgument, ViewStyleUtil.STYLE_CODE);
        ViewStyleUtil.addClassStyles(commandName, ViewStyleUtil.STYLE_CODE, ViewStyleUtil.STYLE_BOLDER);

        TextFlow combinedCommand = ViewGeneratorUtil.placeIntoTextFlow(commandName, commandArgument);
        helpGrid.addRow(rowIndex, commandScenario, combinedCommand);
    }

    /* Ui Methods */
    public void hideHelpPanel() {
        FxViewUtil.setCollapsed(helpPanelView, true);
    }

    private void showHelpPanel() {
        FxViewUtil.setCollapsed(helpPanelView, false);
    }


    /* Override Methods */
    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeholder = placeholder;
    }

    @Override
    public void setNode(Node node) {
        this.helpPanelView = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\todo\ui\view\TaskCardView.java
``` java
/**
 * This class links up with TaskCardView.fxml layout to display details of a given ReadOnlyTask to users via the TaskListPanel.fxml.
 */
public class TaskCardView extends UiPart {
    /*Constants*/
    private static final String FXML = "TaskCardView.fxml";

    private static final String TASK_TYPE = "Task";
    private static final String EVENT_TYPE = "Event";

    /*Static Field*/
    /*
        Provides a global reference between an ImmutableTask to the wrapper TaskCardView class,
        since we have no direct access of TaskCardView from the ListView object.
     */
    private static final Map<ImmutableTask, TaskCardView> taskCardMap = new HashMap<>();
    
    /*Layout Declarations*/
    @FXML
    private VBox taskCard;
    @FXML
    private ImageView pinImage;
    @FXML
    private Label titleLabel;
    @FXML
    private Label typeLabel, moreInfoLabel;
    @FXML
    private Label descriptionLabel, dateLabel, locationLabel;
    @FXML
    private HBox descriptionBox, dateBox, locationBox;
    @FXML
    private FlowPane tagsBox;
    
    /* Variables */
    private ImmutableTask task;
    private int displayedIndex;
    private TimeUtil timeUtil = new TimeUtil();

    /* Default Constructor */
    private TaskCardView(){
    }

    /* Initialisation Methods */
    /**
     * Loads and initialise one cell of the task in the to-do list ListView.
     * @param task to be displayed on the cell
     * @param displayedIndex index to be displayed on the card itself to the user
     * @return an instance of this class
     */
    public static TaskCardView load(ImmutableTask task, int displayedIndex){
        TaskCardView taskListCard = new TaskCardView();
        taskListCard.task = task;
        taskListCard.displayedIndex = displayedIndex;
        taskCardMap.put(task, taskListCard);
        return UiPartLoaderUtil.loadUiPart(taskListCard);
    }

    /**
     * Initialise all the view elements in a task card.
     */
    @FXML
    public void initialize() {
        displayEverythingElse();
        displayTags();
        displayTimings();
        setStyle();
        setTimingAutoUpdate();
        initialiseCollapsibleView();
    }

    /**
     * Displays all other view elements, including title, type label, pin image, description and location texts.
     */
    private void displayEverythingElse() {
        titleLabel.setText(String.valueOf(displayedIndex) + ". " + task.getTitle());
        pinImage.setVisible(task.isPinned());
        typeLabel.setText(task.isEvent() ? EVENT_TYPE : TASK_TYPE);
        FxViewUtil.displayTextWhenAvailable(descriptionLabel, descriptionBox, task.getDescription());
        FxViewUtil.displayTextWhenAvailable(locationLabel, locationBox, task.getLocation());
    }
    
    /**
     * Displays the tags in lexicographical order, ignoring case.
     */
    private void displayTags(){
        List<Tag> tagList = new ArrayList<>(task.getTags());
        if (tagList.isEmpty()) {
            FxViewUtil.setCollapsed(tagsBox, true);
        } else {
            tagList.sort((o1, o2) -> o1.toString().compareToIgnoreCase(o2.toString()));
            for (Tag tag : tagList) {
                Label tagLabel = ViewGeneratorUtil.constructRoundedText(tag.getTagName());
                tagsBox.getChildren().add(tagLabel);
            }
        }
    }
    
    /**
     * Sets style according to the status (e.g. completed, overdue, etc) of the task.
     */
    private void setStyle() {
        boolean isCompleted = task.isCompleted();
        boolean isOverdue = task.getEndTime().isPresent() && timeUtil.isOverdue(task.getEndTime().get()) && !task.isEvent();
        boolean isOngoing = task.isEvent() && 
                            timeUtil.isOngoing(task.getStartTime().get(), task.getEndTime().get());
        
        if (isCompleted) {
            ViewStyleUtil.addClassStyles(taskCard, ViewStyleUtil.STYLE_COMPLETED);
        } else if (isOverdue) {
            ViewStyleUtil.addClassStyles(taskCard, ViewStyleUtil.STYLE_OVERDUE);
        } else if (isOngoing){
            ViewStyleUtil.addClassStyles(taskCard, ViewStyleUtil.STYLE_ONGOING);
        }
    }

    /**
     * Initialise the view to show collapsed state if it can be collapsed,
     * else hide the {@link #moreInfoLabel} otherwise.
     */
    private void initialiseCollapsibleView() {
        ViewStyleUtil.addRemoveClassStyles(true, taskCard, ViewStyleUtil.STYLE_COLLAPSED);
        FxViewUtil.setCollapsed(moreInfoLabel, !isTaskCollapsible());
        FxViewUtil.setCollapsed(tagsBox, isTaskCollapsible());
    }
    
    /**
     * Displays formatted task or event timings in the time field.
     */
    private void displayTimings() {
        String displayTimingOutput;
        Optional<LocalDateTime> startTime = task.getStartTime();
        Optional<LocalDateTime> endTime = task.getEndTime();
        boolean isEventWithTime = task.isEvent() && startTime.isPresent() && endTime.isPresent();
        boolean isTaskWithTime = !task.isEvent() && endTime.isPresent();
        
        if (isEventWithTime) {
            displayTimingOutput = timeUtil.getEventTimeText(startTime.get(), endTime.get());
        } else if (isTaskWithTime) {
            displayTimingOutput = timeUtil.getTaskDeadlineText(endTime.get());
        } else {
            FxViewUtil.setCollapsed(dateBox, true);
            return;
        }
        dateLabel.setText(displayTimingOutput);
    }

    /**
     * Allows timing, and deadline highlight style to be updated automatically.
     */
    private void setTimingAutoUpdate() {
        Timeline timeline = FxViewUtil.setRecurringUiTask(30, event -> {
            displayTimings();
            setStyle();
        });
        timeline.play();
    }

    /* Methods interfacing with UiManager*/
    /**
     * Toggles the task card's collapsed or expanded state, only if this card is collapsible.
     */
    public void toggleCardCollapsing() {
        if (isTaskCollapsible()) {
            //Sets both the collapsed style of the card, and mark the visibility of the "more" label.
            boolean isCollapsing = ViewStyleUtil.toggleClassStyle(taskCard, ViewStyleUtil.STYLE_COLLAPSED);
            FxViewUtil.setCollapsed(moreInfoLabel, !isCollapsing);
            FxViewUtil.setCollapsed(tagsBox, isCollapsing);
        }
    }

    /**
     * Displays in the Ui whether this card is selected
     * @param isSelected true when the card is selected
     */
    public void markAsSelected(boolean isSelected) {
        ViewStyleUtil.addRemoveClassStyles(isSelected, taskCard, ViewStyleUtil.STYLE_SELECTED);
    }

    /* Helper Methods */
    /**
     * Returns true if this task card can be collapsed, based on the information given from the {@link ImmutableTask}
     */
    private boolean isTaskCollapsible() {
        boolean hasDescription = task.getDescription().isPresent();
        boolean hasTags = !task.getTags().isEmpty();
        return hasDescription || hasTags;
    }

    /* Getters */
    /**
     * Gets the mapped {@link TaskCardView} object from an {@link ImmutableTask} object
     * @param task that is being wrapped by the {@link TaskCardView} object
     * @return a {@link TaskCardView} object that contains this task (can be null if not available)
     */
    public static TaskCardView getTaskCard(ImmutableTask task) {
        return taskCardMap.get(task);
    }

    public int getDisplayedIndex() {
        return displayedIndex;
    }

    public VBox getLayout() {
        return taskCard;
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        taskCard = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\todo\ui\view\TodoListView.java
``` java
/**
 * A panel that holds all the tasks inflated from TaskCardView.
 */
public class TodoListView extends UiPart {
    /*Constants*/
    private static final String FXML = "TodoListView.fxml";
    
    /*Variables*/
    private final Logger logger = LogsCenter.getLogger(TodoListView.class);
    private VBox panel;
    private AnchorPane placeHolderPane;
    
    /*Layout Declarations*/
    @FXML
    private ListView<ImmutableTask> todoListView;

    /**
     * Default Constructor for {@link TodoListView}
     */
    public TodoListView() {
        super();
    }

    /**
     * Loads and initialise the {@link TodoListView} to the placeHolder.
     *
     * @param primaryStage of the application
     * @param placeHolder where the view element {@link #todoListView} should be placed
     * @return an instance of this class
     */
    public static TodoListView load(Stage primaryStage, AnchorPane placeHolder,
                                    ObservableList<ImmutableTask> todoList) {
        
        TodoListView todoListView =
                UiPartLoaderUtil.loadUiPart(primaryStage, placeHolder, new TodoListView());
        todoListView.configure(todoList);
        return todoListView;
    }

    /**
     * Configures the {@link TodoListView}
     *
     * @param todoList A list of {@link ImmutableTask} to be displayed on this {@link #todoListView}.
     */
    private void configure(ObservableList<ImmutableTask> todoList) {
        setConnections(todoList);
    }

    /**
     * Links the list of {@link ImmutableTask} to the todoListView.
     *
     * @param todoList A list of {@link ImmutableTask} to be displayed on this {@link #todoListView}.
     */
    private void setConnections(ObservableList<ImmutableTask> todoList) {
        todoListView.setItems(todoList);
        todoListView.setCellFactory(param -> new TodoListViewCell());
    }

    /* Ui Methods */
    /**
     * Toggles the expanded/collapsed view of a task card.
     *
     * @param task The specific to be expanded or collapsed from view.
     */
    public void toggleExpandCollapsed(ImmutableTask task) {
        TaskCardView taskCardView = TaskCardView.getTaskCard(task);
        if (taskCardView != null) {
            taskCardView.toggleCardCollapsing();
        }
    }

    /**
     * Scrolls the {@link #todoListView} to the particular task card at the listIndex.
     */
    public void scrollAndSelect(int listIndex) {
        Platform.runLater(() -> {
            todoListView.scrollTo(listIndex);
            todoListView.getSelectionModel().clearAndSelect(listIndex);
        });
    }

    /**
     * Scrolls the {@link #todoListView} to the particular task card.
     *
     * @param task for the list to scroll to.
     */
    public void scrollAndSelect(ImmutableTask task) {
        TaskCardView taskCardView = TaskCardView.getTaskCard(task);
        int listIndex = FxViewUtil.convertToListIndex(taskCardView.getDisplayedIndex());
        scrollAndSelect(listIndex);
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    /**
     * Models a Task Card as a single ListCell of the ListView
     */
    private class TodoListViewCell extends ListCell<ImmutableTask> {

        /* Override Methods */
        @Override
        protected void updateItem(ImmutableTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                TaskCardView taskCardView = TaskCardView.load(task, FxViewUtil.convertToUiIndex(getIndex()));
                setGraphic(taskCardView.getLayout());
                setTaskCardStyleProperties(taskCardView);
            }
        }

        /**
         * Sets the style properties of a cell on the to-do list, that cannot be done in any other places.
         */
        private void setTaskCardStyleProperties(TaskCardView taskCardView) {
            this.setPadding(Insets.EMPTY);
            this.selectedProperty().addListener((observable, oldValue, newValue) -> taskCardView.markAsSelected(newValue));
        }
    }

}
```
###### \resources\style\DefaultStyle.css
``` css
.main {
    -fx-background-color: #2D2D2D;
    -fx-border-color: #00A4FF;
    -fx-border-width: 1px;
    -fx-padding: 12;
    -fx-spacing: 4;
}

.text1 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI Black";
    -fx-font-size: 17pt;
}

.text2 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI Semibold";
    -fx-font-size: 15pt;
}

.text3 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI Semibold";
    -fx-font-size: 13pt;
}

.text4 {
    -fx-text-fill: #FFFFFF;
    -fx-fill: #ffffff;
    -fx-font-family: "Segoe UI";
    -fx-font-size: 12pt;
}

.code {
    -fx-font-family: "Consolas";
}

.bolder {
    -fx-font-weight: bolder;
}

.underline {
    -fx-underline: true;
}

.gridPanel {
    -fx-hgap: 16pt;
    -fx-vgap: 2pt;
    -fx-background-color: #3D3D3D;
    -fx-padding: 8 8 8 8;
}

.spacingBig {
    -fx-spacing: 16px;
    -fx-hgap: 16px;
    -fx-vgap: 16px;
}

.spacing {
    -fx-spacing: 8px;
    -fx-hgap: 8px;
    -fx-vgap: 8px;
}

.spacingSmall {
    -fx-spacing: 2px;
    -fx-hgap: 2px;
    -fx-vgap: 2px;
}

.subheadingPadding {
    -fx-padding: 0 0 0 2;
}


.commandFeedback{
    -fx-text-fill: #FFFFFF;
    -fx-font-family: "Segoe UI";
    -fx-font-size: 12pt;
}

.commandFeedback.error {
    -fx-text-fill: #FF6464;
}

.commandInput {
    -fx-font-family: "Consolas";
    -fx-font-size: 20px;
}

.commandInput.error {
    -fx-border-color: #FF6464;
    -fx-border-width: 2px;
    -fx-text-fill: #FF6464;
}

.commandError {
    -fx-text-fill: #FFFFFF;
    -fx-font-family: "Segoe UI";
    -fx-font-size: 12pt;
    -fx-wrap-text: true;
}

.roundLabel {
    -fx-background-radius: 10;
    -fx-text-fill: #ffffff;
    -fx-background-color: #2D2D2D;
    -fx-font-size: 10pt;
    -fx-font-family: "Segoe UI Semilight";
}

/***View Filter Styles Start***/
.viewFilter .label{
    -fx-font-family: "Segoe UI";
    -fx-font-size: 14pt;
    -fx-text-fill: #FFFFFF;
}

.viewFilter .selected {
    -fx-background-color: #FFFFFF;
    -fx-background-radius: 100;
    -fx-padding: 0 8 0 8;
}

.viewFilter .selected .label {
    -fx-text-fill: #2D2D2D;
    -fx-font-family: "Segoe UI Semibold";
}

```
###### \resources\style\DefaultStyle.css
``` css
/***TaskCardView Styles Start***/
/*Default and Base*/
.taskCard .label {
    -fx-font-smoothing-type: lcd;
}

.taskCard .titleLabel {
    -fx-font-size: 16pt;
    -fx-font-family: "Segoe UI Semibold";
}

.taskCard .descriptionLabel {
    -fx-font-size: 12pt;
    -fx-font-family: "Segoe UI";
}

.taskCard .footnoteLabel {
    -fx-font-size: 10pt;
    -fx-font-family: "Segoe UI Semilight";
    -fx-font-style: italic;
}

.taskCard .highlightedBackground {
    -fx-background-color: #00A4FF;
}

.taskCard .lightBackground {
    -fx-background-color: #d2d2d2;
}

.taskCard .pinImage {
    -fx-image: url("../images/star_gold.png");
    -fx-fit-to-width: 30px;
    -fx-fit-to-height: 30px;
}

.taskCard .dateImage {
    -fx-image: url("../images/clock_black.png");
    -fx-fit-to-width: 20px;
    -fx-fit-to-height: 20px;
}

.taskCard .locationImage {
    -fx-image: url("../images/location_black.png");
    -fx-fit-to-width: 20px;
    -fx-fit-to-height: 20px;
}

/*Completed*/
.completed .label{
    -fx-text-fill: #7F7F7F;
}

.completed .titleLabel .text {
    -fx-strikethrough: true;
}

.completed .roundLabel {
    -fx-background-color: #7F7F7F;
    -fx-text-fill: #ffffff;
}

.completed .pinImage {
    -fx-image: url("../images/star_grey.png");
}

.completed .dateImage {
    -fx-image: url("../images/clock_grey.png");
}

.completed .locationImage {
    -fx-image: url("../images/location_grey.png");
}

/*Overdue*/
.overdue {
    -fx-background-color: #FF6464;
}

.overdue .label {
    -fx-text-fill: #FFFFFF;
}

.overdue .roundLabel {
    -fx-background-color: #FFFFFF;
    -fx-text-fill: #FF6464;
}

.overdue .pinImage {
    -fx-image: url("../images/star_white.png");
}

.overdue .dateImage {
    -fx-image: url("../images/clock_white.png");
}

.overdue .locationImage {
    -fx-image: url("../images/location_white.png");
}


```
###### \resources\style\DefaultStyle.css
``` css
/*Selected*/
.selected {
    -fx-background-color: #00A4FF;
}

.selected .label {
    -fx-text-fill: #FFFFFF;
}

.selected .roundLabel {
    -fx-background-color: #FFFFFF;
    -fx-text-fill: #00A4FF;
}

.selected .pinImage {
    -fx-image: url("../images/star_white.png");
}

.selected .dateImage {
    -fx-image: url("../images/clock_white.png");
}

.selected .locationImage {
    -fx-image: url("../images/location_white.png");
}

/*Collapse*/
.collapsed .collapsible {
    visibility: collapse;
    -fx-pref-height: 0px;
    -fx-min-height: 0px;
}

/***TaskCardView Styles End***/

```
