# A0135817B
###### \java\seedu\todo\commons\util\StringUtil.java
``` java
    /**
     * Returns true if the string is null, of length zero, or contains only whitespace 
     */
    public static boolean isEmpty(String s) {
        return s == null || s.length() == 0 || CharMatcher.whitespace().matchesAllOf(s);
    }

```
###### \java\seedu\todo\commons\util\TimeUtil.java
``` java
    /**
     * Translates input string from International date format (DD/MM/YYYY) to American
     * date format (MM/DD/YYYY), because Natty only recognizes the later 
     */
    public static String toAmericanDateFormat(String input) {
        return DATE_REGEX.matcher(input).replaceAll("$3$2$1");
    }
    
```
###### \java\seedu\todo\logic\arguments\Argument.java
``` java
abstract public class Argument<T> implements Parameter {
    private static final String REQUIRED_ERROR_FORMAT = "The %s parameter is required";
    private static final String TYPE_ERROR_FORMAT = "The %s should be a %s. You gave '%s'.";
    
    protected static final String OPTIONAL_ARGUMENT_FORMAT = "[%s]";
    protected static final String FLAG_ARGUMENT_FORMAT = "%s%s %s";
    
    private String name;
    private String description;
    private String flag;
    private boolean optional = true;
    private boolean boundValue = false;
    
    protected T value;
    
    private String requiredErrorMessage;
    
    private static final Logger logger = LogsCenter.getLogger(Argument.class);
    
    public Argument(String name) {
        this.name = name;
    }
    
    public Argument(String name, T defaultValue) {
        this.name = name;
        this.value = defaultValue;
    }
    
    /**
     * Binds a value to this parameter. Implementing classes MUST override AND 
     * call the parent class function so that the dirty bit is set for required
     * parameter validation to work
     */
    @Override
    public void setValue(String input) throws IllegalValueException {
        boundValue = true;
    }
    
    public T getValue() {
        return value;
    }
    
    @Override
    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public Argument<T> description(String description) {
        this.description = description;
        return this;
    }

    public String getFlag() {
        return flag;
    }
    
    public Argument<T> flag(String flag) {
        this.flag = flag.trim().toLowerCase();
        
        if (!this.flag.equals(flag)) {
            logger.warning("Flag argument has uppercase or whitespace characters. These have been ignored.");
        }
        
        return this;
    }

    public boolean isOptional() {
        return optional;
    }
    
    public boolean hasBoundValue() {
        return boundValue;
    }
    
    /**
     * Sets the field as required
     */
    public Argument<T> required() {
        this.optional = false;
        return this;
    }
    
    /**
     * Sets the field as required and specify an error message to show if it is not provided
     * @param errorMessage shown to the user when the parameter is not provided 
     */
    public Argument<T> required(String errorMessage) {
        requiredErrorMessage = errorMessage;
        this.optional = false;
        return this;
    }
    
    @Override
    public boolean isPositional() {
        return flag == null;
    }
    
    @Override
    public void checkRequired() throws IllegalValueException {
        if (!isOptional() && !hasBoundValue()) {
            String error = requiredErrorMessage == null ? 
                    String.format(Argument.REQUIRED_ERROR_FORMAT, name) : requiredErrorMessage;
            throw new IllegalValueException(error);
        }
    }

    /**
     * Throws an IllegalValueException for a type mismatch between user input and what 
     * the argument expect 
     * @param field     name of the argument 
     * @param expected  the expected type for the argument 
     * @param actual    what the user actually gave 
     */
    protected void typeError(String field, String expected, String actual) throws IllegalValueException {
        throw new IllegalValueException(String.format(Argument.TYPE_ERROR_FORMAT, field, expected, actual));
    }
    
    @Override
    public String toString() {
        return toString(name);
    }
    
    public String toString(String name) {
        if (!isPositional()) {
            name = String.format(FLAG_ARGUMENT_FORMAT, TodoParser.FLAG_TOKEN, flag, name);
        }

        if (isOptional()) {
            name = String.format(OPTIONAL_ARGUMENT_FORMAT, name);
        }

        return name;
    }
}
```
###### \java\seedu\todo\logic\arguments\DateRange.java
``` java
/**
 * Utility container class for the output from DateRangeArgument
 */
public class DateRange {
    private final LocalDateTime endTime; 
    private LocalDateTime startTime;
    
    public DateRange(LocalDateTime endTime) {
        this.endTime = endTime;
    }
    
    public DateRange(LocalDateTime startTime, LocalDateTime endTime) {
        this(endTime);
        this.startTime = startTime;
    }

    public LocalDateTime getEndTime() {
        return endTime;
    }

    public LocalDateTime getStartTime() {
        return startTime;
    }
    
    public boolean isRange() {
        return startTime != null;
    }
}
```
###### \java\seedu\todo\logic\arguments\DateRangeArgument.java
``` java
public class DateRangeArgument extends Argument<DateRange> {
    private static final PrettyTimeParser parser = new PrettyTimeParser();
    private static final TimeUtil timeUtil = new TimeUtil();
    
    // TODO: Review all error messages to check for user friendliness 
    private static final String TOO_MANY_DATES_FORMAT = "You specified too many time - we found: %s";
    private static final String NO_DATE_FOUND_FORMAT = "%s does not seem to contain a date";
    
    public DateRangeArgument(String name) {
        // Makes sure that there is a default value, so that callers won't get null when they getValue()
        super(name, new DateRange(null));
    }

    public DateRangeArgument(String name, DateRange defaultValue) {
        super(name, defaultValue);
    }
    
    @Override
    public void setValue(String input) throws IllegalValueException {
        super.setValue(input);
        
        if (StringUtil.isEmpty(input)) {
            return;
        }
        
        input = TimeUtil.toAmericanDateFormat(input);
        List<Date> dateGroups = parser.parse(input);
        
        List<LocalDateTime> dates = dateGroups.stream()
            .map(TimeUtil::asLocalDateTime)
            .sorted()
            .collect(Collectors.toList());

        if (dates.size() > 2) {
            tooManyDatesError(dates);
        } else if (dates.size() == 0) {
            throw new IllegalValueException(String.format(DateRangeArgument.NO_DATE_FOUND_FORMAT, input));
        }
        
        if (dates.size() == 1) {
            value = new DateRange(dates.get(0));
        } else {
            value = new DateRange(dates.get(0), dates.get(1));
        }
    }
    
    private void tooManyDatesError(List<LocalDateTime> dates) throws IllegalValueException {
        StringJoiner sj = new StringJoiner(", ");
        for (LocalDateTime d : dates) {
            sj.add(timeUtil.getTaskDeadlineText(d));
        }
        String message = String.format(DateRangeArgument.TOO_MANY_DATES_FORMAT, sj.toString());
        throw new IllegalValueException(message);
    }
    
}
```
###### \java\seedu\todo\logic\arguments\FlagArgument.java
``` java
public class FlagArgument extends Argument<Boolean> {

    public FlagArgument(String name) {
        super(name);
        flag(name.substring(0, 1).toLowerCase());
        this.value = false;
    }

    public FlagArgument(String name, boolean defaultValue) {
        super(name, defaultValue);
        flag(name.substring(0, 1).toLowerCase());
    }

    @Override
    public void setValue(String input) throws IllegalValueException {
        this.value = true;
        super.setValue(input);
    }
    
    @Override
    public String toString(String name) {
        String flag = TodoParser.FLAG_TOKEN + getFlag();
        return isOptional() ? String.format(Argument.OPTIONAL_ARGUMENT_FORMAT, flag) : flag;
    }
}
```
###### \java\seedu\todo\logic\arguments\IntArgument.java
``` java
public class IntArgument extends Argument<Integer> {

    public IntArgument(String name) {
        super(name);
    }
    
    public IntArgument(String name, int defaultValue) {
        super(name, defaultValue);
    }

    @Override
    public void setValue(String input) throws IllegalValueException {
        try {
            value = Integer.parseInt(input);
            super.setValue(input);
        } catch (NumberFormatException e) {
            typeError(this.getName(), "integer", input);
        }
    }

}
```
###### \java\seedu\todo\logic\arguments\Parameter.java
``` java
/**
 * Represents a single command parameter that the parser will try to feed the user 
 * input into. The Parameter interface is needed because the Argument base class is 
 * typed, so this interface contains all of the non-typed methods that are common to 
 * all argument subclasses
 */
public interface Parameter {
    void setValue(String input) throws IllegalValueException;
    
    boolean isPositional();
    
    boolean hasBoundValue();
    
    boolean isOptional();
    
    String getFlag();
    
    String getName();
    
    String getDescription();
    
    void checkRequired() throws IllegalValueException;
}
```
###### \java\seedu\todo\logic\arguments\StringArgument.java
``` java
public class StringArgument extends Argument<String> {

    public StringArgument(String name) {
        super(name);
    }
    
    public StringArgument(String name, String defaultValue) {
        super(name, defaultValue);
    }

    @Override
    public void setValue(String input) throws IllegalValueException {
        input = input.trim();
        
        // Ignore empty strings
        if (input.length() > 0) {
            this.value = input;
        }
        
        super.setValue(input);
    }

}
```
###### \java\seedu\todo\logic\commands\AddCommand.java
``` java
public class AddCommand extends BaseCommand {
    private static final String VERB = "added";
    
    private Argument<String> title = new StringArgument("title").required();
    
    private Argument<String> description = new StringArgument("description")
            .flag("m");
    
    private Argument<Boolean> pin = new FlagArgument("pin")
            .flag("p");
    
    private Argument<String> location = new StringArgument("location")
            .flag("l");
    
    private Argument<DateRange> date = new DateRangeArgument("deadline")
            .flag("d");

    @Override
    public Parameter[] getArguments() {
        return new Parameter[] {
            title, date, description, location, pin,
        };
    }

    @Override
    public String getCommandName() {
        return "add";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        String eventArguments = Joiner.on(" ").join(title, "/d start and end time", description, location, pin);
        
        return ImmutableList.of(
            new CommandSummary("Add task", getCommandName(), getArgumentSummary()), 
            new CommandSummary("Add event", getCommandName(), eventArguments));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        ImmutableTask addedTask = this.model.add(title.getValue(), task -> {
            task.setDescription(description.getValue());
            task.setPinned(pin.getValue());
            task.setLocation(location.getValue());
            task.setStartTime(date.getValue().getStartTime());
            task.setEndTime(date.getValue().getEndTime());
        });
        if(!model.getObservableList().contains(addedTask)) {
            model.view(TaskViewFilter.DEFAULT);
        }
        eventBus.post(new HighlightTaskEvent(addedTask));
        eventBus.post(new ExpandCollapseTaskEvent(addedTask));
        return taskSuccessfulResult(title.getValue(), AddCommand.VERB);
    }

}
```
###### \java\seedu\todo\logic\commands\BaseCommand.java
``` java
/**
 * The base class for commands. All commands need to implement an execute function 
 * and a getArguments function that collects the command arguments for the use of 
 * the help command. 
 * 
 * To perform additional validation on incoming arguments, override the validateArguments 
 * function.
 */
public abstract class BaseCommand {
    /**
     * The default message that accompanies argument errors
     */
    private static final String DEFAULT_ARGUMENT_ERROR_MESSAGE = ""; 
    
    private static final String TASK_MODIFIED_SUCCESS_MESSAGE = "'%s' successfully %s!";
    
    protected static final EventsCenter eventBus = EventsCenter.getInstance();

    protected Model model;
    
    protected ErrorBag errors = new ErrorBag(); 
    
    abstract protected Parameter[] getArguments();

    /**
     * Return the name of the command, which is used to call it
     */
    abstract public String getCommandName();

    /**
     * Returns a list of command summaries for the command. This function returns a 
     * list because commands may (rarely) be responsible for more than one thing, 
     * like the <code>add</code> command. 
     */
    abstract public List<CommandSummary> getCommandSummary();
    
    abstract public CommandResult execute() throws ValidationException;
    
    /**
     * Binds the data model to the command object
     */
    public void setModel(Model model) {
        this.model = model;
    }

    /**
     * Binds the both positional and named command arguments from the parse results 
     * to the command object itself 
     * 
     * @throws ValidationException if the arguments are invalid
     */
    public void setArguments(ParseResult arguments) throws ValidationException {
        if (arguments.getPositionalArgument().isPresent()) {
            setPositionalArgument(arguments.getPositionalArgument().get());
        }
        
        for (Entry<String, String> e : arguments.getNamedArguments().entrySet()) {
            setNameArgument(e.getKey(), e.getValue());
        }
        
        checkRequiredArguments();
        validateArguments();
        
        errors.validate(getArgumentErrorMessage());
    }
    
    /**
     * Hook allowing subclasses to implement their own validation logic for arguments
     * Subclasses should add additional errors to the errors ErrorBag
     */
    protected void validateArguments() {
        // Does no additional validation by default 
    }
    
    protected void setPositionalArgument(String argument) {
        for (Parameter p : getArguments()) {
            if (p.isPositional()) {
                try {
                    p.setValue(argument);
                } catch (IllegalValueException e) {
                    errors.put(e.getMessage());
                }
            }
        }
    }
    
    protected void setNameArgument(String flag, String argument) {
        for (Parameter p : getArguments()) {
            if (flag.equals(p.getFlag())) {
                try {
                    p.setValue(argument);
                } catch (IllegalValueException e) {
                    errors.put(p.getName(), e.getMessage());
                }
                
                return;
            }
        }
        
        // TODO: Do something for unrecognized argument?
    }
    
    private void checkRequiredArguments() {
        for (Parameter p : getArguments()) {
            try {
                p.checkRequired();
            } catch (IllegalValueException e) {
                errors.put(p.getName(), e.getMessage());
            }
        }
    }

    /**
     * Override this function if the command should return some other error 
     * message on argument validation error 
     */
    protected String getArgumentErrorMessage() {
        return BaseCommand.DEFAULT_ARGUMENT_ERROR_MESSAGE;
    }

    /**
     * Returns a generic CommandResult with a "{task} successfully {verbed}" success message. 
     * 
     * @param title the title of the task that was verbed on 
     * @param verb the action that was performed on the task, in past tense
     */
    protected CommandResult taskSuccessfulResult(String title, String verb) {
        return new CommandResult(String.format(BaseCommand.TASK_MODIFIED_SUCCESS_MESSAGE, title, verb));
    }

    /**
     * Turns the arguments into a string summary using their toString function
     */
    protected String getArgumentSummary() {
        StringJoiner sj = new StringJoiner(" ");
        for (Parameter p : getArguments()) {
            sj.add(p.toString());
        }
        return sj.toString();
    }
}
```
###### \java\seedu\todo\logic\commands\CommandMap.java
``` java
public class CommandMap {
    // List of command classes. Remember to register new commands here so that the
    // dispatcher can recognize them
    public static List<Class<? extends BaseCommand>> commandClasses = ImmutableList.of(
        AddCommand.class,
        CompleteCommand.class,
        DeleteCommand.class,
        EditCommand.class,
        ExitCommand.class,
        HelpCommand.class,
        PinCommand.class,
        UndoCommand.class,
        RedoCommand.class,
        SaveCommand.class,
        LoadCommand.class,
        ShowCommand.class,
        FindCommand.class,
        ViewCommand.class,
        TagCommand.class
    );
    
    private static Map<String, Class<? extends BaseCommand>> commandMap;
    
    private static void buildCommandMap() {
        commandMap = new LinkedHashMap<>();
        
        for (Class<? extends BaseCommand> command : CommandMap.commandClasses) {
            String commandName = getCommand(command).getCommandName().toLowerCase();
            commandMap.put(commandName, command);
        }
    }

    public static Map<String, Class<? extends BaseCommand>> getCommandMap() {
        if (commandMap == null) {
            buildCommandMap();
        }
        
        return commandMap;
    }
    
    public static BaseCommand getCommand(String key) {
        return getCommand(getCommandMap().get(key));
    }
    
    public static BaseCommand getCommand(Class<? extends BaseCommand> command) {
        try {
            return command.newInstance();
        } catch (InstantiationException|IllegalAccessException e) {
            e.printStackTrace();
            return null; // This shouldn't happen
        }
    }
}
```
###### \java\seedu\todo\logic\commands\CommandResult.java
``` java
/**
 * Represents the result of a command execution.
 */
public class CommandResult {
    private final String feedback;
    private final ErrorBag errors; 
    
    public CommandResult() {
        this.feedback = "";
        this.errors = null;
    }
    
    public CommandResult(String feedback) {
        this.feedback = feedback;
        this.errors = null;
    }
    
    public CommandResult(String feedback, ErrorBag errors) {
        this.feedback = feedback;
        this.errors = errors;
    }

    public String getFeedback() {
        return feedback;
    }

    public ErrorBag getErrors() {
        return errors;
    }
    
    public boolean isSuccessful() {
        return errors == null;
    }
}
```
###### \java\seedu\todo\logic\commands\CommandSummary.java
``` java
public class CommandSummary {
    /**
     * The scenario the summary is aiming to describe, eg. add event, delete task, etc. 
     * Keep it short but descriptive. 
     */
    public final String scenario;

    /**
     * The command to accomplish the scenario, eg. add, delete 
     */
    public final String command;

    /**
     * The parameters for the command
     */
    public final String arguments;
    
    public CommandSummary(String scenario, String command) {
        this(scenario, command, "");
    }
    
    public CommandSummary(String scenario, String command, String arguments) {
        this.scenario = scenario.trim();
        this.command = command.toLowerCase().trim();
        this.arguments = arguments.trim();
    }
}
```
###### \java\seedu\todo\logic\commands\DeleteCommand.java
``` java
public class DeleteCommand extends BaseCommand {
    private static final String VERB = "deleted";
    
    private Argument<Integer> index = new IntArgument("index").required();

    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{ index };
    }

    @Override
    public String getCommandName() {
        return "delete";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Delete task", getCommandName(), 
            getArgumentSummary()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        ImmutableTask deletedTask = this.model.delete(index.getValue());
        return taskSuccessfulResult(deletedTask.getTitle(), DeleteCommand.VERB);
    }
}
```
###### \java\seedu\todo\logic\commands\ExitCommand.java
``` java
/**
 * Terminates the program.
 */
public class ExitCommand extends BaseCommand {
    private final static String EXIT_MESSAGE = "Goodbye!";
    
    @Override
    public CommandResult execute() throws ValidationException {
        EventsCenter.getInstance().post(new ExitAppRequestEvent());
        return new CommandResult(ExitCommand.EXIT_MESSAGE);
    }

    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{};
    }

    @Override
    public String getCommandName() {
        return "exit";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Close this app :(", getCommandName()));
    }

}
```
###### \java\seedu\todo\logic\commands\HelpCommand.java
``` java
/**
 * Shows the help panel
 */
public class HelpCommand extends BaseCommand {
    private final static String HELP_MESSAGE = "Showing help...";
    
    private static List<CommandSummary> commandSummaries;

    @Override
    public CommandResult execute() throws ValidationException {
        if (commandSummaries == null) {
            commandSummaries = collectCommandSummaries();
        }
        
        EventsCenter.getInstance().post(new ShowHelpEvent(commandSummaries));
        return new CommandResult(HelpCommand.HELP_MESSAGE);
    }

    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{};
    }

    @Override
    public String getCommandName() {
        return "help";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Show help", getCommandName()));
    }
    
    private List<CommandSummary> collectCommandSummaries() {
        List<CommandSummary> summaries = new ArrayList<>();
        for (String key : CommandMap.getCommandMap().keySet()) {
            summaries.addAll(CommandMap.getCommand(key).getCommandSummary());
        }
        return summaries;
    }
}
```
###### \java\seedu\todo\logic\commands\LoadCommand.java
``` java
public class LoadCommand extends BaseCommand {
    private Argument<String> location = new StringArgument("location").required();
    
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{ location };
    }

    @Override
    public String getCommandName() {
        return "load";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Load todo list from file", getCommandName(), 
            getArgumentSummary()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        String path = location.getValue();
        model.load(path);
        return new CommandResult(String.format("File loaded from %s", path));
    }
}
```
###### \java\seedu\todo\logic\commands\RedoCommand.java
``` java
public class RedoCommand extends BaseCommand {
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[0];
    }

    @Override
    public String getCommandName() {
        return "redo";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Redo", getCommandName()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        model.redo();
        return new CommandResult("Redid last action");
    }
}
```
###### \java\seedu\todo\logic\commands\SaveCommand.java
``` java
/**
 * Saves the save file to a different location 
 */
public class SaveCommand extends BaseCommand {
    private Argument<String> location = new StringArgument("location");
    
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{ location };
    }

    @Override
    public String getCommandName() {
        return "save";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(
            new CommandSummary("Save to a different file", getCommandName(), "location"), 
            new CommandSummary("Find my todo list file", getCommandName()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        if (location.hasBoundValue()) {
            model.save(location.getValue());
            
            return new CommandResult(String.format("Todo list saved successfully to %s", location));
        } else {
            return new CommandResult(String.format("Save location: %s", model.getStorageLocation()));
        }
    }
}
```
###### \java\seedu\todo\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends BaseCommand {
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[0];
    }

    @Override
    public String getCommandName() {
        return "undo";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Undo last edit", getCommandName()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        model.undo();
        return new CommandResult("Undid last action");
    }
}
```
###### \java\seedu\todo\logic\Dispatcher.java
``` java
public interface Dispatcher {
    BaseCommand dispatch(String command) throws IllegalValueException;
}
```
###### \java\seedu\todo\logic\Logic.java
``` java
/**
 * API of the Logic component
 */
public interface Logic {
    /**
     * Executes the command and returns the result.
     * @param input The command as entered by the user.
     */
    CommandResult execute(String input);

```
###### \java\seedu\todo\logic\TodoDispatcher.java
``` java
/**
 * Selects the correct command based on the parser results
 */
public class TodoDispatcher implements Dispatcher {
    private final static String COMMAND_NOT_FOUND_FORMAT = "'%s' doesn't look like any command we know.";
    private final static String AMBIGUOUS_COMMAND_FORMAT = "Do you mean %s?";
    
    public BaseCommand dispatch(String input) throws IllegalValueException {
        // Implements character by character matching of input to the list of command names
        // Since this eliminates non-matches at every character, it is fast even though 
        // it is theoretically O(n^2) in the worst case.
        Set<String> commands = new HashSet<>(CommandMap.getCommandMap().keySet());
        
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);

            Iterator<String> s = commands.iterator();
            while (s.hasNext()) {
                String commandName = s.next();
                if (input.length() > commandName.length() || commandName.charAt(i) != c) {
                    s.remove();
                }
            }
            
            // Return immediately when there's one match left. This allow the user to 
            // type as little as possible, and is also good for autocomplete if that's 
            // on the radar
            if (commands.size() == 1) {
                String key = commands.iterator().next();
                return CommandMap.getCommand(key);
            } else if (commands.isEmpty()) {
                throw new IllegalValueException(String.format(TodoDispatcher.COMMAND_NOT_FOUND_FORMAT, input));
            }
        }
        
        String ambiguousCommands = Joiner.on(" or ").join(commands);
        throw new IllegalValueException(String.format(TodoDispatcher.AMBIGUOUS_COMMAND_FORMAT, ambiguousCommands));
    }
}
```
###### \java\seedu\todo\logic\TodoLogic.java
``` java
/**
 * Central controller for the application, abstracting application logic from the UI
 */
public class TodoLogic implements Logic {
    private final Parser parser;
    private final Model model;
    private final Dispatcher dispatcher;
    
    private static final Logger logger = LogsCenter.getLogger(TodoLogic.class);
    
    public TodoLogic(Parser parser, Model model, Dispatcher dispatcher) {
        assert parser != null;
        assert model != null;
        assert dispatcher != null;
        
        this.parser = parser;
        this.model = model;
        this.dispatcher = dispatcher;
    }
    
    public CommandResult execute(String input) {
        // Sanity check - input should not be empty 
        if (StringUtil.isEmpty(input)) {
            return new CommandResult();
        }
        
        ParseResult parseResult = parser.parse(input);
        BaseCommand command;
        logger.fine("Parsed command: " + parseResult.toString());
        
        try {
            command = dispatcher.dispatch(parseResult.getCommand());
        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage(), new ErrorBag());
        }
        
        try {
            command.setArguments(parseResult);
            command.setModel(model);
            return command.execute();
        } catch (ValidationException e) {
            logger.info(e.getMessage());
            return new CommandResult(e.getMessage(), e.getErrors());
        }
    }

```
###### \java\seedu\todo\model\ErrorBag.java
``` java
public class ErrorBag {
    private List<String> nonFieldErrors = new ArrayList<>();
    private Map<String, String> fieldErrors = new HashMap<>();
    
    /**
     * Add an error that is not related to any specific field
     * 
     * @param nonFieldError the error message
     */
    public void put(String nonFieldError) {
        nonFieldErrors.add(nonFieldError);
    }
    
    /**
     * Add an error that is related to a specific field 
     * 
     * @param field the error is for
     * @param error the error message 
     */
    public void put(String field, String error) {
        fieldErrors.put(field, error);
    }
    
    public List<String> getNonFieldErrors() {
        return nonFieldErrors;
    }
    
    public Map<String, String> getFieldErrors() {
        return fieldErrors;
    }
    
    public int size() {
        return nonFieldErrors.size() + fieldErrors.size();
    }
    
    /**
     * Throws a validation exception if the bag contains errors 
     * 
     * @param message a short message about why the validation failed
     * @throws ValidationException if the ErrorBag is not empty
     */
    public void validate(String message) throws ValidationException {
        if (size() > 0) {
            throw new ValidationException(message, this);
        }
    }
}
```
###### \java\seedu\todo\model\ImmutableTodoList.java
``` java
public interface ImmutableTodoList {
    /**
     * Get an immutable list of tasks 
     */
    List<ImmutableTask> getTasks();
}
```
###### \java\seedu\todo\model\Model.java
``` java
public interface Model {
    /**
     * Adds a new task or event with title only to the todo list.
     *
     * @param title  the title of the task
     * @return the task that was just created 
     * @throws IllegalValueException if the values set in the update predicate is invalid
     */
    ImmutableTask add(String title) throws IllegalValueException;

    /**
     * Adds a new task or event with title and other fields to the todo list.
     *
     * @param title   the title of the task 
     * @param update  a {@link MutableTask} is passed into this lambda. All other fields 
     *                should be set from inside this lambda. 
     * @return the task that was just created
     * @throws ValidationException   if the fields in the task to be updated are not valid
     */
    ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException;

    /**
     * Deletes the given task from the todo list. This change is also propagated to the 
     * underlying persistence layer.  
     *
     * @param index  the 1-indexed position of the task that needs to be deleted
     * @return the task that was just deleted
     * @throws ValidationException if the task does not exist
     */
    ImmutableTask delete(int index) throws ValidationException;

    /**
     * Replaces certain fields in the task. Mutation of the {@link Task} object should 
     * only be done in the <code>update</code> lambda. The lambda takes in one parameter, 
     * a {@link MutableTask}, and does not expect any return value. For example: 
     *
     * <pre><code>todo.update(task, t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline back by 2h
     *     t.setPin(true); // Pin this task
     * });</code></pre>
     *
     * @return the task that was just updated
     *
     * @throws ValidationException    if the task does not exist or if the fields in the 
     *                                task to be updated are not valid
     */
    ImmutableTask update(int index, Consumer<MutableTask> update) throws ValidationException;
    
    /**
     * Carries out the specified update in the fields of all visible tasks. Mutation of all {@link Task}
     * objects should only be done in the <code>update</code> lambda. The lambda takes in a single parameter,
     * a {@link MutableTask}, and does not expect any return value, as per the {@link update} command. Since
     * this represents the observable layer, the changes required to be done to the underlying layer TodoList
     * is set via getting a list of their indices in the underlying layer using a UUID map.  
     * 
     * <pre><code>todo.updateAll (t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline of all Observable tasks back by 2h
     *     t.setPin(true); // Pin all tasks in Observable view
     * });</code></pre>
     * 
     * @throws ValidationException if any updates on any of the task objects are considered invalid
     */
    void updateAll(Consumer <MutableTask> update) throws ValidationException;

    /**
     * Sets the model to the provided TaskViewFilter object. TaskViewFilters represents the
     * filter and sorting needed by each intelligent view
     */
    void view(TaskViewFilter view);

    /**
     * Filters the list of tasks by this predicate. This is filtering is ran
     * after the view predicate. No information about the search is shown to the user.
     * Setting predicate to null will reset the search.
     */
    void find(Predicate<ImmutableTask> predicate);

    /**
     * Filters the list of tasks by this predicate. This is filtering is ran
     * after the view predicate. A list of search terms is also shown to the user.
     */
    void find(Predicate<ImmutableTask> predicate, List<String> terms);

    /**
     * Undoes the last operation that modifies the todolist
     * @throws ValidationException if there are no more changes to undo
     */
    void undo() throws ValidationException;

    /**
     * Redoes the last operation that was undone
     * @throws ValidationException if there are no more changes to redo
     */
    void redo() throws ValidationException;
    
    /**
     * Changes the save path of the TodoList storage 
     * @throws ValidationException if the path is not valid
     */
    void save(String location) throws ValidationException;

    /**
     * Loads a TodoList from the path. 
     * @throws ValidationException if the path or file is invalid
     */
    void load(String location) throws ValidationException;

    /**
     * Obtains the current storage methods 
     */
    String getStorageLocation();

    /**
     * Get an observable list of tasks. Used mainly by the JavaFX UI. 
     */
    UnmodifiableObservableList<ImmutableTask> getObservableList();

    /**
     * Get the current view filter used on the model. Used mainly by the JavaFx UI. 
     */
    ObjectProperty<TaskViewFilter> getViewFilter();

    /**
     * Get the current status of the search used on the model.
     */
    ObjectProperty<SearchStatus> getSearchStatus();

```
###### \java\seedu\todo\model\TodoList.java
``` java
/**
 * Represents the todolist inside memory. While Model works as the external 
 * interface for handling data and application state, this class is internal 
 * to Model and represents only CRUD operations to the todolist. 
 */
public class TodoList implements TodoListModel {
    private static final String INCORRECT_FILE_FORMAT_FORMAT = "%s doesn't seem to be in the correct format.";
    private static final String FILE_NOT_FOUND_FORMAT = "%s does not seem to exist.";
    private static final String FILE_SAVE_ERROR_FORMAT = "Couldn't save file: %s";

    private ObservableList<Task> tasks = FXCollections.observableArrayList(Task::getObservableProperties);

    private MovableStorage<ImmutableTodoList> storage;

    private static final Logger logger = LogsCenter.getLogger(TodoList.class);
    private static final EventsCenter events = EventsCenter.getInstance();

    public TodoList(MovableStorage<ImmutableTodoList> storage) {
        this.storage = storage;
        
        try {
            setTasks(storage.read().getTasks(), false);
        } catch (FileNotFoundException | DataConversionException e) {
            logger.info("Data file not found. Will be starting with an empty TodoList");
        }
        
        // Update event status 
        new Timer().scheduleAtFixedRate(new UpdateEventTask(), 0, 60 * 1000);
    }
    
    private void updateEventStatus() {
        LocalDateTime now = LocalDateTime.now();
        boolean todoListModified = false;
        
        for (Task task : tasks) {
            boolean isIncompleteEvent = !task.isCompleted() && task.isEvent();
            if (isIncompleteEvent && now.isAfter(task.getEndTime().get())) {
                task.setCompleted(true);
                todoListModified = true;
            }
        }
        if (todoListModified) {
            saveTodoList();
        }
    }

    private void raiseStorageEvent(String message, Exception e) {
        // TODO: Have this raise an event
    }
    
    private void saveTodoList() {
        try {
            storage.save(this);
        } catch (IOException e) {
            events.post(new DataSavingExceptionEvent(e));
        }
    }

```
###### \java\seedu\todo\model\TodoList.java
``` java
    @Override
    public void save(String location) throws ValidationException {
        try {
            storage.save(this, location);
        } catch (IOException e) {
            String message = String.format(TodoList.FILE_SAVE_ERROR_FORMAT, e.getMessage());
            throw new ValidationException(message);
        }
    }

    @Override
    public void load(String location) throws ValidationException {
        try {
            setTasks(storage.read(location).getTasks());
        } catch (DataConversionException e) {
            throw new ValidationException(TodoList.INCORRECT_FILE_FORMAT_FORMAT);
        } catch (FileNotFoundException e) {
            String message = String.format(TodoList.FILE_NOT_FOUND_FORMAT, location);
            throw new ValidationException(message);
        }
    }

    @Override
    public void setTasks(List<ImmutableTask> todoList) {
        setTasks(todoList, true);
    }

    /**
     * We have a private version of setTasks because we also need to setTask during initialization, 
     * but we don't want the list to be save during init (where we presumably got the data from)
     */
    private void setTasks(List<ImmutableTask> todoList, boolean persistToStorage) {
        this.tasks.clear();
        this.tasks.addAll(todoList.stream().map(Task::new).collect(Collectors.toList()));
        
        if (persistToStorage) {
            saveTodoList();
        }
    }

    @Override
    public ObservableList<ImmutableTask> getObservableList() {
        return new UnmodifiableObservableList<>(tasks);
    }

    @Override
    public List<ImmutableTask> getTasks() {
        return Collections.unmodifiableList(tasks);
    }
    
    private class UpdateEventTask extends TimerTask {
        @Override
        public void run() {
            updateEventStatus();
        }
    }

}
```
###### \java\seedu\todo\model\TodoListModel.java
``` java
public interface TodoListModel extends ImmutableTodoList {
    /**
     * Adds a new task or event with title only to the todo list.
     *
     * @param title  the title of the task
     * @return the task that was just created 
     * @throws IllegalValueException if the values set in the update predicate is invalid
     */
    ImmutableTask add(String title) throws IllegalValueException;

    /**
     * Adds a new task or event with title and other fields to the todo list.
     *
     * @param title   the title of the task 
     * @param update  a {@link MutableTask} is passed into this lambda. All other fields 
     *                should be set from inside this lambda. 
     * @return the task that was just created
     * @throws ValidationException   if the fields in the task to be updated are not valid
     */
    ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException;

    /**
     * Deletes the given task from the todo list. This change is also propagated to the 
     * underlying persistence layer.  
     *
     * @param index  the 1-indexed position of the task that needs to be deleted
     * @return the task that was just deleted
     * @throws ValidationException if the task does not exist
     */
    ImmutableTask delete(int index) throws ValidationException;

    /**
     * Replaces certain fields in the task. Mutation of the {@link Task} object should 
     * only be done in the <code>update</code> lambda. The lambda takes in one parameter, 
     * a {@link MutableTask}, and does not expect any return value. For example: 
     *
     * <pre><code>todo.update(task, t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline back by 2h
     *     t.setPin(true); // Pin this task
     * });</code></pre>
     *
     * @return the task that was just updated
     *
     * @throws ValidationException    if the task does not exist or if the fields in the 
     *                                task to be updated are not valid
     */
    ImmutableTask update(int index, Consumer<MutableTask> update) throws ValidationException;
    
```
###### \java\seedu\todo\model\TodoListModel.java
``` java
    /**
     * Changes the save path of the TodoList storage 
     * @throws ValidationException if the path is not valid
     */
    void save(String location) throws ValidationException;

    /**
     * Loads a TodoList from the path. 
     * @throws ValidationException if the path or file is invalid
     */
    void load(String location) throws ValidationException;

    /**
     * Replaces the tasks in list with the one in the 
     */
    void setTasks(List<ImmutableTask> todoList);

    /**
     * Get an observable list of tasks. Used mainly by the JavaFX UI. 
     */
    ObservableList<ImmutableTask> getObservableList();

}

```
###### \java\seedu\todo\model\TodoModel.java
``` java
/**
 * Represents the data layer of the application. The TodoModel handles any 
 * interaction with the application state that are not persisted, such as the
 * view (sort and filtering), undo and redo. Since this layer handles 
 * sorting and filtering, task ID must be passed through {@link #getTaskIndex}
 * to transform them into the index {@link TodoList} methods can use. 
 */
public class TodoModel implements Model {
    // Constants 
    private static final int UNDO_LIMIT = 10;
    private static final String INDEX_OUT_OF_BOUND_FORMAT = "There is no task no. %d";
    private static final String NO_MORE_UNDO_REDO_FORMAT = "There are no more steps to %s";
    
    // Dependencies
    private TodoListModel todoList;
    private UniqueTagCollectionModel uniqueTagCollection = new UniqueTagCollection();
    private MovableStorage<ImmutableTodoList> storage;
    
    // Stack of transformation that the tasks go through before being displayed to the user
    private ObservableList<ImmutableTask> tasks;
    private FilteredList<ImmutableTask> viewFilteredTasks;
    private FilteredList<ImmutableTask> findFilteredTasks;
    private SortedList<ImmutableTask> sortedTasks;
    
    // State stacks for managing un/redo
    private Deque<List<ImmutableTask>> undoStack = new ArrayDeque<>();
    private Deque<List<ImmutableTask>> redoStack = new ArrayDeque<>();

    /**
     * Contains the current view tab the user has selected. 
     * {@link #getViewFilter()} is the getter and {@link #view(TaskViewFilter)} is the setter
     */
    private ObjectProperty<TaskViewFilter> view = new SimpleObjectProperty<>();
    
    private ObjectProperty<SearchStatus> search = new SimpleObjectProperty<>();

    public TodoModel(Config config) {
        this(new TodoListStorage(config.getTodoListFilePath()));
    }
    
    public TodoModel(MovableStorage<ImmutableTodoList> storage) {
        this(new TodoList(storage), storage);
    }
    
    public TodoModel(TodoListModel todoList, MovableStorage<ImmutableTodoList> storage) {
        this.storage = storage;
        this.todoList = todoList;

        tasks = todoList.getObservableList();
        viewFilteredTasks = new FilteredList<>(tasks);
        findFilteredTasks = new FilteredList<>(viewFilteredTasks);
        sortedTasks = new SortedList<>(findFilteredTasks);
        
        // Sets the default view 
        view(TaskViewFilter.DEFAULT);
    }

    /**
     * Because the model does filtering and sorting on the tasks, the incoming index needs to be 
     * translated into it's index in the underlying todoList. The code below is not particularly
     * clean, but it works well enough. 
     * 
     * @throws ValidationException if the index is invalid
     */
    private int getTaskIndex(int index) throws ValidationException {
        int taskIndex;

        try {
            ImmutableTask task = getObservableList().get(index - 1);
            taskIndex = tasks.indexOf(task);
        } catch (IndexOutOfBoundsException e) {
            taskIndex = -1;
        }

        if (taskIndex == -1) {
            String message = String.format(TodoModel.INDEX_OUT_OF_BOUND_FORMAT, index);
            throw new ValidationException(message);
        }

        return taskIndex;
    }
    
    private void saveState(Deque<List<ImmutableTask>> stack) {
        List<ImmutableTask> tasks = todoList.getTasks().stream()
            .map(Task::new).collect(Collectors.toList());
        
        stack.addFirst(tasks);
        while (stack.size() > TodoModel.UNDO_LIMIT) {
            stack.removeLast();
        }
    }

    private void saveUndoState() {
        saveState(undoStack);
        redoStack.clear();
    }
    
    @Override
    public ImmutableTask add(String title) throws IllegalValueException {
        saveUndoState();
        return todoList.add(title);
    }

    @Override
    public ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException {
        saveUndoState();
        return todoList.add(title, update);
    }

    @Override
    public ImmutableTask delete(int index) throws ValidationException {
        saveUndoState();
        ImmutableTask taskToDelete = getObservableList().get(getTaskIndex(index));
        uniqueTagCollection.notifyTaskDeleted(taskToDelete);
        return todoList.delete(getTaskIndex(index));
    }

    @Override
    public ImmutableTask update(int index, Consumer<MutableTask> update) throws ValidationException {
        saveUndoState();
        return todoList.update(getTaskIndex(index), update);
    }

```
###### \java\seedu\todo\model\TodoModel.java
``` java
    @Override
    public void view(TaskViewFilter view) {
        viewFilteredTasks.setPredicate(view.filter);

        sortedTasks.setComparator((a, b) -> {
            int pin = Boolean.compare(b.isPinned(), a.isPinned());
            return pin != 0 || view.sort == null ? pin : view.sort.compare(a, b);
        });
        
        this.view.setValue(view);
    }
    
    @Override
    public void find(Predicate<ImmutableTask> predicate) {
        findFilteredTasks.setPredicate(predicate);
        search.setValue(null);
    }

    @Override
    public void find(Predicate<ImmutableTask> predicate, List<String> terms) {
        findFilteredTasks.setPredicate(predicate);
        search.setValue(new SearchStatus(terms, findFilteredTasks.size(), tasks.size()));
    }

    @Override
    public void undo() throws ValidationException {
        if (undoStack.isEmpty()) {
            String message = String.format(TodoModel.NO_MORE_UNDO_REDO_FORMAT, "undo");
            throw new ValidationException(message);
        }
        
        List<ImmutableTask> tasks = undoStack.removeFirst();
        uniqueTagCollection.initialise(todoList.getObservableList());
        saveState(redoStack);
        todoList.setTasks(tasks);
    }

    @Override
    public void redo() throws ValidationException {
        if (redoStack.isEmpty()) {
            String message = String.format(TodoModel.NO_MORE_UNDO_REDO_FORMAT, "redo");
            throw new ValidationException(message);
        }

        List<ImmutableTask> tasks = redoStack.removeFirst();
        uniqueTagCollection.initialise(todoList.getObservableList());
        saveState(undoStack);
        todoList.setTasks(tasks);
    }

    @Override
    public void save(String location) throws ValidationException {
        todoList.save(location);
    }

    @Override
    public void load(String location) throws ValidationException {
        todoList.load(location);
        uniqueTagCollection.initialise(todoList.getObservableList());
    }

    @Override
    public String getStorageLocation() {
        return storage.getLocation();
    }

    @Override
    public UnmodifiableObservableList<ImmutableTask> getObservableList() {
        return new UnmodifiableObservableList<>(sortedTasks);
    }

    @Override
    public ObjectProperty<TaskViewFilter> getViewFilter() {
        return view;
    }

    @Override
    public ObjectProperty<SearchStatus> getSearchStatus() {
        return search;
    }

```
###### \resources\style\DefaultStyle.css
``` css
.searchStatus {
    -fx-padding: 4px;
}

.searchStatus Text {
    -fx-font-size: 14px;
    -fx-fill: #fff;
}

.searchStatus .searchLabel {
}

.searchStatus .searchTerm {
    -fx-font-weight: bold;
}

.searchStatus .searchCount {
    -fx-text-alignment: right;
}
```
