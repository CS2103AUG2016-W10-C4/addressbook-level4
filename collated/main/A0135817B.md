# A0135817B
###### \java\seedu\todo\commons\exceptions\ValidationException.java
``` java
public class ValidationException extends Exception {

    private ErrorBag errors;
    
    public ValidationException(String message) {
        super(message);
        this.errors = new ErrorBag();
    }
    
    public ValidationException(String message, ErrorBag errors) {
        super(message);
        this.errors = errors;
    }
    
    public ErrorBag getErrors() {
        return errors;
    }
}
```
###### \java\seedu\todo\commons\util\StringUtil.java
``` java
    /**
     * Returns true if the string is null, of length zero, or contains only whitespace 
     */
    public static boolean isEmpty(String s) {
        return s == null || s.length() == 0 || CharMatcher.whitespace().matchesAllOf(s);
    }

```
###### \java\seedu\todo\commons\util\TimeUtil.java
``` java
    /**
     * Translates input string from International date format (DD/MM/YYYY) to American
     * date format (MM/DD/YYYY), because Natty only recognizes the later 
     */
    public static String toAmericanDateFormat(String input) {
        return DATE_REGEX.matcher(input).replaceAll("$3$2$1");
    }
    
```
###### \java\seedu\todo\logic\arguments\Argument.java
``` java
abstract public class Argument<T> implements Parameter {
    private static final String REQUIRED_ERROR_FORMAT = "The %s parameter is required";
    private static final String TYPE_ERROR_FORMAT = "The %s should be a %s. You gave '%s'.";
    
    protected static final String OPTIONAL_ARGUMENT_FORMAT = "[%s]";
    protected static final String FLAG_ARGUMENT_FORMAT = "%s%s %s";
    
    private String name;
    private String description;
    private String flag;
    private boolean optional = true;
    private boolean boundValue = false;
    
    protected T value;
    
    private String requiredErrorMessage;
    
    private static final Logger logger = LogsCenter.getLogger(Argument.class);
    
    public Argument(String name) {
        this.name = name;
    }
    
    public Argument(String name, T defaultValue) {
        this.name = name;
        this.value = defaultValue;
    }
    
    /**
     * Binds a value to this parameter. Implementing classes MUST override AND 
     * call the parent class function so that the dirty bit is set for required
     * parameter validation to work
     */
    @Override
    public void setValue(String input) throws IllegalValueException {
        boundValue = true;
    }
    
    public T getValue() {
        return value;
    }
    
    @Override
    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public Argument<T> description(String description) {
        this.description = description;
        return this;
    }

    public String getFlag() {
        return flag;
    }
    
    public Argument<T> flag(String flag) {
        this.flag = flag.trim().toLowerCase();
        
        if (!this.flag.equals(flag)) {
            logger.warning("Flag argument has uppercase or whitespace characters. These have been ignored.");
        }
        
        return this;
    }

    public boolean isOptional() {
        return optional;
    }
    
    public boolean hasBoundValue() {
        return boundValue;
    }
    
    /**
     * Sets the field as required
     */
    public Argument<T> required() {
        this.optional = false;
        return this;
    }
    
    /**
     * Sets the field as required and specify an error message to show if it is not provided
     * @param errorMessage shown to the user when the parameter is not provided 
     */
    public Argument<T> required(String errorMessage) {
        requiredErrorMessage = errorMessage;
        this.optional = false;
        return this;
    }
    
    @Override
    public boolean isPositional() {
        return flag == null;
    }
    
    @Override
    public void checkRequired() throws IllegalValueException {
        if (!isOptional() && !hasBoundValue()) {
            String error = requiredErrorMessage == null ? 
                    String.format(Argument.REQUIRED_ERROR_FORMAT, name) : requiredErrorMessage;
            throw new IllegalValueException(error);
        }
    }

    /**
     * Throws an IllegalValueException for a type mismatch between user input and what 
     * the argument expect 
     * @param field     name of the argument 
     * @param expected  the expected type for the argument 
     * @param actual    what the user actually gave 
     */
    protected void typeError(String field, String expected, String actual) throws IllegalValueException {
        throw new IllegalValueException(String.format(Argument.TYPE_ERROR_FORMAT, field, expected, actual));
    }
    
    @Override
    public String toString() {
        return toString(name);
    }
    
    public String toString(String name) {
        if (!isPositional()) {
            name = String.format(FLAG_ARGUMENT_FORMAT, TodoParser.FLAG_TOKEN, flag, name);
        }

        if (isOptional()) {
            name = String.format(OPTIONAL_ARGUMENT_FORMAT, name);
        }

        return name;
    }
}
```
###### \java\seedu\todo\logic\arguments\DateRange.java
``` java
/**
 * Utility container class for the output from DateRangeArgument
 */
public class DateRange {
    private final LocalDateTime endTime; 
    private LocalDateTime startTime;
    
    public DateRange(LocalDateTime endTime) {
        this.endTime = endTime;
    }
    
    public DateRange(LocalDateTime startTime, LocalDateTime endTime) {
        this(endTime);
        this.startTime = startTime;
    }

    public LocalDateTime getEndTime() {
        return endTime;
    }

    public LocalDateTime getStartTime() {
        return startTime;
    }
    
    public boolean isRange() {
        return startTime != null;
    }
}
```
###### \java\seedu\todo\logic\arguments\DateRangeArgument.java
``` java
public class DateRangeArgument extends Argument<DateRange> {
    private static final TimeUtil timeUtil = new TimeUtil();
    
    // TODO: Review all error messages to check for user friendliness 
    private static final String TOO_MANY_DATES_FORMAT = "You specified too many time - we found: %s";
    private static final String NO_DATE_FOUND_FORMAT = "%s does not seem to contain a date";
    
    public DateRangeArgument(String name) {
        // Makes sure that there is a default value, so that callers won't get null when they getValue()
        super(name, new DateRange(null));
    }
    
    @Override
    public void setValue(String input) throws IllegalValueException {
        super.setValue(input);
        
        if (StringUtil.isEmpty(input)) {
            return;
        }
        
        input = TimeUtil.toAmericanDateFormat(input);
        List<Date> dateGroups = TodoParser.dateTimeParser.parse(input);
        
        List<LocalDateTime> dates = dateGroups.stream()
            .map(TimeUtil::asLocalDateTime)
            .sorted()
            .collect(Collectors.toList());

        if (dates.size() > 2) {
            tooManyDatesError(dates);
        } else if (dates.isEmpty()) {
            throw new IllegalValueException(String.format(DateRangeArgument.NO_DATE_FOUND_FORMAT, input));
        }
        
        if (dates.size() == 1) {
            value = new DateRange(dates.get(0));
        } else {
            value = new DateRange(dates.get(0), dates.get(1));
        }
    }
    
    private void tooManyDatesError(List<LocalDateTime> dates) throws IllegalValueException {
        StringJoiner sj = new StringJoiner(", ");
        for (LocalDateTime d : dates) {
            sj.add(timeUtil.getTaskDeadlineText(d));
        }
        String message = String.format(DateRangeArgument.TOO_MANY_DATES_FORMAT, sj.toString());
        throw new IllegalValueException(message);
    }
    
}
```
###### \java\seedu\todo\logic\arguments\FlagArgument.java
``` java
public class FlagArgument extends Argument<Boolean> {

    public FlagArgument(String name) {
        super(name);
        flag(name.substring(0, 1).toLowerCase());
        this.value = false;
    }

    @Override
    public void setValue(String input) throws IllegalValueException {
        this.value = true;
        super.setValue(input);
    }
    
    @Override
    public String toString(String name) {
        String flag = TodoParser.FLAG_TOKEN + getFlag();
        return isOptional() ? String.format(Argument.OPTIONAL_ARGUMENT_FORMAT, flag) : flag;
    }
}
```
###### \java\seedu\todo\logic\arguments\IntArgument.java
``` java
public class IntArgument extends Argument<Integer> {

    public IntArgument(String name) {
        super(name);
    }
    
    @Override
    public void setValue(String input) throws IllegalValueException {
        try {
            value = Integer.parseInt(input);
            super.setValue(input);
        } catch (NumberFormatException e) {
            typeError(this.getName(), "integer", input);
        }
    }

}
```
###### \java\seedu\todo\logic\arguments\Parameter.java
``` java
/**
 * Represents a single command parameter that the parser will try to feed the user 
 * input into. The Parameter interface is needed because the Argument base class is 
 * typed, so this interface contains all of the non-typed methods that are common to 
 * all argument subclasses
 */
public interface Parameter {
    void setValue(String input) throws IllegalValueException;
    
    boolean isPositional();
    
    boolean hasBoundValue();
    
    boolean isOptional();
    
    String getFlag();
    
    String getName();
    
    String getDescription();
    
    void checkRequired() throws IllegalValueException;
}
```
###### \java\seedu\todo\logic\arguments\StringArgument.java
``` java
public class StringArgument extends Argument<String> {

    public StringArgument(String name) {
        super(name);
    }
    
    @Override
    public void setValue(String input) throws IllegalValueException {
        input = input.trim();
        
        // Ignore empty strings
        if (input.length() > 0) {
            this.value = input;
        }
        
        super.setValue(input);
    }

}
```
###### \java\seedu\todo\logic\commands\AddCommand.java
``` java
public class AddCommand extends BaseCommand {
    
    private Argument<String> title = new StringArgument("title").required();
    
    private Argument<String> description = new StringArgument("description")
            .flag("m");
    
    private Argument<Boolean> pin = new FlagArgument("pin")
            .flag("p");
    
    private Argument<String> location = new StringArgument("location")
            .flag("l");
    
    private Argument<DateRange> date = new DateRangeArgument("deadline")
            .flag("d");

    private Argument<String> tags = new StringArgument("tag")
            .flag("t");

    @Override
    public Parameter[] getArguments() {
        return new Parameter[] {
            title, date, description, location, pin, tags
        };
    }

    @Override
    public String getCommandName() {
        return "add";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        String eventArguments = Joiner.on(" ").join(title, "/d start and end time", description, location, pin, "/t tag1 [, tag2, ...]");
        
        return ImmutableList.of(
            new CommandSummary("Add task", getCommandName(), getArgumentSummary()), 
            new CommandSummary("Add event", getCommandName(), eventArguments));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        ImmutableTask addedTask = this.model.add(title.getValue(), task -> {
            task.setDescription(description.getValue());
            task.setPinned(pin.getValue());
            task.setLocation(location.getValue());
            task.setStartTime(date.getValue().getStartTime());
            task.setEndTime(date.getValue().getEndTime());
            model.addTagsToTask(task, StringUtil.split(tags.getValue()));
        });
        if(!model.getObservableList().contains(addedTask)) {
            model.view(TaskViewFilter.DEFAULT);
        }

        eventBus.post(new HighlightTaskEvent(addedTask));
        eventBus.post(new ExpandCollapseTaskEvent(addedTask));
        return new CommandResult();
    }

```
###### \java\seedu\todo\logic\commands\BaseCommand.java
``` java
/**
 * The base class for commands. All commands need to implement an execute function 
 * and a getArguments function that collects the command arguments for the use of 
 * the help command. 
 * 
 * To perform additional validation on incoming arguments, override the validateArguments 
 * function.
 */
public abstract class BaseCommand {
    /**
     * The default message that accompanies argument errors
     */
    private static final String DEFAULT_ARGUMENT_ERROR_MESSAGE = ""; 
    
    private static final String TASK_MODIFIED_SUCCESS_MESSAGE = "'%s' successfully %s!";
    
    protected static final EventsCenter eventBus = EventsCenter.getInstance();

    protected Model model;
    
    protected ErrorBag errors = new ErrorBag(); 
    
    abstract protected Parameter[] getArguments();

    /**
     * Return the name of the command, which is used to call it
     */
    abstract public String getCommandName();

    /**
     * Returns a list of command summaries for the command. This function returns a 
     * list because commands may (rarely) be responsible for more than one thing, 
     * like the <code>add</code> command. 
     */
    abstract public List<CommandSummary> getCommandSummary();
    
    abstract public CommandResult execute() throws ValidationException;
    
    /**
     * Binds the data model to the command object
     */
    public void setModel(Model model) {
        this.model = model;
    }

    /**
     * Binds the both positional and named command arguments from the parse results 
     * to the command object itself 
     * 
     * @throws ValidationException if the arguments are invalid
     */
    public void setArguments(ParseResult arguments) throws ValidationException {
        if (arguments.getPositionalArgument().isPresent()) {
            setPositionalArgument(arguments.getPositionalArgument().get());
        }
        
        for (Entry<String, String> e : arguments.getNamedArguments().entrySet()) {
            setNameArgument(e.getKey(), e.getValue());
        }
        
        checkRequiredArguments();
        validateArguments();
        
        errors.validate(getArgumentErrorMessage());
    }
    
    /**
     * Hook allowing subclasses to implement their own validation logic for arguments
     * Subclasses should add additional errors to the errors ErrorBag
     */
    protected void validateArguments() {
        // Does no additional validation by default 
    }
    
    protected void setPositionalArgument(String argument) {
        for (Parameter p : getArguments()) {
            if (p.isPositional()) {
                try {
                    p.setValue(argument);
                } catch (IllegalValueException e) {
                    errors.put(e.getMessage());
                }
            }
        }
    }
    
    protected void setNameArgument(String flag, String argument) {
        for (Parameter p : getArguments()) {
            if (flag.equals(p.getFlag())) {
                try {
                    p.setValue(argument);
                } catch (IllegalValueException e) {
                    errors.put(p.getName(), e.getMessage());
                }
                
                return;
            }
        }
    }
    
    private void checkRequiredArguments() {
        for (Parameter p : getArguments()) {
            try {
                p.checkRequired();
            } catch (IllegalValueException e) {
                errors.put(p.getName(), e.getMessage());
            }
        }
    }

    /**
     * Override this function if the command should return some other error 
     * message on argument validation error 
     */
    protected String getArgumentErrorMessage() {
        return BaseCommand.DEFAULT_ARGUMENT_ERROR_MESSAGE;
    }

    /**
     * Returns a generic CommandResult with a "{task} successfully {verbed}" success message. 
     * 
     * @param title the title of the task that was verbed on 
     * @param verb the action that was performed on the task, in past tense
     */
    protected CommandResult taskSuccessfulResult(String title, String verb) {
        return new CommandResult(String.format(BaseCommand.TASK_MODIFIED_SUCCESS_MESSAGE, title, verb));
    }

    /**
     * Turns the arguments into a string summary using their toString function
     */
    protected String getArgumentSummary() {
        StringJoiner sj = new StringJoiner(" ");
        for (Parameter p : getArguments()) {
            sj.add(p.toString());
        }
        return sj.toString();
    }

    /**
     * Checks whether a string argument is empty
     */
    protected boolean isEmpty(Argument<String> argument) {
        return !argument.hasBoundValue() || StringUtil.isEmpty(argument.getValue());
    }
}
```
###### \java\seedu\todo\logic\commands\CommandResult.java
``` java
/**
 * Represents the result of a command execution.
 */
public class CommandResult {
    private final String feedback;
    private final ErrorBag errors; 
    
    public CommandResult() {
        this.feedback = "";
        this.errors = null;
    }
    
    public CommandResult(String feedback) {
        this.feedback = feedback;
        this.errors = null;
    }
    
    public CommandResult(String feedback, ErrorBag errors) {
        this.feedback = feedback;
        this.errors = errors;
    }

    public String getFeedback() {
        return feedback;
    }

    public ErrorBag getErrors() {
        return errors;
    }
    
    public boolean isSuccessful() {
        return errors == null;
    }
}
```
###### \java\seedu\todo\logic\commands\CommandSummary.java
``` java
public class CommandSummary {
    /**
     * The scenario the summary is aiming to describe, eg. add event, delete task, etc. 
     * Keep it short but descriptive. 
     */
    public final String scenario;

    /**
     * The command to accomplish the scenario, eg. add, delete 
     */
    public final String command;

    /**
     * The parameters for the command
     */
    public final String arguments;
    
    public CommandSummary(String scenario, String command) {
        this(scenario, command, "");
    }
    
    public CommandSummary(String scenario, String command, String arguments) {
        this.scenario = scenario.trim();
        this.command = command.toLowerCase().trim();
        this.arguments = arguments.trim();
    }

```
###### \java\seedu\todo\logic\commands\DeleteCommand.java
``` java
public class DeleteCommand extends BaseCommand {
    private static final String VERB = "deleted";
    
    private Argument<Integer> index = new IntArgument("index").required();

    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{ index };
    }

    @Override
    public String getCommandName() {
        return "delete";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Delete task", getCommandName(), 
            getArgumentSummary()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        //clear selections
        eventBus.post(new HighlightTaskEvent(null));
        
        ImmutableTask deletedTask = this.model.delete(index.getValue());
        return taskSuccessfulResult(deletedTask.getTitle(), DeleteCommand.VERB);
    }
}
```
###### \java\seedu\todo\logic\commands\ExitCommand.java
``` java
/**
 * Terminates the program.
 */
public class ExitCommand extends BaseCommand {
    private final static String EXIT_MESSAGE = "Goodbye!";
    
    @Override
    public CommandResult execute() throws ValidationException {
        EventsCenter.getInstance().post(new ExitAppRequestEvent());
        return new CommandResult(ExitCommand.EXIT_MESSAGE);
    }

    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{};
    }

    @Override
    public String getCommandName() {
        return "exit";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Close this app :(", getCommandName()));
    }

}
```
###### \java\seedu\todo\logic\commands\FindCommand.java
``` java
public class FindCommand extends BaseCommand {
    private static final String FEEDBACK = "Type 'find' or switch to another view to dismiss";
    
    private Argument<String> keywords = new StringArgument("keywords");

    private Argument<String> tags = new StringArgument("tags")
            .flag("t");
    
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[] { keywords, tags };
    }

    @Override
    public String getCommandName() {
        return "find";
        }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(
                new CommandSummary("Find tasks", getCommandName(), getArgumentSummary()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        // Dismissing search results if there are no keywords
        if (isEmpty(keywords) && isEmpty(tags)) {
            model.find(t -> true);
            return new CommandResult();
        }
        
        // Construct the predicate and list of search terms 
        Predicate<ImmutableTask> filter = t -> false;
        List<String> terms = new ArrayList<>();
        
        if (!isEmpty(keywords)) {
            List<String> keywordList = getSearchTerms(keywords);
            terms.addAll(keywordList);
            filter = filter.or(task -> {
                String title = task.getTitle().toLowerCase();
                return keywordList.stream().anyMatch(title::contains);
            });
        }
        
        if (!isEmpty(tags)) {
            List<String> tagList = getSearchTerms(tags);
            terms.addAll(tagList);
            filter = filter.or(task -> {
                Set<String> taskTagNames = Tag.getLowerCaseNames(task.getTags());
                return !Collections.disjoint(taskTagNames, tagList);
            });
        }

        model.find(filter, terms);
        return new CommandResult(FEEDBACK);
    }

    /**
     * Splits the argument's value into lowercase space or comma delimited terms 
     */
    private List<String> getSearchTerms(Argument<String> argument) {
        return Arrays.asList(StringUtil.split(argument.getValue().toLowerCase()));
    }
}
```
###### \java\seedu\todo\logic\commands\HelpCommand.java
``` java
/**
 * Shows the help panel
 */
public class HelpCommand extends BaseCommand {
    private final static String HELP_MESSAGE = "Start typing in the command to dismiss.";

    @Override
    public CommandResult execute() throws ValidationException {
        List<CommandSummary> commandSummaries = CommandMap.getAllCommandSummary();
        
        EventsCenter.getInstance().post(new ShowHelpEvent(commandSummaries));
        return new CommandResult(HelpCommand.HELP_MESSAGE);
    }

    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{};
    }

    @Override
    public String getCommandName() {
        return "help";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Show help", getCommandName()));
    }
}
```
###### \java\seedu\todo\logic\commands\LoadCommand.java
``` java
public class LoadCommand extends BaseCommand {
    private Argument<String> location = new StringArgument("location").required();
    
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{ location };
    }

    @Override
    public String getCommandName() {
        return "load";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Load todo list from file", getCommandName(), 
            getArgumentSummary()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        String path = location.getValue();
        model.load(path);
        return new CommandResult(String.format("File loaded from %s", path));
    }
}
```
###### \java\seedu\todo\logic\commands\RedoCommand.java
``` java
public class RedoCommand extends BaseCommand {
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[0];
    }

    @Override
    public String getCommandName() {
        return "redo";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Redo", getCommandName()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        model.redo();
        return new CommandResult("Redid last action");
    }
}
```
###### \java\seedu\todo\logic\commands\SaveCommand.java
``` java
/**
 * Saves the save file to a different location 
 */
public class SaveCommand extends BaseCommand {
    private Argument<String> location = new StringArgument("location");
    
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[]{ location };
    }

    @Override
    public String getCommandName() {
        return "save";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(
            new CommandSummary("Save to another file", getCommandName(), "location"), 
            new CommandSummary("Show save location", getCommandName()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        if (location.hasBoundValue()) {
            model.save(location.getValue());
            
            return new CommandResult(String.format("Todo list saved successfully to %s", location));
        } else {
            return new CommandResult(String.format("Save location: %s", model.getStorageLocation()));
        }
    }
}
```
###### \java\seedu\todo\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends BaseCommand {
    @Override
    protected Parameter[] getArguments() {
        return new Parameter[0];
    }

    @Override
    public String getCommandName() {
        return "undo";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(new CommandSummary("Undo last edit", getCommandName()));
    }

    @Override
    public CommandResult execute() throws ValidationException {
        model.undo();
        return new CommandResult("Undid last action");
    }
}
```
###### \java\seedu\todo\logic\Dispatcher.java
``` java
public interface Dispatcher {
    BaseCommand dispatch(String command) throws IllegalValueException;
}
```
###### \java\seedu\todo\logic\Logic.java
``` java
/**
 * API of the Logic component
 */
public interface Logic {
    /**
     * Executes the command and returns the result.
     * @param input The command as entered by the user.
     */
    CommandResult execute(String input);

```
###### \java\seedu\todo\logic\parser\Parser.java
``` java
public interface Parser {
    ParseResult parse(String input);
}
```
###### \java\seedu\todo\logic\parser\ParseResult.java
``` java
public interface ParseResult {

    String getCommand();

    Optional<String> getPositionalArgument();

    Map<String, String> getNamedArguments();

}
```
###### \java\seedu\todo\logic\parser\TodoParser.java
``` java
/**
 * Parses a input string into the command, positional argument and named arguments. 
 * The format looks like: 
 * 
 * <pre><code>command positional [-f or --flag named]...</code></pre>
 * 
 * There will only be one command, optionally one positional argument, and 
 * optionally many named arguments. 
 */
public class TodoParser implements Parser {
    // Best practice would dictate this property be inside DateRangeArgument instead
    // but PrettyTimeParser takes several seconds to warm up, so instead we do it in the 
    // TodoLogic constructor, which is initialized on app startup. 
    public static final PrettyTimeParser dateTimeParser = new PrettyTimeParser();
    
    public static final String FLAG_TOKEN = "/";
    
    public TodoParser() {
        // Try to warm up the parser a little on a background thread
        new Thread(() -> dateTimeParser.parse("next Wednesday 2pm to 6pm")).start();
    }

    private List<String> tokenize(String input) {
        input = input.trim();
        
        return Lists.newArrayList(Splitter
            .on(" ")
            .trimResults()
            .omitEmptyStrings()
            .split(input));
    }
    
    private String parseFlag(String token) {
        return token.substring(1, token.length());
    }
    
    private boolean isFlag(String token) {
        return token.startsWith(TodoParser.FLAG_TOKEN) && token.length() > 1;
    }
    
    @Override
    public ParseResult parse(String input) {
        List<String> tokens = tokenize(input);
        Map<String, String> named = new HashMap<>();
        
        // Pull out the command, exit if there's no more things to parse
        String command = tokens.remove(0).toLowerCase();
        
        // Parse out positional argument
        StringJoiner sj = new StringJoiner(" ");
        while (!tokens.isEmpty() && !isFlag(tokens.get(0))) {
            sj.add(tokens.remove(0));
        }
        String positional = sj.toString();
        
        // If there are no more tokens return immediately
        if (tokens.isEmpty()) {
            return new TodoResult(command, positional, named);
        }
        
        // Parse out named arguments
        String flag = tokens.remove(0);
        sj = new StringJoiner(" ");
        while (!tokens.isEmpty()) {
            if (isFlag(tokens.get(0))) {
                named.put(parseFlag(flag), sj.toString());
                flag = tokens.remove(0);
                sj = new StringJoiner(" ");
            } else {
                sj.add(tokens.remove(0));
            }
        }
        named.put(parseFlag(flag), sj.toString());
        
        return new TodoResult(command, positional, named);
    }

    private class TodoResult implements ParseResult {
        private final String command;
        private final String positional;
        private final Map<String, String> named;

        public TodoResult(String command, String positional, Map<String, String> named) {
            this.command = command;
            this.positional = positional.length() > 0 ? positional : null;
            this.named = named;
        }

        @Override
        public String getCommand() {
            return command;
        }

        @Override
        public Optional<String> getPositionalArgument() {
            return Optional.ofNullable(positional);
        }

        @Override
        public Map<String, String> getNamedArguments() {
            return named;
        }

        @Override
        public String toString() {
            StringJoiner sj = new StringJoiner(" ");
            sj.add(command).add(getPositionalArgument().orElse(""));
            for (Entry<String, String> e : getNamedArguments().entrySet()) {
                sj.add(TodoParser.FLAG_TOKEN + e.getKey()).add(e.getValue());
            }
            return sj.toString();
        }
    }
}
```
###### \java\seedu\todo\logic\TodoDispatcher.java
``` java
/**
 * Selects the correct command based on the parser results
 */
public class TodoDispatcher implements Dispatcher {
    private final static String COMMAND_NOT_FOUND_FORMAT = "'%s' doesn't look like any command we know.";
    private final static String AMBIGUOUS_COMMAND_FORMAT = "Do you mean %s?";
    
    public BaseCommand dispatch(String input) throws IllegalValueException {

        List<String> commands = CommandMap.filterCommandKeys(input);

        // Return immediately when there's one match left. This allow the user to
        // type as little as possible
        if (commands.size() == 1) {
            String key = commands.iterator().next();
            return CommandMap.getCommand(key);
        } else if (commands.isEmpty()) {
            throw new IllegalValueException(String.format(TodoDispatcher.COMMAND_NOT_FOUND_FORMAT, input));
        }

        String ambiguousCommands = Joiner.on(" or ").join(commands);
        throw new IllegalValueException(String.format(TodoDispatcher.AMBIGUOUS_COMMAND_FORMAT, ambiguousCommands));
    }
}
```
###### \java\seedu\todo\logic\TodoLogic.java
``` java
/**
 * Central controller for the application, abstracting application logic from the UI
 */
public class TodoLogic implements Logic {
    private final Parser parser;
    private final Model model;
    private final Dispatcher dispatcher;
    
    private static final Logger logger = LogsCenter.getLogger(TodoLogic.class);
    
    public TodoLogic(Parser parser, Model model, Dispatcher dispatcher) {
        assert parser != null;
        assert model != null;
        assert dispatcher != null;
        
        this.parser = parser;
        this.model = model;
        this.dispatcher = dispatcher;
    }
    
    public CommandResult execute(String input) {
        // Sanity check - input should not be empty 
        if (StringUtil.isEmpty(input)) {
            return new CommandResult();
        }
        
        ParseResult parseResult = parser.parse(input);
        BaseCommand command;
        logger.fine("Parsed command: " + parseResult.toString());
        
        try {
            command = dispatcher.dispatch(parseResult.getCommand());
        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage(), new ErrorBag());
        }
        
        try {
            command.setArguments(parseResult);
            command.setModel(model);
            return command.execute();
        } catch (ValidationException e) {
            logger.info(e.getMessage());
            return new CommandResult(e.getMessage(), e.getErrors());
        }
    }

```
###### \java\seedu\todo\model\ErrorBag.java
``` java
public class ErrorBag {
    private List<String> nonFieldErrors = new ArrayList<>();
    private Map<String, String> fieldErrors = new HashMap<>();
    
    /**
     * Add an error that is not related to any specific field
     * 
     * @param nonFieldError the error message
     */
    public void put(String nonFieldError) {
        nonFieldErrors.add(nonFieldError);
    }
    
    /**
     * Add an error that is related to a specific field 
     * 
     * @param field the error is for
     * @param error the error message 
     */
    public void put(String field, String error) {
        fieldErrors.put(field, error);
    }
    
    public List<String> getNonFieldErrors() {
        return nonFieldErrors;
    }
    
    public Map<String, String> getFieldErrors() {
        return fieldErrors;
    }
    
    public int size() {
        return nonFieldErrors.size() + fieldErrors.size();
    }
    
    /**
     * Throws a validation exception if the bag contains errors 
     * 
     * @param message a short message about why the validation failed
     * @throws ValidationException if the ErrorBag is not empty
     */
    public void validate(String message) throws ValidationException {
        if (size() > 0) {
            throw new ValidationException(message, this);
        }
    }

```
###### \java\seedu\todo\model\ImmutableTodoList.java
``` java
public interface ImmutableTodoList {
    /**
     * Get an immutable list of tasks 
     */
    List<ImmutableTask> getTasks();
}
```
###### \java\seedu\todo\model\Model.java
``` java
public interface Model {
    /**
     * Adds a new task or event with title only to the todo list.
     *
     * @param title  the title of the task
     * @return the task that was just created 
     * @throws IllegalValueException if the values set in the update predicate is invalid
     */
    ImmutableTask add(String title) throws IllegalValueException;

    /**
     * Adds a new task or event with title and other fields to the todo list.
     *
     * @param title   the title of the task 
     * @param update  a {@link MutableTask} is passed into this lambda. All other fields 
     *                should be set from inside this lambda. 
     * @return the task that was just created
     * @throws ValidationException   if the fields in the task to be updated are not valid
     */
    ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException;

    /**
     * Deletes the given task from the todo list. This change is also propagated to the 
     * underlying persistence layer.  
     *
     * @param index  the 1-indexed position of the task that needs to be deleted
     * @return the task that was just deleted
     * @throws ValidationException if the task does not exist
     */
    ImmutableTask delete(int index) throws ValidationException;
    
    /**
     * Deletes all currently visible tasks from the todo list. This change is also propagated to the 
     * underlying persistence layer.  
     *
     * @return the list of tasks that were just deleted
     * @throws ValidationException if any of the tasks do not exist
     */
    List<ImmutableTask> deleteAll() throws ValidationException;
    
    /**
     * Replaces certain fields in the task. Mutation of the {@link Task} object should 
     * only be done in the {@code update} lambda. The lambda takes in one parameter, 
     * a {@link MutableTask}, and does not expect any return value. For example: 
     *
     * <pre><code>todo.update(task, t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline back by 2h
     *     t.setPin(true); // Pin this task
     * });</code></pre>
     *
     * @return the task that was just updated
     *
     * @throws ValidationException    if the task does not exist or if the fields in the 
     *                                task to be updated are not valid
     */
    ImmutableTask update(int index, Consumer<MutableTask> update) throws ValidationException;
    
    /**
     * Carries out the specified update in the fields of all visible tasks. Mutation of all {@link Task}
     * objects should only be done in the {@code update} lambda. The lambda takes in a single parameter,
     * a {@link MutableTask}, and does not expect any return value, as per the {@link #update} command. Since
     * this represents the observable layer, the changes required to be done to the underlying layer TodoList
     * is set via getting a list of their indices in the underlying layer using a UUID map. 
     * 
     * Note that no change is carried out if <em>any</em> of the tasks fail, the entire operation will 
     * fail, and none of the tasks will be updated. 
     * 
     * <pre><code>todo.updateAll (t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline of all Observable tasks back by 2h
     *     t.setPin(true); // Pin all tasks in Observable view
     * });</code></pre>
     * @return the list of tasks which were just updated
     * 
     * @throws ValidationException if any updates on any of the task objects are considered invalid
     */
    List<ImmutableTask> updateAll(Consumer <MutableTask> update) throws ValidationException;

    /**
     * Sets the model to the provided TaskViewFilter object. TaskViewFilters represents the
     * filter and sorting needed by each intelligent view
     */
    void view(TaskViewFilter view);

    /**
     * Filters the list of tasks by this predicate. This is filtering is ran
     * after the view predicate. No information about the search is shown to the user.
     * Setting predicate to null will reset the search.
     */
    void find(Predicate<ImmutableTask> predicate);

    /**
     * Filters the list of tasks by this predicate. This is filtering is ran
     * after the view predicate. A list of search terms is also shown to the user.
     */
    void find(Predicate<ImmutableTask> predicate, List<String> terms);

    /**
     * Undoes the last operation that modifies the todolist
     * @throws ValidationException if there are no more changes to undo
     */
    void undo() throws ValidationException;

    /**
     * Redoes the last operation that was undone
     * @throws ValidationException if there are no more changes to redo
     */
    void redo() throws ValidationException;
    
    /**
     * Changes the save path of the TodoList storage 
     * @throws ValidationException if the path is not valid
     */
    void save(String location) throws ValidationException;

    /**
     * Loads a TodoList from the path. 
     * @throws ValidationException if the path or file is invalid
     */
    void load(String location) throws ValidationException;

    /**
     * Obtains the current storage methods 
     */
    String getStorageLocation();

    /**
     * Get an observable list of tasks. Used mainly by the JavaFX UI. 
     */
    UnmodifiableObservableList<ImmutableTask> getObservableList();

    /**
     * Get the current view filter used on the model. Used mainly by the JavaFx UI. 
     */
    ObjectProperty<TaskViewFilter> getViewFilter();

    /**
     * Get the current status of the search used on the model.
     */
    ObjectProperty<SearchStatus> getSearchStatus();

```
###### \java\seedu\todo\model\task\BaseTask.java
``` java
public abstract class BaseTask implements ImmutableTask {
    protected UUID uuid = UUID.randomUUID();

    @Override
    public UUID getUUID() {
        return uuid;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof ImmutableTask)) {
            return false;
        }

        return getUUID().equals(((ImmutableTask) o).getUUID());
    }

    @Override
    public int hashCode() {
        return getUUID().hashCode();
    }

    @Override
    public String toString() {
        return getTitle();
    }
}
```
###### \java\seedu\todo\model\task\Task.java
``` java
/**
 * Represents a single task
 */
public class Task extends BaseTask implements MutableTask {
    private StringProperty title = new SimpleStringProperty();
    private StringProperty description = new SimpleStringProperty();
    private StringProperty location = new SimpleStringProperty();

    private BooleanProperty pinned = new SimpleBooleanProperty();
    private BooleanProperty completed = new SimpleBooleanProperty();

    private ObjectProperty<LocalDateTime> startTime = new SimpleObjectProperty<>();
    private ObjectProperty<LocalDateTime> endTime = new SimpleObjectProperty<>();

    private ObjectProperty<Set<Tag>> tags = new SimpleObjectProperty<>(new HashSet<Tag>());
    private LocalDateTime createdAt = LocalDateTime.now();

    /**
     * Creates a new task
     */
    public Task(String title) {
        this.setTitle(title);
    }

    /**
     * Constructs a Task from a ReadOnlyTask
     */
    public Task(ImmutableTask task) {
        this.setTitle(task.getTitle());
        this.setDescription(task.getDescription().orElse(null));
        this.setLocation(task.getLocation().orElse(null));
        this.setStartTime(task.getStartTime().orElse(null));
        this.setEndTime(task.getEndTime().orElse(null));
        this.setCompleted(task.isCompleted());
        this.setPinned(task.isPinned());
        this.setCreatedAt(task.getCreatedAt());
        this.uuid = task.getUUID();
        this.setTags(task.getTags());
    }

    @Override
    public String getTitle() {
        return title.get();
    }

    @Override
    public Optional<String> getDescription() {
        return Optional.ofNullable(description.get());
    }

    @Override
    public Optional<String> getLocation() {
        return Optional.ofNullable(location.get());
    }

    @Override
    public Optional<LocalDateTime> getStartTime() {
        return Optional.ofNullable(startTime.get());
    }

    @Override
    public Optional<LocalDateTime> getEndTime() {
        return Optional.ofNullable(endTime.get());
    }

    @Override
    public boolean isPinned() {
        return pinned.get();
    }

    @Override
    public boolean isCompleted() {
        return completed.get();
    }

    @Override
    public Set<Tag> getTags() {
        return Collections.unmodifiableSet(tags.get());
    }
    
    @Override
    public LocalDateTime getCreatedAt() { return createdAt; }

    @Override
    public void setTitle(String title) {
        this.title.set(title);
    }

    @Override
    public void setPinned(boolean pinned) {
        this.pinned.set(pinned);
    }

    @Override
    public void setCompleted(boolean completed) {
        this.completed.set(completed);
    }

    @Override
    public void setDescription(String description) {
        this.description.set(description);
    }

    @Override
    public void setLocation(String location) {
        this.location.set(location);
    }

    @Override
    public void setStartTime(LocalDateTime startTime) {
        this.startTime.set(startTime);
    }

    @Override
    public void setEndTime(LocalDateTime endTime) {
        this.endTime.set(endTime);
    }

    @Override
    public void setTags(Set<Tag> tags) {
        this.tags.set(tags);
    }
    
    public void setCreatedAt(LocalDateTime createdAt) {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
        
        this.createdAt = createdAt;
    }

    public Observable[] getObservableProperties() {
        return new Observable[] {
            title, description, location, startTime, endTime, tags, completed, pinned,
        };
    }
}
```
###### \java\seedu\todo\model\TodoList.java
``` java
/**
 * Represents the todolist inside memory. While Model works as the external 
 * interface for handling data and application state, this class is internal 
 * to Model and represents only CRUD operations to the todolist. 
 */
public class TodoList implements TodoListModel {
    private static final String INCORRECT_FILE_FORMAT_FORMAT = "%s doesn't seem to be in the correct format.";
    private static final String FILE_NOT_FOUND_FORMAT = "%s does not seem to exist.";
    private static final String FILE_SAVE_ERROR_FORMAT = "Couldn't save file: %s";
    private static final String FILE_LOAD_ERROR_FORMAT = "The data file %s does not appear to be in the correct format";

    private ObservableList<Task> tasks = FXCollections.observableArrayList(Task::getObservableProperties);

    private MovableStorage<ImmutableTodoList> storage;

    private static final Logger logger = LogsCenter.getLogger(TodoList.class);
    private static final EventsCenter events = EventsCenter.getInstance();

    public TodoList(MovableStorage<ImmutableTodoList> storage) {
        this.storage = storage;
        
        try {
            setTasks(storage.read().getTasks(), false);
        } catch (FileNotFoundException e) {
            logger.info("Data file not found. Will be starting with an empty TodoList");
        } catch (DataConversionException e) {
            String message = String.format(FILE_LOAD_ERROR_FORMAT, storage.getLocation());
            raiseStorageEvent(message, e);
        }
    }

    private void raiseStorageEvent(String message, Exception e) {
        logger.severe("Data IO error - " + e.getClass().getSimpleName() + " | " + e.getMessage());
        events.post(new DataSavingExceptionEvent(message, e));
    }
    
    private void saveTodoList() {
        try {
            storage.save(this);
        } catch (IOException e) {
            String message = String.format(TodoList.FILE_SAVE_ERROR_FORMAT, e.getMessage());
            raiseStorageEvent(message, e);
        }
    }

    @Override
    public ImmutableTask add(String title) {
        Task task = new Task(title);
        tasks.add(task);
        saveTodoList();
        return task;
    }

    @Override
    public ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException {
        ValidationTask validationTask = new ValidationTask(title);
        update.accept(validationTask);
        Task task = validationTask.convertToTask();
        tasks.add(task);
        saveTodoList();
        return task;
    }

    @Override
    public List<ImmutableTask> delete(List<Integer> indexes) throws ValidationException {
        List<ImmutableTask> tasksRemoved = new ArrayList<>();  
        for (Integer index : indexes) {
            ImmutableTask task = tasks.get(index);
            tasksRemoved.add(task);
        }
        tasks.removeAll(tasksRemoved);
        saveTodoList();
        return tasksRemoved;
    }
    
    public ImmutableTask delete(int index) throws ValidationException {
        List<Integer> indexes = Lists.newArrayList(index);
        //get(0) because there should be only one element returned in the list of deleted tasks
        return delete(indexes).get(0);
    }

```
###### \java\seedu\todo\model\TodoList.java
``` java
    @Override
    public void save(String location) throws ValidationException {
        try {
            storage.save(this, location);
        } catch (IOException e) {
            String message = String.format(TodoList.FILE_SAVE_ERROR_FORMAT, e.getMessage());
            throw new ValidationException(message);
        }
    }

    @Override
    public void load(String location) throws ValidationException {
        try {
            setTasks(storage.read(location).getTasks());
        } catch (DataConversionException e) {
            throw new ValidationException(TodoList.INCORRECT_FILE_FORMAT_FORMAT);
        } catch (FileNotFoundException e) {
            String message = String.format(TodoList.FILE_NOT_FOUND_FORMAT, location);
            throw new ValidationException(message);
        }
    }

    @Override
    public void setTasks(List<ImmutableTask> todoList) {
        setTasks(todoList, true);
    }

    /**
     * We have a private version of setTasks because we also need to setTask during initialization, 
     * but we don't want the list to be save during init (where we presumably got the data from)
     */
    private void setTasks(List<ImmutableTask> todoList, boolean persistToStorage) {
        this.tasks.clear();
        this.tasks.addAll(todoList.stream().map(Task::new).collect(Collectors.toList()));
        
        if (persistToStorage) {
            saveTodoList();
        }
    }

    @Override
    public ObservableList<ImmutableTask> getObservableList() {
        return new UnmodifiableObservableList<>(tasks);
    }

    @Override
    public List<ImmutableTask> getTasks() {
        return Collections.unmodifiableList(tasks);
    }
}
```
###### \java\seedu\todo\model\TodoListModel.java
``` java
public interface TodoListModel extends ImmutableTodoList {
    /**
     * Adds a new task or event with title only to the todo list.
     *
     * @param title  the title of the task
     * @return the task that was just created 
     * @throws IllegalValueException if the values set in the update predicate is invalid
     */
    ImmutableTask add(String title) throws IllegalValueException;

    /**
     * Adds a new task or event with title and other fields to the todo list.
     *
     * @param title   the title of the task 
     * @param update  a {@link MutableTask} is passed into this lambda. All other fields 
     *                should be set from inside this lambda. 
     * @return the task that was just created
     * @throws ValidationException   if the fields in the task to be updated are not valid
     */
    ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException;

    /**
     * Deletes the list of given task from the todo list. The changes are also propagated to the 
     * underlying persistence layer.  
     *
     * @param index  the 1-indexed position of the tasks that need to be deleted
     * @return the list of tasks that was just deleted
     * @throws ValidationException if the task does not exist
     */
    List<ImmutableTask> delete(List<Integer> indexes) throws ValidationException;
    
    /**
     * Deletes the given task from the todo list. The change is also propagated to the 
     * underlying persistence layer.  
     *
     * @param index  the 1-indexed position of the tasks that need to be deleted
     * @return the list of tasks that was just deleted
     * @throws ValidationException if the task does not exist
     */
    ImmutableTask delete(int index) throws ValidationException;

    /**
     * Replaces certain fields in the tasks specified. Mutation of the {@link Task} objects should 
     * only be done in the <code>update</code> lambda. The lambda takes in one parameter, 
     * a {@link MutableTask}, and does not expect any return value. For example: 
     *
     * <pre><code>todo.update(task, t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline back by 2h
     *     t.setPin(true); // Pin this task
     * });</code></pre>
     *
     * @return the list of tasks that were just updated
     *
     * @throws ValidationException    if the task does not exist or if the fields in the 
     *                                task to be updated are not valid
     */
    List<ImmutableTask> update(List<Integer> indexes, Consumer<MutableTask> update) throws ValidationException;
    
    /**
     * Replaces certain fields in the task. Mutation of the {@link Task} object should 
     * only be done in the <code>update</code> lambda. The lambda takes in one parameter, 
     * a {@link MutableTask}, and does not expect any return value. For example: 
     *
     * <pre><code>todo.update(task, t -> {
     *     t.setEndTime(t.getEndTime.get().plusHours(2)); // Push deadline back by 2h
     *     t.setPin(true); // Pin this task
     * });</code></pre>
     *
     * @return the task that was just updated
     *
     * @throws ValidationException    if the task does not exist or if the fields in the 
     *                                task to be updated are not valid
     */
    
    ImmutableTask update(int index, Consumer<MutableTask> update) throws ValidationException;

```
###### \java\seedu\todo\model\TodoListModel.java
``` java
    /**
     * Changes the save path of the TodoList storage 
     * @throws ValidationException if the path is not valid
     */
    void save(String location) throws ValidationException;

    /**
     * Loads a TodoList from the path. 
     * @throws ValidationException if the path or file is invalid
     */
    void load(String location) throws ValidationException;

    /**
     * Replaces the tasks in list with the one in the 
     */
    void setTasks(List<ImmutableTask> todoList);

    /**
     * Get an observable list of tasks. Used mainly by the JavaFX UI. 
     */
    ObservableList<ImmutableTask> getObservableList();

}

```
###### \java\seedu\todo\model\TodoModel.java
``` java
/**
 * Represents the data layer of the application. The TodoModel handles any 
 * interaction with the application state that are not persisted, such as the
 * view (sort and filtering), undo and redo. Since this layer handles 
 * sorting and filtering, task ID must be passed through {@link #getTaskIndex}
 * to transform them into the index {@link TodoList} methods can use. 
 */
public class TodoModel implements Model {
    // Constants 
    private static final int UNDO_LIMIT = 10;
    private static final String INDEX_OUT_OF_BOUND_FORMAT = "There is no task no. %d";
    private static final String NO_MORE_UNDO_REDO_FORMAT = "There are no more steps to %s";
    
    // Dependencies
    private TodoListModel todoList;
    private UniqueTagCollectionModel uniqueTagCollection;
    private MovableStorage<ImmutableTodoList> storage;
    
    // Stack of transformation that the tasks go through before being displayed to the user
    private ObservableList<ImmutableTask> tasks;
    private FilteredList<ImmutableTask> viewFilteredTasks;
    private FilteredList<ImmutableTask> findFilteredTasks;
    private SortedList<ImmutableTask> sortedTasks;
    
    // State stacks for managing un/redo
    private Deque<List<ImmutableTask>> undoStack = new ArrayDeque<>();
    private Deque<List<ImmutableTask>> redoStack = new ArrayDeque<>();

    /**
     * Contains the current view tab the user has selected. 
     * {@link #getViewFilter()} is the getter and {@link #view(TaskViewFilter)} is the setter
     */
    private ObjectProperty<TaskViewFilter> view = new SimpleObjectProperty<>();
    
    private ObjectProperty<SearchStatus> search = new SimpleObjectProperty<>();

    public TodoModel(Config config) {
        this(new TodoListStorage(config.getTodoListFilePath()));
    }
    
    public TodoModel(MovableStorage<ImmutableTodoList> storage) {
        this(new TodoList(storage), storage);
    }
    
    public TodoModel(TodoListModel todoList, MovableStorage<ImmutableTodoList> storage) {
        this.storage = storage;
        this.todoList = todoList;

        tasks = todoList.getObservableList();
        viewFilteredTasks = new FilteredList<>(tasks);
        findFilteredTasks = new FilteredList<>(viewFilteredTasks);
        sortedTasks = new SortedList<>(findFilteredTasks);

        uniqueTagCollection = new UniqueTagCollection(todoList.getTasks());
        
        // Sets the default view 
        view(TaskViewFilter.DEFAULT);
    }

    /**
     * Because the model does filtering and sorting on the tasks, the incoming index needs to be 
     * translated into it's index in the underlying todoList. The code below is not particularly
     * clean, but it works well enough. 
     * 
     * @throws ValidationException if the index is invalid
     */
    private int getTaskIndex(int index) throws ValidationException {
        int taskIndex;
        try {
            ImmutableTask task = getObservableList().get(index - 1);
            taskIndex = tasks.indexOf(task);
        } catch (IndexOutOfBoundsException e) {
            taskIndex = -1;
        }
        if (taskIndex == -1) {
            String message = String.format(TodoModel.INDEX_OUT_OF_BOUND_FORMAT, index);
            throw new ValidationException(message);
        }

        return taskIndex;
    }
    
    private void saveState(Deque<List<ImmutableTask>> stack) {
        List<ImmutableTask> tasks = todoList.getTasks().stream()
            .map(Task::new).collect(Collectors.toList());
        
        stack.addFirst(tasks);
        while (stack.size() > TodoModel.UNDO_LIMIT) {
            stack.removeLast();
        }
    }

    private void saveUndoState() {
        saveState(undoStack);
        redoStack.clear();
    }
    
    @Override
    public ImmutableTask add(String title) throws IllegalValueException {
        saveUndoState();
        return todoList.add(title);
    }

    @Override
    public ImmutableTask add(String title, Consumer<MutableTask> update) throws ValidationException {
        saveUndoState();
        return todoList.add(title, update);
    }
```
###### \java\seedu\todo\model\TodoModel.java
``` java
    @Override
    public void view(TaskViewFilter view) {
        viewFilteredTasks.setPredicate(view.filter);
        sortedTasks.setComparator((a, b) -> {
            int pin = Boolean.compare(b.isPinned(), a.isPinned());
            return pin != 0 || view.sort == null ? pin : view.sort.compare(a, b);
        });
        
        this.view.setValue(view);
    }
    
    @Override
    public void find(Predicate<ImmutableTask> predicate) {
        findFilteredTasks.setPredicate(predicate);
        search.setValue(null);
    }

    @Override
    public void find(Predicate<ImmutableTask> predicate, List<String> terms) {
        findFilteredTasks.setPredicate(predicate);
        search.setValue(new SearchStatus(terms, findFilteredTasks.size(), tasks.size()));
    }

    @Override
    public void undo() throws ValidationException {
        if (undoStack.isEmpty()) {
            String message = String.format(TodoModel.NO_MORE_UNDO_REDO_FORMAT, "undo");
            throw new ValidationException(message);
        }
        
        List<ImmutableTask> tasks = undoStack.removeFirst();
        uniqueTagCollection.update(tasks);
        saveState(redoStack);
        todoList.setTasks(tasks);
    }

    @Override
    public void redo() throws ValidationException {
        if (redoStack.isEmpty()) {
            String message = String.format(TodoModel.NO_MORE_UNDO_REDO_FORMAT, "redo");
            throw new ValidationException(message);
        }

        List<ImmutableTask> tasks = redoStack.removeFirst();
        uniqueTagCollection.update(tasks);
        saveState(undoStack);
        todoList.setTasks(tasks);
    }

    @Override
    public void save(String location) throws ValidationException {
        todoList.save(location);
    }

    @Override
    public void load(String location) throws ValidationException {
        todoList.load(location);
        uniqueTagCollection.update(tasks);
    }

    @Override
    public String getStorageLocation() {
        return storage.getLocation();
    }

    @Override
    public UnmodifiableObservableList<ImmutableTask> getObservableList() {
        return new UnmodifiableObservableList<>(sortedTasks);
    }

    @Override
    public ObjectProperty<TaskViewFilter> getViewFilter() {
        return view;
    }

    @Override
    public ObjectProperty<SearchStatus> getSearchStatus() {
        return search;
    }

```
###### \java\seedu\todo\storage\FixedStorage.java
``` java
/**
 * Represents a storage mechanism to save an object to a fixed location
 * @param <T>
 */
public interface FixedStorage<T> {
    /**
     * Reads the object from storage 
     * @return the object read from storage 
     * @throws DataConversionException if the data read was not of the expected type 
     * @throws FileNotFoundException if there was no file  
     */
    T read() throws DataConversionException, FileNotFoundException;

    /**
     * Persists an object 
     * @param object the object that needs to be persisted 
     * @throws IOException if there was any problem saving the object to storage
     */
    void save(T object) throws IOException;
}
```
###### \java\seedu\todo\storage\MovableStorage.java
``` java
/**
 * Represents an storage mechanism that allows an object to be saved to a 
 * specific location
 */
public interface MovableStorage<T> extends FixedStorage<T> {
    
    String getLocation(); 
    
    T read(String location) throws DataConversionException, FileNotFoundException;
    
    void save(T object, String newLocation) throws IOException;
}
```
###### \java\seedu\todo\ui\controller\TextAreaResizer.java
``` java
/**
 * Automatically resize a text area object such that the height fits the content of the text area
 */
public class TextAreaResizer {
    // Constants
    private static final int CHAR_AHEAD = 3; 
    private static final int PADDING_OFFSET = 5;
    
    // FXML elements
    private final TextArea textArea;
    private final Text pseudoText = new Text();
    
    // Internal variables
    private double lineHeight;
    private double charWidth;
    private double textAreaWidth;
    private int textAreaChars;
    
    public TextAreaResizer(TextArea textArea) {
        this.textArea = textArea;
        textAreaChars = textArea.getText().length();
        textAreaWidth = textArea.getWidth();
        
        pseudoText.fontProperty().addListener((observable, oldValue, newValue) -> updateCharacterWidth());
        pseudoText.fontProperty().bind(textArea.fontProperty());
        
        textArea.widthProperty().addListener((observable, oldValue, newValue) -> {
            textAreaWidth = (double) newValue - PADDING_OFFSET;
            updateTextArea();
        });
        
        textArea.textProperty().addListener((observable, oldValue, newValue) -> {
            textAreaChars = newValue.length();
            updateTextArea();
        });
    }

    private void updateCharacterWidth() {
        final int TEST_CHAR_LEN = 60;

        pseudoText.setText("");
        double initialWidth = pseudoText.getLayoutBounds().getWidth();
        pseudoText.setText(Strings.repeat("w", TEST_CHAR_LEN));
        double newWidth = pseudoText.getLayoutBounds().getWidth();
        charWidth = (newWidth - initialWidth) / TEST_CHAR_LEN;
    }
    
    private void updateTextArea() {
        // Silly hack to make sure lineHeight is available before continuing 
        if (lineHeight <= 0) {
            if ((lineHeight = textArea.getLayoutBounds().getHeight() - PADDING_OFFSET) <= 0) {
                return;
            }
        }
        
        int lines = (int) (((textAreaChars + CHAR_AHEAD) * charWidth) / textAreaWidth) + 1;
        double height = lines * lineHeight + PADDING_OFFSET;
        
        Platform.runLater(() -> {
            textArea.setMaxHeight(height);
            textArea.setPrefHeight(height);
        });
    }
}
```
###### \java\seedu\todo\ui\view\TaskCardView.java
``` java
    /**
     * Sets style according to the status (e.g. completed, overdue, etc) of the task.
     */
    private void setStyle() {
        ViewStyleUtil.addClassStyles(taskCard, task.isEvent() ? "event" : "task");

        if (task.isCompleted()) {
            ViewStyleUtil.addClassStyles(taskCard, ViewStyleUtil.STYLE_COMPLETED);
        } else if (task.getEndTime().isPresent() && timeUtil.isOverdue(task.getEndTime().get())) {
            ViewStyleUtil.addClassStyles(taskCard, ViewStyleUtil.STYLE_OVERDUE);
        } else if (task.isEvent() && timeUtil.isOngoing(task.getStartTime().get(), task.getEndTime().get())) {
            ViewStyleUtil.addClassStyles(taskCard, ViewStyleUtil.STYLE_ONGOING);
        }
    }

```
###### \resources\style\DefaultStyle.css
``` css
.searchStatus {
    -fx-padding: 4px;
}

.searchStatus Text {
    -fx-font-size: 16px;
    -fx-fill: #f3f3f3;
}

.searchStatus .searchLabel {
}

.searchStatus .searchTerm {
    -fx-font-weight: bold;
}

.searchStatus .searchCount {
    -fx-text-alignment: right;
}

```
