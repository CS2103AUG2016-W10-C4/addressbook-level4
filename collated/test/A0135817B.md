# A0135817B
###### \java\seedu\todo\logic\arguments\ArgumentTest.java
``` java
public class ArgumentTest {
    private Argument<String> arg = new TestArgument();

    @Test
    public void testRequiredErrorMessage() {
        arg.required("Hello world");
        
        try {
            arg.checkRequired();
        } catch (IllegalValueException e) {
            assertEquals("Hello world", e.getMessage());
        }
    }
    
    @Test(expected=IllegalValueException.class)
    public void testRequired() throws IllegalValueException {
        arg.required(); 
        arg.checkRequired();
    }
    
    @Test
    public void testIsOptional() {
        assertTrue(arg.isOptional());
        arg.required();
        assertFalse(arg.isOptional());
    }
    
    @Test
    public void testIsPositional() {
        assertTrue(arg.isPositional());
        arg.flag("t");
        assertFalse(arg.isPositional());
    }
    
    @Test
    public void testFlag() {
        assertNull(arg.getFlag());
        arg.flag("h");
        assertEquals("h", arg.getFlag());
        arg.flag(" H   ");
        assertEquals("h", arg.getFlag());
    }
    
    @Test
    public void testDescription() {
        assertNull(arg.getDescription());
        arg.description("Hello World");
        assertEquals("Hello World", arg.getDescription());
    }
    
    @Test
    public void testToString() {
        assertEquals("[Test]", arg.toString());
        assertEquals("[Something]", arg.toString("Something"));
        
        arg.flag("t");
        assertEquals("[/t Test]", arg.toString());
        assertEquals("[/t Something]", arg.toString("Something"));
        
        arg.required(); 
        assertEquals("/t Test", arg.toString());
        assertEquals("/t Something", arg.toString("Something"));
    }
    
    private class TestArgument extends Argument<String> {
        public TestArgument() {
            super("Test");
        }
    }
}
```
###### \java\seedu\todo\logic\arguments\DateRangeArgumentTest.java
``` java
public class DateRangeArgumentTest {
    private final Argument<DateRange> arg = new DateRangeArgument("Test");
    private final LocalDateTime tomorrow = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(0, 0));
    
    @Test
    public void testDefaultValue() throws Exception {
        assertNull(arg.getValue().getStartTime());
        assertNull(arg.getValue().getEndTime());
        assertFalse(arg.hasBoundValue());
    }
    
    @Test
    public void testEmptyInput() throws Exception {
        arg.setValue("");
        assertNull(arg.getValue().getStartTime());
        assertNull(arg.getValue().getEndTime());
        assertTrue(arg.hasBoundValue());
    }

    @Test
    public void testInternationalDate() throws Exception {
        arg.setValue("6/12/16");
        assertEquals(LocalDate.of(2016, 12, 6), arg.getValue().getEndTime().toLocalDate());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testIsoDate() throws Exception {
        arg.setValue("06-12-2016");
        assertEquals(LocalDate.of(2016, 12, 6), arg.getValue().getEndTime().toLocalDate());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testInternationalDateTime() throws Exception {
        arg.setValue("6/12/16 12:45pm");
        assertEquals(LocalDateTime.of(2016, 12, 6, 12, 45), arg.getValue().getEndTime());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testNaturalLanguageDateTime() throws Exception {
        arg.setValue("12 Oct 2014 6pm");
        assertEquals(LocalDateTime.of(2014, 10, 12, 18, 0), arg.getValue().getEndTime());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testRelativeDate() throws Exception {
        arg.setValue("tomorrow");
        assertEquals(tomorrow.toLocalDate(), arg.getValue().getEndTime().toLocalDate());
        assertFalse(arg.getValue().isRange());
    }

    @Test
    public void testRelativeDateTime() throws Exception {
        arg.setValue("tomorrow 6pm");
        assertEquals(tomorrow.withHour(18), arg.getValue().getEndTime());
        assertFalse(arg.getValue().isRange());
    }
    
    @Test
    public void testRelativeDateRange() throws Exception {
        arg.setValue("tomorrow 6 to 8pm");
        assertEquals(tomorrow.withHour(20), arg.getValue().getEndTime());
        assertEquals(tomorrow.withHour(18), arg.getValue().getStartTime());
    }
    
    @Test
    public void testFormalDateTimeRange() throws Exception {
        arg.setValue("18-12-16 1800hrs to 2000hrs");
        LocalDateTime date = LocalDateTime.of(2016, 12, 18, 0, 0);
        assertEquals(date.withHour(20), arg.getValue().getEndTime());
        assertEquals(date.withHour(18), arg.getValue().getStartTime());

        arg.setValue("18-12-16 1800hrs to 19-12-16 2000hrs");
        assertEquals(LocalDateTime.of(2016, 12, 18, 18, 0), arg.getValue().getStartTime());
        assertEquals(LocalDateTime.of(2016, 12, 19, 20, 0), arg.getValue().getEndTime());
    }
    
    @Test(expected=IllegalValueException.class)
    public void testNoDate() throws Exception {
        arg.setValue("no date here");
    }
    
    @Test(expected=IllegalValueException.class)
    public void testTooManyDates() throws Exception {
        arg.setValue("yesterday, today, tomorrow");
    }

}
```
###### \java\seedu\todo\logic\arguments\DateRangeTest.java
``` java
public class DateRangeTest {

    @Test
    public void testDateRangeLocalDateTime() {
        LocalDateTime start = LocalDateTime.now();
        DateRange range = new DateRange(start);
        assertNull(range.getStartTime());
        assertFalse(range.isRange());
    }

    @Test
    public void testDateRangeLocalDateTimeLocalDateTime() {
        LocalDateTime start = LocalDateTime.now();
        LocalDateTime end = start.plusHours(2);
        DateRange range = new DateRange(start, end);
        
        assertTrue(range.isRange());
    }

}
```
###### \java\seedu\todo\logic\arguments\FlagArgumentTest.java
``` java
public class FlagArgumentTest {
    
    private Argument<Boolean> argument;

    @Before
    public void setUp() throws Exception {
        argument = new FlagArgument("test");
    }

    @Test
    public void testDefaultValue() {
        assertEquals("t", argument.getFlag());
        assertFalse(argument.getValue());
    }
    
    @Test
    public void testSetEmptyValue() throws IllegalValueException {
        argument.setValue("");
        assertTrue(argument.getValue());
    }

    @Test
    public void testSetStringValue() throws IllegalValueException {
        argument.setValue("Hello World");
        assertTrue(argument.getValue());
    }
    
    @Test
    public void testToString() {
        argument.flag("t");
        assertEquals("[/t]", argument.toString());
        
        argument.required();
        assertEquals("/t", argument.toString());
    }

}
```
###### \java\seedu\todo\logic\arguments\IntArgumentTest.java
``` java
public class IntArgumentTest {
    private Argument<Integer> argument;
    
    private int setInput(String input) throws IllegalValueException {
        argument.setValue(input);
        return argument.getValue();
    }
    
    @Before
    public void setUp() {
        argument = new IntArgument("test");
    }

    @Test
    public void testParse() throws IllegalValueException {
        assertEquals(123, setInput("123"));
        assertEquals(-345, setInput("-345"));
    }
    
    @Test(expected=IllegalValueException.class)
    public void testFloatArgument() throws IllegalValueException {
        setInput("12.34");
    }
    
    @Test(expected=IllegalValueException.class)
    public void testStringArgument() throws IllegalValueException {
        setInput("random stuff");
    }
}
```
###### \java\seedu\todo\logic\arguments\StringArgumentTest.java
``` java
public class StringArgumentTest {
    
    private Argument<String> arg = new StringArgument("test");

    @Test
    public void testSetValue() throws IllegalValueException {
        arg.setValue("Hello world");
        assertTrue(arg.hasBoundValue());
        assertEquals("Hello world", arg.getValue());
    }
    
    @Test
    public void testTrimValue() throws IllegalValueException {
        arg.setValue("  Hello world ");
        assertTrue(arg.hasBoundValue());
        assertEquals("Hello world", arg.getValue());
    }
    
    @Test
    public void testEmptyValue() throws IllegalValueException {
        arg.setValue("  ");
        assertTrue(arg.hasBoundValue());
        assertEquals(arg.getValue(), null);
    }
}
```
###### \java\seedu\todo\logic\commands\BaseCommandTest.java
``` java
public class BaseCommandTest extends CommandTest {
    private Argument<String> requiredArgument = mock(StringArgument.class);
    private Argument<Boolean> flagArgument = mock(FlagArgument.class);
    private Argument<Integer> intArgument = mock(IntArgument.class);
    private Argument<String> stringArgument = mock(StringArgument.class);
    
    private StubCommand stubCommand;

    @Override
    protected BaseCommand commandUnderTest() {
        stubCommand = new StubCommand();
        return stubCommand;
    }
    
    @Before
    public void setUp() throws Exception {
        when(requiredArgument.isPositional()).thenReturn(true);
        when(requiredArgument.toString()).thenReturn("required");
        
        when(flagArgument.isOptional()).thenReturn(true);
        when(flagArgument.getFlag()).thenReturn("f");
        when(flagArgument.toString()).thenReturn("flag");
        
        when(intArgument.isOptional()).thenReturn(true);
        when(intArgument.getFlag()).thenReturn("i");
        when(intArgument.toString()).thenReturn("int");
        
        when(stringArgument.isOptional()).thenReturn(true);
        when(stringArgument.getFlag()).thenReturn("s");
        when(stringArgument.toString()).thenReturn("string");
    }
    
    @Test
    public void testSetParameter() throws Exception {
        this.setParameter("required")
            .setParameter("f", "")
            .setParameter("i", "20")
            .setParameter("s", "Hello World");
        
        execute(true);
        
        verify(requiredArgument).setValue("required");
        verify(flagArgument).setValue("");
        verify(intArgument).setValue("20");
        verify(stringArgument).setValue("Hello World");
    }
    
    @Test
    public void testCustomArgumentError() throws Exception {
        command = new CommandWithOverrideMethods();
        
        try {
            execute(false);
            fail();
        } catch (ValidationException e) {
            assertEquals("Test error message", e.getMessage());
            assertTrue(e.getErrors().getNonFieldErrors().contains("Test error"));
        }
    }
    
    @Test
    public void getArgumentSummary() {
        assertEquals("required flag int string", stubCommand.getArgumentSummaryResult());
    }

    @Test(expected=ValidationException.class)
    public void testMissingRequiredArgument() throws Exception {
        IllegalValueException e = mock(IllegalValueException.class);
        doThrow(e).when(requiredArgument).checkRequired();
        
        execute(false);
    }

    private class StubCommand extends BaseCommand {
        @Override
        protected Parameter[] getArguments() {
            return new Parameter[]{ requiredArgument, flagArgument, intArgument, stringArgument };
        }

        @Override
        public String getCommandName() {
            return "stub";
        }

        @Override
        public List<CommandSummary> getCommandSummary() {
            return ImmutableList.of(mock(CommandSummary.class));
        }

        @Override
        public CommandResult execute() throws ValidationException {
            // Does nothing
            return new CommandResult("Great Success!");
        }
        
        public String getArgumentSummaryResult() {
            return getArgumentSummary();
        }
    }
    
    private class CommandWithOverrideMethods extends StubCommand {
        @Override
        protected String getArgumentErrorMessage() {
            return "Test error message";
        }

        @Override
        protected void validateArguments() {
            errors.put("Test error");
        }
    }
}
```
###### \java\seedu\todo\logic\commands\CommandSummaryTest.java
``` java
public class CommandSummaryTest {
    @Test
    public void testConstructor() {
        CommandSummary summary = new CommandSummary(" Hello  ", "World");
        // Check trim 
        assertEquals("Hello", summary.scenario);
        // Check command is lowercase 
        assertEquals("world", summary.command);
        // Check constructor without third argument
        assertEquals("", summary.arguments);
    }
}
```
###### \java\seedu\todo\logic\commands\CommandTest.java
``` java
/**
 * Base test case for testing commands. All command tests should extend this class. 
 * Provides a simple interface for setting up command testing as well as a number 
 * of assertions to inspect the model. 
 */
public abstract class CommandTest {
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    protected Model model;
    protected TodoList todolist;
    @Mock protected MovableStorage<ImmutableTodoList> storage;
    @Mock protected ImmutableTodoList storageData;
    protected BaseCommand command;
    protected StubParseResult params;
    protected CommandResult result;
    
    abstract protected BaseCommand commandUnderTest();

    @Before
    public void setUpCommand() throws Exception {
        when(storage.read()).thenReturn(storageData);
        when(storageData.getTasks()).thenReturn(Collections.emptyList());
        
        todolist = new TodoList(storage);
        model = new TodoModel(todolist, storage);
        params = new StubParseResult();
        command = commandUnderTest();
    }
    
    /**
     * Returns the task visible in the model at 1-indexed position, mimicking user input
     */
    protected ImmutableTask getTaskAt(int index) {
        return model.getObservableList().get(index - 1);
    }
    
    /**
     * Asserts that the model has this number of tasks stored in internal storage (visible and not visible)
     */
    
    protected void assertTotalTaskCount(int size) {
        assertEquals(size, todolist.getTasks().size());
    }
    
    /**
     * Asserts that the model has this number of tasks visible
     */
    protected void assertVisibleTaskCount(int size) {
        assertEquals(size, model.getObservableList().size());
    }
    
    /**
     * Asserts that the task exists in memory
     */
    protected void assertTaskExist(ImmutableTask task) {
        if (!todolist.getTasks().contains(task)) {
            throw new AssertionError("Task not found in model");
        }
    }
    

    /**
     * Asserts that the task does not exist in memory
     */
    protected void assertTaskNotExist(ImmutableTask task) {
        if (todolist.getTasks().contains(task)) {
            throw new AssertionError("Task found in model");
        }
    }
    
    /**
     * Asserts that the task is visible to the user through the model
     */
    protected void assertTaskVisible(ImmutableTask task) {
        if (!model.getObservableList().contains(task)) {
            throw new AssertionError("Task is not visible");
        }
    }

    /**
     * Asserts that the task is visible to the user through the model. 
     * This can also mean the task is simply not in memory. Use {@link #assertTaskHidden}
     * to assert that the task exists, but is not visible
     */
    protected void assertTaskNotVisible(ImmutableTask task) {
        if (model.getObservableList().contains(task)) {
            throw new AssertionError("Task is visible");
        }
    }
    
    /**
     * Asserts that the task exists, but is not visible to the user through 
     * the model
     */
    protected void assertTaskHidden(ImmutableTask task) {
        assertTaskExist(task); 
        assertTaskNotVisible(task);
    }

    /**
     * Sets the positional parameter for command execution. Can be chained. 
     */
    protected CommandTest setParameter(String positional) {
        params.positional = positional;
        return this;
    }
    
    /**
     * Sets the named argument for command execution. Can be chained. 
     */
    protected CommandTest setParameter(String flag, String value) {
        params.named.put(flag, value);
        return this;
    }
    
    @Test
    public void testCommonProperties() {
        assertNotNull(command.getArguments());
        assertThat(command.getCommandName(), not(containsString(" ")));
        assertThat(command.getCommandSummary().size(), greaterThan(0));
    }
    
    /**
     * Executes the command
     */
    protected void execute(boolean expectSuccess) throws ValidationException {
        command.setArguments(params);
        command.setModel(model);
        result = command.execute();
        
        assertEquals(expectSuccess, result.isSuccessful());
        
        // Resets the command object for re-execution
        command = commandUnderTest();
        params = new StubParseResult();
    }

    private class StubParseResult implements ParseResult {
        public String command;
        public String positional;
        public Map<String, String> named = new HashMap<>();

        @Override
        public String getCommand() {
            return command;
        }

        @Override
        public Optional<String> getPositionalArgument() {
            return Optional.ofNullable(positional);
        }

        @Override
        public Map<String, String> getNamedArguments() {
            return named;
        }
    }
}
```
###### \java\seedu\todo\logic\commands\ExitCommandTest.java
``` java
public class ExitCommandTest extends CommandTest {
    @Override
    protected BaseCommand commandUnderTest() {
        return new ExitCommand();
    }
    
    @Test
    public void testExecute() throws IllegalValueException, ValidationException {
        EventsCollector eventCollector = new EventsCollector();
        execute(true);
        assertThat(eventCollector.get(0), instanceOf(ExitAppRequestEvent.class));
    }

}
```
###### \java\seedu\todo\logic\commands\FindCommandTest.java
``` java
    @Test
    public void testFindWithFilter() throws ValidationException {
        TaskViewFilter filter = new TaskViewFilter("test", t -> t.getTitle().contains("CS2101"), null);
        model.view(filter);
        
        setParameter("Task");
        execute(true);
        assertVisibleTaskCount(1);
    }
    
    @Test
    public void testFindTag() throws ValidationException {
        setParameter("t", "Gamma");
        execute(true);
        assertVisibleTaskCount(1);
    }

    @Test
    public void testFindMultipleTag() throws ValidationException {
        setParameter("t", "Gamma, Beta");
        execute(true);
        assertVisibleTaskCount(3);
    }

    @Test
    public void testPartialFindTag() throws ValidationException {
        setParameter("t", "Ga");
        execute(true);
        assertVisibleTaskCount(0);
    }

    @Test
    public void testKeywordAndTag() throws ValidationException {
        setParameter("t", "Gamma");
        setParameter("CS2101");
        execute(true);
        assertVisibleTaskCount(3);
    }

    @Test
    public void testDismissFind() throws ValidationException {
        setParameter("project");
        execute(true);
        assertVisibleTaskCount(2);
        assertNotNull(model.getSearchStatus().getValue());

        setParameter("");
        execute(true);
        assertVisibleTaskCount(4);
        assertNull(model.getSearchStatus().getValue());
    }
}
```
###### \java\seedu\todo\logic\commands\HelpCommandTest.java
``` java
public class HelpCommandTest extends CommandTest {
    @Override
    protected BaseCommand commandUnderTest() {
        return new HelpCommand();
    }
    
    @Test
    public void testExecute() throws Exception {
        EventsCollector eventsCollector = new EventsCollector();
        execute(true);
        assertThat(eventsCollector.get(0), instanceOf(ShowHelpEvent.class));
    }

}
```
###### \java\seedu\todo\logic\commands\LoadCommandTest.java
``` java
/**
 * This is an integration test for the {@code load} command. For tests on the 
 * load functionality itself, see {@link seedu.todo.storage.TodoListStorageTest}
 */
public class LoadCommandTest extends CommandTest {
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();
    
    @Mock private ImmutableTodoList tasks;
    
    @Override
    protected BaseCommand commandUnderTest() {
        return new LoadCommand();
    }
    
    @Test
    public void testSaveLocation() throws Exception {
        setParameter("new file");
        when(storage.read("new file")).thenReturn(tasks);
        when(tasks.getTasks()).thenReturn(ImmutableList.of(new Task("Hello world")));
            
        execute(true);
        assertEquals("Hello world", getTaskAt(1).getTitle());
    }

    @Test(expected = ValidationException.class)
    public void testHandleFileError() throws Exception {
        setParameter("new file");
        doThrow(new FileNotFoundException()).when(storage).read("new file");
        execute(false);
    }

}
```
###### \java\seedu\todo\logic\commands\PinCommandTest.java
``` java
public class PinCommandTest extends CommandTest {

    @Override
    protected BaseCommand commandUnderTest() {
        return new PinCommand();
    }
}
```
###### \java\seedu\todo\logic\commands\RedoCommandTest.java
``` java
public class RedoCommandTest extends CommandTest {
    @Override
    protected BaseCommand commandUnderTest() {
        return new RedoCommand();
    }
    
    /**
     * This is an integration test for the redo command. For a more detailed test on the model itself 
     * {@link seedu.todo.model.TodoModelTest#testRedo} and other related tests 
     */
    @Test
    public void testExecute() throws Exception {
        model.add("Test task");
        model.undo();
        execute(true);
        assertEquals("Test task", getTaskAt(1).getTitle());
    }
    
    @Test(expected = ValidationException.class)
    public void testIncorrectExecute() throws Exception {
        execute(false);
    }
}
```
###### \java\seedu\todo\logic\commands\SaveCommandTest.java
``` java
public class SaveCommandTest extends CommandTest {
    @Test
    public void testGetStorageLocation() throws Exception {
        when(storage.getLocation()).thenReturn("test location");
        execute(true);
        
        assertThat(result.getFeedback(), containsString("test location"));
        verify(storage, never()).save(eq(todolist), anyString());
    }
    
    @Test
    public void testSaveLocation() throws Exception {
        setParameter("new file");
        execute(true);
        verify(storage).save(todolist, "new file");
    }
    
    @Test(expected = ValidationException.class)
    public void testHandleFileError() throws Exception {
        setParameter("new file");
        doThrow(new IOException()).when(storage).save(todolist, "new file");
        execute(false);
    }
    
    @Override
    protected BaseCommand commandUnderTest() {
        return new SaveCommand();
    }
}
```
###### \java\seedu\todo\logic\commands\TagCommandTest.java
``` java
    @Test
    public void testDeleteTag_caseInsensitivity() throws Exception {
        // Tagging a task with the same tag but in different case should cause the tag to be renamed
        setParameter("2");
        setParameter("d", TAG_NAMES[0].toUpperCase());
        execute(true);
        assertEquals(0, getTaskAt(2).getTags().size());
    }

```
###### \java\seedu\todo\logic\commands\UndoCommandTest.java
``` java
public class UndoCommandTest extends CommandTest {

    @Override
    protected BaseCommand commandUnderTest() {
        return new UndoCommand();
    }

    /**
     * This is an integration test for the redo command. For a more detailed test on the model itself 
     * {@link TodoModelTest#testUndo} and other related tests 
     */
    @Test
    public void testUndo() throws Exception {
        model.add("Test task");
        execute(true);
    }
    
    @Test(expected = ValidationException.class)
    public void testEmptyUndo() throws Exception {
        execute(false);
    }

```
###### \java\seedu\todo\logic\parser\TodoParserTest.java
``` java
public class TodoParserTest {
    private Parser parser = new TodoParser();
    
    @Test
    public void testParse() {
        ParseResult p;
        
        p = parser.parse("hello");
        assertEquals("hello", p.getCommand());
        
        p = parser.parse("HeLLo");
        assertEquals("hello", p.getCommand());
        
        p = parser.parse("HELLO");
        assertEquals("hello", p.getCommand());
        
        p = parser.parse("hello world");
        assertEquals("hello", p.getCommand());
        
        p = parser.parse("  hello ");
        assertEquals("hello", p.getCommand());
    }
    
    @Test
    public void testPositionalArgument() {
        ParseResult p;
        
        p = parser.parse("hello world");
        assertEquals("world", p.getPositionalArgument().get());
        
        p = parser.parse("hello one two three");
        assertEquals("one two three", p.getPositionalArgument().get());
        
        p = parser.parse("hello   one   two  three  ");
        assertEquals("one two three", p.getPositionalArgument().get());
    }
    
    @Test
    public void testNamedArguments() {
        ParseResult p;
        
        p = parser.parse("hello /f");
        assertEquals(1, p.getNamedArguments().size());
        assertTrue(p.getNamedArguments().containsKey("f"));
        
        p = parser.parse("hello /f Hello");
        assertEquals(1, p.getNamedArguments().size());
        assertEquals("Hello", p.getNamedArguments().get("f"));
        
        p = parser.parse("hello  /f   Hello ");
        assertEquals(1, p.getNamedArguments().size());
        assertEquals("Hello", p.getNamedArguments().get("f"));
        
        p = parser.parse("hello /all Hello");
        assertEquals(1, p.getNamedArguments().size());
        assertEquals("Hello", p.getNamedArguments().get("all"));
        
        p = parser.parse("hello /f Hello /p /all");
        assertEquals(3, p.getNamedArguments().size());
        assertEquals("Hello", p.getNamedArguments().get("f"));
        assertTrue(p.getNamedArguments().containsKey("p"));
        assertTrue(p.getNamedArguments().containsKey("all"));
    }
    
    @Test
    public void testInvalidFlags() {
        ParseResult p;
        
        p = parser.parse("hello /");
        assertTrue(p.getPositionalArgument().isPresent());
        assertEquals(0, p.getNamedArguments().size());
    }

}
```
###### \java\seedu\todo\logic\TodoLogicTest.java
``` java
public class TodoLogicTest {
    private static final String INPUT = "input";
    private static final String COMMAND = "command";

    @Rule
    public MockitoRule rule = MockitoJUnit.rule();
    
    @Mock private Parser parser; 
    @Mock private Dispatcher dispatcher;
    @Mock private ParseResult parseResult;
    @Mock private Model model;
    @Mock private BaseCommand command;
    
    private Logic logic;

    @Before
    public void setUp() throws Exception {
        // Wire up some default behavior 
        when(parser.parse(TodoLogicTest.INPUT))
            .thenReturn(parseResult);
        when(parseResult.getCommand())
            .thenReturn(TodoLogicTest.COMMAND);
        when(dispatcher.dispatch(TodoLogicTest.COMMAND))
            .thenReturn(command);

        logic = new TodoLogic(parser, model, dispatcher);
    }
    
    private CommandResult execute() throws Exception {
        CommandResult r = logic.execute(TodoLogicTest.INPUT);

        verify(parser).parse(TodoLogicTest.INPUT);
        verify(dispatcher).dispatch(TodoLogicTest.COMMAND);
        
        return r;
    }
    
    @Test
    public void testExecute() throws Exception {
        execute();
        
        verify(command).setModel(model);
        verify(command).setArguments(parseResult);
        verify(command).execute();
        
        // Logic should not touch model directly 
        verifyZeroInteractions(model);
    }
    
    @Test
    public void testArgumentError() throws Exception {
        // Create a stub exception for setArguments to throw
        ValidationException e = mock(ValidationException.class);
        ErrorBag errors = mock(ErrorBag.class);
        
        when(e.getErrors()).thenReturn(errors);
        doThrow(e).when(command).setArguments(parseResult);
        
        CommandResult r = execute();
        
        assertFalse(r.isSuccessful());
        // Make sure the command is never executed 
        verify(command, never()).execute();
    }
    
    @Test
    public void testExecuteError() throws Exception {
        // Create a stub exception for execute to throw
        ValidationException e = mock(ValidationException.class);
        ErrorBag errors = mock(ErrorBag.class);

        when(e.getErrors()).thenReturn(errors);
        doThrow(e).when(command).execute();

        CommandResult r = execute();
        
        assertFalse(r.isSuccessful());
        assertEquals(errors, r.getErrors());
    }
    
    @Test
    public void testDispatchError() throws Exception {
        // Create a stub exception for execute to throw
        IllegalValueException e = mock(IllegalValueException.class);
        when(e.getMessage()).thenReturn("Test message");
        doThrow(e).when(dispatcher).dispatch(TodoLogicTest.COMMAND);

        CommandResult r = execute();

        assertFalse(r.isSuccessful());
        assertEquals("Test message", r.getFeedback());
    }
    
    @Test
    public void testEmptyInput() throws Exception {
        CommandResult r = logic.execute("");
        
        assertNotNull(r);
        assertNotNull(r.getFeedback());
        verifyZeroInteractions(parser);
    }
}
```
###### \java\seedu\todo\model\ErrorBagTest.java
``` java
public class ErrorBagTest {
    
    private ErrorBag errorBag = new ErrorBag();

    @Test
    public void testPutString() {
        errorBag.put("Hello World");
        errorBag.put("Another error");
        
        assertEquals(0, errorBag.getNonFieldErrors().indexOf("Hello World"));
        assertEquals(1, errorBag.getNonFieldErrors().indexOf("Another error"));
        
        assertEquals(2, errorBag.size());
        assertEquals(0, errorBag.getFieldErrors().size());
    }

    @Test
    public void testPutStringString() {
        errorBag.put("a", "Hello World");
        errorBag.put("b", "Another error");
        
        assertEquals("Hello World", errorBag.getFieldErrors().get("a"));
        assertEquals("Another error", errorBag.getFieldErrors().get("b"));
        
        assertEquals(2, errorBag.size());
        assertEquals(0, errorBag.getNonFieldErrors().size());
    }

    @Test
    public void testSize() {
        errorBag.put("Hello World");
        errorBag.put("a", "Hello World");
        
        assertEquals(2, errorBag.size());
    }

    @Test
    public void testValidateNoErrors() throws ValidationException {
        assertEquals(0, errorBag.size());
        errorBag.validate("Validation message");
    }
    

    @Test(expected=ValidationException.class)
    public void testValidateWithErrors() throws ValidationException {
        errorBag.put("Hello World");
        errorBag.put("a", "Hello World");
        
        errorBag.validate("Validation message");
    }
    
    @Test
    public void testValidationException() {
        errorBag.put("Hello World");
        errorBag.put("a", "Hello World");
        
        try {
            errorBag.validate("Validation message");
        } catch (ValidationException e) {
            assertEquals(errorBag, e.getErrors());
            assertEquals("Validation message", e.getMessage());
        }
        
    }

}
```
###### \java\seedu\todo\model\property\TaskViewFilterTest.java
``` java
public class TaskViewFilterTest {
    @Test
    public void testNoOverlappingShortcut() {
        Set<Character> shortcuts = new HashSet<>();
        
        for (TaskViewFilter filter : TaskViewFilter.all()) {
            char shortcut = filter.name.charAt(filter.shortcutCharPosition);
            assertFalse(shortcuts.contains(shortcut));
            shortcuts.add(shortcut);
        }
    }
}
```
###### \java\seedu\todo\model\tag\TagTest.java
``` java
public class TagTest {
    @Test
    public void testSimpleEquality() {
        Tag t = new Tag("world");
        assertEquals(t, t);
        assertEquals(new Tag("hello"), new Tag("hello"));
        assertEquals(new Tag("world"), t);
    }
    
    @Test
    public void testLowerCaseEquality() {
        assertEquals(new Tag("HELLO"), new Tag("hello"));
        assertEquals(new Tag("heLlo"), new Tag("HelLo"));
        assertEquals(new Tag("HELLO"), new Tag("hello"));
    }
    
    @Test
    public void testHashCode() {
        assertEquals(new Tag("hello").hashCode(), new Tag("hello").hashCode());
        assertEquals(new Tag("HEllO").hashCode(), new Tag("hello").hashCode());
        assertEquals(new Tag("heLlo").hashCode(), new Tag("hello").hashCode());
    }
}
```
###### \java\seedu\todo\model\task\ImmutableTaskTest.java
``` java
/**
 * This set of tests check that every implementation of ImmutableTask are equal and 
 * generates the same hashCode as each other when their copy constructor is used. 
 */
public class ImmutableTaskTest {
    private ImmutableTask reference = TaskFactory.fullEvent();
    
    private List<ImmutableTask> tasks = ImmutableList.of(
        new ValidationTask(reference), 
        new Task(reference)
    );
    
    private void permuteTasks(Function<ImmutableTask, Object> mapper) {
        Object referenceProperty = mapper.apply(reference);
        
        for (int i = 0; i < tasks.size(); i++) {
            ImmutableTask subject = tasks.get(i);
            Object subjectProperty = mapper.apply(subject);
            
            assertEquals(subjectProperty, referenceProperty);
            assertEquals(referenceProperty, subjectProperty);

            for (int j = i; j < tasks.size(); j++) {
                assertEquals(subjectProperty, mapper.apply(tasks.get(i)));
                assertEquals(mapper.apply(tasks.get(i)), subjectProperty);
            }
        }
    }
    
    @Test
    public void testEquality() {
        permuteTasks(task -> task);
    }

    @Test
    public void testHashing() {
        permuteTasks(Object::hashCode);
    }
    
    @Test
    public void testProperties() {
        permuteTasks(ImmutableTask::getTitle);
        permuteTasks(ImmutableTask::getTags);
        permuteTasks(ImmutableTask::getDescription);
        permuteTasks(ImmutableTask::getStartTime);
        permuteTasks(ImmutableTask::getEndTime);
        permuteTasks(ImmutableTask::getLocation);
        permuteTasks(ImmutableTask::isCompleted);
        permuteTasks(ImmutableTask::isEvent);
        permuteTasks(ImmutableTask::isPinned);
        permuteTasks(ImmutableTask::getCreatedAt);
    }
}
```
###### \java\seedu\todo\model\task\TaskTest.java
``` java
public class TaskTest {
    private Task task;

    @Before
    public void setUp() throws Exception {
        task = new Task("Test Task");
    }

    @Test
    public void testTaskString() {
        assertEquals("Test Task", task.getTitle());
    }

    @Test
    public void testTaskImmutableTask() {
        Task original = new Task("Mock Task");
        assertAllPropertiesEqual(original, new Task(original));

        original = new Task("Mock Task");
        original.setStartTime(LocalDateTime.now());
        original.setEndTime(LocalDateTime.now().plusHours(2));
        assertAllPropertiesEqual(original, new Task(original));

        original = new Task("Mock Task");
        original.setDescription("A Test Description");
        original.setLocation("Test Location");
        assertAllPropertiesEqual(original, new Task(original));
    }

    @Test
    public void testTitle() {
        task.setTitle("New Title");
        assertEquals("New Title", task.getTitle());
    }

    @Test
    public void testDescription() {
        assertFalse(task.getDescription().isPresent());

        task.setDescription("A short description");
        assertEquals("A short description", task.getDescription().get());
    }

    @Test
    public void testLocation() {
        assertFalse(task.getLocation().isPresent());

        task.setLocation("Some Test Location");
        assertEquals("Some Test Location", task.getLocation().get());
    }

    @Test
    public void testTime() {
        assertFalse(task.getStartTime().isPresent());
        assertFalse(task.getEndTime().isPresent());
    }

    @Test
    public void testPinned() {
        assertFalse(task.isPinned());

        task.setPinned(true);
        assertTrue(task.isPinned());
    }

    @Test
    public void testLastUpdated() throws Exception {
        assertNotNull(task.getCreatedAt());

        LocalDateTime anotherTime = LocalDateTime.now().minusDays(1);

        task.setCreatedAt(anotherTime);
        assertEquals(anotherTime, task.getCreatedAt());
    }
    
    @Test
    public void testLastUpdatedNull() throws Exception {
        task.setCreatedAt(null);
        assertNotNull(task.getCreatedAt());
    }

    @Test
    public void testCompleted() {
        assertFalse(task.isCompleted());

        task.setCompleted(true);
        assertTrue(task.isCompleted());
    }


    @Test
    public void testTags() throws ValidationException {
        assertEquals(0, task.getTags().size());

        Set<Tag> tags = new HashSet<>();
        tags.add(new Tag("Hello"));
        tags.add(new Tag("World"));
        task.setTags(tags);

        assertEquals(2, task.getTags().size());
    }
    
    @Test
    public void testIsEvent() throws Exception {
        assertFalse(task.isEvent());
        
        task.setEndTime(LocalDateTime.now());
        assertFalse(task.isEvent());
        
        task.setStartTime(LocalDateTime.now().minusHours(4));
        assertTrue(task.isEvent());
    }

    @Test
    public void testGetObservableProperties() {
        assertEquals(8, task.getObservableProperties().length);
    }

    @Test
    public void testGetUUID() {
        assertNotNull(task.getUUID());
    }

    @Test
    public void testEqualsObject() {
        ImmutableTask stubTask = mock(ImmutableTask.class);
        when(stubTask.getUUID()).thenReturn(task.getUUID());
        assertEquals(task, stubTask);
        assertFalse(task.equals(12));
    }

}
```
###### \java\seedu\todo\model\TodoModelTest.java
``` java
public class TodoModelTest {
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    @Rule
    public final ExpectedException exception = ExpectedException.none();
    
    @Mock private MovableStorage<ImmutableTodoList> storage;
    @Mock private ImmutableTodoList storageData;
    
    private TodoList todolist;
    private TodoModel model;
    private UnmodifiableObservableList<ImmutableTask> observableList;

    @Before
    public void setUp() throws Exception {
        when(storage.read()).thenReturn(storageData);
        when(storageData.getTasks()).thenReturn(Collections.emptyList());

        todolist = new TodoList(storage);
        model = new TodoModel(todolist, storage);
        observableList = model.getObservableList();
    }
    
    @Test
    public void testUpdateDateFields() throws Exception {
        model.add("Test Task");

        assertNotNull(model.update(1, t -> {
            t.setStartTime(TimeUtil.now);
            t.setEndTime(TimeUtil.now.plusHours(4));
        }));

        ImmutableTask task = observableList.get(0);
        assertEquals(TimeUtil.now, task.getStartTime().get());
        assertEquals(TimeUtil.now.plusHours(4), task.getEndTime().get());

        model.update(1, t -> t.setEndTime(TimeUtil.now));
        task = observableList.get(0);
        assertEquals(TimeUtil.now, task.getStartTime().get());
        assertEquals(TimeUtil.now, task.getEndTime().get());
    }

    @Test
    public void testPinning() throws Exception {
        model.add("Task 1");
        model.add("Task 2");
        model.add("Task 3");

        // Get the last item and pin it
        ImmutableTask lastTask = observableList.get(2);
        model.update(3, t -> t.setPinned(true));

        assertTrue(observableList.get(0).isPinned());
        assertEquals(lastTask.getTitle(), observableList.get(0).getTitle());
    }


    @Test(expected = ValidationException.class)
    public void testIllegalUpdate() throws Exception {
        model.add("Foo Bar Test");
        model.update(2, t -> t.setTitle("Test 2"));
    }

    @Test(expected = ValidationException.class)
    public void testIllegalDelete() throws Exception {
        model.add("Foo Bar Test");
        model.delete(2);
    }
    
    @Test
    public void testFilteredDelete() throws Exception {
        model.add("First");
        model.add("Second");
        model.find(t -> t.getTitle().equals("Second"));
        model.delete(1);
        assertEquals("First", getTask(0).getTitle());
    }
    
    @Test
    public void testFilteredUpdate() throws Exception {
        model.add("First");
        model.add("Second");
        model.find(t -> t.getTitle().equals("Second"));
        model.update(1, t -> t.setTitle("New Title"));
        assertEquals("New Title", getTask(1).getTitle());
    }
    
```
###### \java\seedu\todo\model\TodoModelTest.java
``` java
    @Test
    public void testSorting() throws Exception {
        model.add("Task 3", p -> p.setEndTime(TimeUtil.now));
        model.add("Task 2", p -> p.setEndTime(TimeUtil.now.plusHours(2)));
        model.add("Task 1", p -> p.setEndTime(TimeUtil.now.plusHours(1)));

        TaskViewFilter lexi = new TaskViewFilter("lexi", 
            null, (a, b) -> a.getTitle().compareTo(b.getTitle()));
        TaskViewFilter chrono = new TaskViewFilter("chrono", 
            null, (a, b) -> a.getEndTime().get().compareTo(b.getEndTime().get()));

        // Check that the items are sorted in lexicographical order by title
        model.view(lexi);
        assertEquals("Task 1", observableList.get(0).getTitle());
        assertEquals("Task 2", observableList.get(1).getTitle());
        assertEquals(3, observableList.size());

        // Insert an item that comes before all others lexicographically
        model.add("Task 0", p -> p.setEndTime(TimeUtil.now.plusHours(3)));
        assertEquals("Task 0", observableList.get(0).getTitle());

        // Change its title and check that it has moved down
        model.update(1, t -> t.setTitle("Task 4"));
        assertEquals("Task 1", observableList.get(0).getTitle());
        assertEquals("Task 4", observableList.get(3).getTitle());

        // Check that sorting by time works
        // Chronological ordering would give us Task 3, 1, 2, 4
        model.view(chrono);
        assertEquals("Task 3", observableList.get(0).getTitle());
        assertEquals("Task 1", observableList.get(1).getTitle());
        assertEquals("Task 2", observableList.get(2).getTitle());
        assertEquals("Task 4", observableList.get(3).getTitle());
    }

    @Test
    public void testFiltering() throws Exception {
        model.add("Foo");
        model.add("FooBar");
        model.add("Bar");
        model.add("Bar Bar");

        // Give us only tasks with "Foo" in the title
        model.find(t -> t.getTitle().contains("Foo"));
        assertEquals(2, observableList.size());
    }

    @Test
    public void testSave() throws Exception {
        model.save("new location");
        verify(storage).save(todolist, "new location");
    }

    @Test
    public void testLoad() throws Exception {
        model.add("Some task");
        
        when(storageData.getTasks())
            .thenReturn(ImmutableList.of(new Task("Hello world")));
        when(storage.read("new location")).thenReturn(storageData);

        model.load("new location");
        // Check that the task list has been replaced 
        assertEquals(1, todolist.getTasks().size());
        assertEquals("Hello world", getTask(0).getTitle());
    }
    
    @Test
    public void testUndo() throws Exception {
        model.add("Test task 1");
        model.add("Test task 2");
        
        // Undo add 
        model.undo();
        assertEquals(1, todolist.getTasks().size());
        assertEquals("Test task 1", getTask(0).getTitle());
        
        // Undo edit 
        model.update(1, t -> t.setTitle("New title"));
        model.undo();
        assertEquals("Test task 1", getTask(0).getTitle());
        
        // Undo delete
        model.delete(1);
        model.undo();
        assertEquals(1, todolist.getTasks().size());
    }
    
    @Test
    public void testPersistAfterUndo() throws Exception {
        model.add("Test task 1");
        model.undo();
        verify(storage, times(2)).save(todolist);
    }
    
    @Test
    public void testUndoStackSize() throws Exception {
        final int STACK_SIZE = 10;
        
        // Add 11 items (which will add 11 to the undo stack) 
        for (int i = 0; i < STACK_SIZE + 1; i++) {
            model.add(TaskFactory.taskTitle());
        }
        
        // Undo until the undo stack is empty 
        for (int i = 0; i < STACK_SIZE; i++) {
            model.undo();
        }
        
        // Make sure the last undo throws an exception, even though 11 add 
        // events were recorded 
        exception.expect(ValidationException.class);
        model.undo();
    }
    
    @Test(expected = ValidationException.class)
    public void testOnlyUndoDataChanges() throws Exception {
        // Actions that does not cause underlying data to change should not cause 
        // undo stack to increase
        model.find(ImmutableTask::isCompleted);
        model.undo();
    }
    
    @Test(expected = ValidationException.class)
    public void testEmptyUndoStack() throws Exception {
        model.undo();
    }
    
    @Test
    public void testRedo() throws Exception {
        model.add("Test task 1");
        model.add("Test task 2");
        model.add("Test task 3");

        // Undo then redo add 
        model.undo();
        model.undo();
        assertEquals(1, todolist.getTasks().size());
        
        model.redo();
        assertEquals(2, todolist.getTasks().size());
        assertEquals("Test task 2", getTask(1).getTitle());
        
        model.redo();
        assertEquals(3, todolist.getTasks().size());
        assertEquals("Test task 3", getTask(2).getTitle());
    }

    @Test
    public void testPersistAfterRedo() throws Exception {
        model.add("Test task 1");
        model.undo();
        model.redo();
        verify(storage, times(3)).save(todolist);
    }
    
    @Test
    public void testActionAfterRedoClearsStack() throws Exception {
        model.add("Test task 1");
        model.add("Test task 2");
        model.add("Test task 3");

        // Undo then redo add 
        model.undo();
        model.undo();
        assertEquals(1, todolist.getTasks().size());

        model.redo();
        assertEquals(2, todolist.getTasks().size());
        assertEquals("Test task 2", getTask(1).getTitle());
        
        // There should be at least one more undo in this, but by performing 
        // an action we should invalidate the undo stack
        model.add("Test task 4");
        exception.expect(ValidationException.class);
        model.redo();
    }
    
    @Test(expected = ValidationException.class)
    public void testEmptyRedoStack() throws Exception {
        model.redo();
    }

    @Test
    public void testGetSaveLocation() throws Exception {
        when(storage.getLocation()).thenReturn("test location");
        assertEquals("test location", model.getStorageLocation());
    }

    /**
     * Get the task at the zero-index position in memory (reverse insertion order)
     */
    private ImmutableTask getTask(int index) {
        return todolist.getTasks().get(index);
    }

}
```
###### \java\seedu\todo\model\TodoTest.java
``` java
public class TodoTest {
    @Rule
    public final ExpectedException exception = ExpectedException.none();

    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    @Mock private MovableStorage<ImmutableTodoList> storage;
    @Mock private ImmutableTodoList storageData;
    private TodoList todo;

    @Before
    public void setUp() throws Exception {
        when(storage.read()).thenReturn(storageData);
        todo = new TodoList(storage);
    }

    @Test
    public void testEmptyStorage() throws Exception {
        when(storage.read()).thenThrow(new FileNotFoundException());
        todo = new TodoList(storage);

        assertThat(todo.getTasks(), empty());
    }

    @Test
    public void testRestoreFromStorage() {
        // Create a mock todo list, add it to mock storage and try to get
        // TodoList to retrieve it
        Task task1 = new Task("Task 1");
        Task task2 = new Task("Task 2");

        when(storageData.getTasks()).thenReturn(ImmutableList.of(task1, task2));
        todo = new TodoList(storage);

        assertEquals(2, todo.getTasks().size());
        assertTrue(todo.getTasks().contains(task1));
        assertTrue(todo.getTasks().contains(task2));
    }

    @Test
    public void testAdd() throws Exception {
        assertNotNull(todo.add("Test Task 1"));
        assertEquals(1, todo.getTasks().size());
        assertFalse(getTask(0).isPinned());
        assertFalse(getTask(0).isCompleted());
        verify(storage).save(todo);

        assertNotNull(todo.add("Test Task 2"));
        assertEquals(2, todo.getTasks().size());
        assertEquals("Test Task 1", getTask(0).getTitle());
        assertEquals("Test Task 2", getTask(1).getTitle());
        verify(storage, times(2)).save(todo);
    }

    @Test
    public void testCreatedAt() throws Exception {
        LocalDateTime initialTime = LocalDateTime.now().minusSeconds(1);

        LocalDateTime firstCreatedAt = todo.add("Test Task 1").getCreatedAt();
        assertTrue(firstCreatedAt.isAfter(initialTime));

        // Delay for a bit
        Thread.sleep(1);
        LocalDateTime secondCreatedAt = todo.add("Test Task 2").getCreatedAt();
        assertTrue(secondCreatedAt.isAfter(firstCreatedAt));
    }

    @Test
    public void testUpdate() throws Exception {
        final String DESCRIPTION = "Really long description blah blah blah";
        final String TITLE = "New title";
        
        todo.add("Old Title");

        // Check that updating string fields work
        assertNotNull(todo.update(0, t -> {
            t.setTitle(TITLE);
            t.setDescription(DESCRIPTION);
        }));

        assertEquals(TITLE, getTask(0).getTitle());
        assertEquals(DESCRIPTION, getTask(0).getDescription().get());
        verify(storage, times(2)).save(todo);
    }
    
    @Test
    public void testUpdateUUID() throws Exception {
        ImmutableTask task = todo.add(TaskFactory.taskTitle());
        UUID taskUUID = task.getUUID();
        int hashCode = task.hashCode();
        
        todo.update(0, mutableTask -> {
            assertEquals(taskUUID, mutableTask.getUUID());
            assertEquals(hashCode, mutableTask.hashCode());
            assertEquals(mutableTask, task);
        });
    }

    @Test
    public void testUpdateBooleanFields() throws Exception {
        todo.add("Test Task");

        // Check that updating boolean fields work
        assertNotNull(todo.update(0, t -> t.setPinned(true)));
        assertTrue(getTask(0).isPinned());
        verify(storage, times(2)).save(todo);

        assertNotNull(todo.update(0, t -> t.setCompleted(true)));
        assertTrue(getTask(0).isCompleted());
        verify(storage, times(3)).save(todo);
    }
    
```
###### \java\seedu\todo\model\TodoTest.java
``` java
    @Test
    public void testDeleting() throws Exception {
        todo.add("Foo");
        todo.add("FooBar");
        todo.add("Bar");
        todo.add("Bar Bar");

        // Delete the first task, then check that it has been deleted
        ImmutableTask topTask = todo.getObservableList().get(0);
        todo.delete(0);
        assertFalse(todo.getTasks().contains(topTask));
        assertEquals(3, todo.getTasks().size());
        verify(storage, times(5)).save(todo);

        // Continue deleting the top task until the list is empty
        todo.delete(0);
        verify(storage, times(6)).save(todo);
        List<Integer> indexes = new ArrayList<>();
        indexes.add(0);
        indexes.add(1);
        todo.delete(indexes);
        verify(storage, times(7)).save(todo);

        assertTrue(todo.getTasks().isEmpty());
    }

    @Test
    public void testEditSetEmptyTitle() throws Exception {
        todo.add("Task 1");

        try {
            todo.update(0, t -> t.setTitle(""));
            fail();
        } catch (ValidationException e) {
            // Check that the bad update didn't go through
            assertEquals("Task 1", getTask(0).getTitle());
        }
    }

    @Test
    public void testEdit() throws Exception {
        todo.add("Task 1");

        try {
            todo.update(0, t -> {
                t.setStartTime(LocalDateTime.now());
                t.setTitle("Title changed");
            });
            fail();
        } catch (ValidationException e) {
            assertEquals("Task 1", getTask(0).getTitle());
        }
    }

    @Test
    public void testAddOnlyStartDate() throws Exception {
        try {
            todo.add("Task 1", t -> t.setStartTime(LocalDateTime.now()));
            fail();
        } catch (ValidationException e) {
            // Check that the new task is not added to the list
            assertEquals(0, todo.getTasks().size());
        }
    }

    @Test(expected = ValidationException.class)
    public void testAddInvalidDateRange() throws Exception {
        todo.add("Task 1", t -> {
            t.setStartTime(LocalDateTime.now());
            t.setEndTime(LocalDateTime.now().minusHours(2));
        });
    }

    private ImmutableTask getTask(int index) {
        return todo.getTasks().get(index);
    }
}
```
###### \java\seedu\todo\testutil\TaskFactory.java
``` java
public class TaskFactory {
    private static final Faker faker = new Faker(new Locale("en", "SG"));
    private static final Random random = new Random();
    
    private static final List<String> friends = ImmutableList.of(
        "Govind", "Li Kai", "Louie", "Xien Dong", "Alex", "Jim"
    );
    
    private static final List<String> locations = ImmutableList.of(
        "LT15", "School of Computing", "Engineering Canteen", "Cafe Nowhere", 
        "Cinnamon College", "West Coast Plaza"
    );
    
    // For realism the test subject shall only have 5 modules 
    // And no Govind, he's not taking a double degree
    private static final List<String> modules = ImmutableList.of(
        "MA1521", "CS2104", "GET1025", "CS1231", "CS2100");
    
    private static final List<String> tags = ImmutableList.of(
        "urgent", "homework", "assignment", "tea_time", "pokemon_go", "to-do-12",
        "sports", "dinner", "CS2103T", "physics", "chemistry", "econs", "math"
    );
    
    private static final List<String> events = ImmutableList.of(
        "Watch {sport} match with {friend}",
        "Watch the next {superhero} movie with {friend}",
        "Attend concert with {friend}"
    );
    
    private static final List<String> tasks = ImmutableList.of(
        "Finish {module} homework {number}", 
        "Do {module} assignment #{number}", 
        "Do {module} lab #{number}", 
        "Prepare for {module} test", 
        "Discuss {module} project with {friend}",
        "Fix bug #{number}", 
        "Read new novel from {name}",
        "Research on new ways to get {power}"
    );
    
    private static <T> T choice(List<T> choices) {
        return choices.get(random.nextInt(choices.size()));
    }
    
    private static String substitute(String format) {
        return format
            .replace("{friend}", choice(friends))
            .replace("{module}", choice(modules))
            .replace("{name}", faker.name().fullName())
            .replace("{sport}", faker.team().sport())
            .replace("{superhero}", faker.superhero().name())
            .replace("{power}", faker.superhero().power())
            .replace("{number}", Integer.toString(random.nextInt(6) + 1));
    }
    
    private static LocalDateTime randomDate() {
        return TimeUtil.today()
            .plusDays(random.nextInt(20))
            .plusHours(random.nextInt(12) + 9)
            .plusMinutes(random.nextInt(3) * 15);
    }
    
    public static String taskTitle() {
        return substitute(choice(tasks));
    }
    
    public static String eventTitle() {
        return substitute(choice(events));
    }

```
###### \java\seedu\todo\testutil\TaskFactory.java
``` java
    public static ImmutableTask task() {
        return TaskBuilder.name(taskTitle()).build();
    }

    public static ImmutableTask fullTask() {
        return TaskBuilder.name(taskTitle())
            .description(faker.lorem().paragraph(2))
            .due(randomDate())
            .build();
    }

    public static ImmutableTask fullTaggedTask() {
        return TaskBuilder.name(taskTitle())
            .description(faker.lorem().paragraph(2))
            .due(randomDate())
            .tagged(randomTags())
            .build();
    }
    
    public static ImmutableTask event() {
        LocalDateTime start = randomDate();
        return TaskBuilder.name(eventTitle())
            .event(start, start.plusMinutes((random.nextInt(6) + 2) * 15))
            .build();
    }
    
    public static ImmutableTask fullEvent() {
        LocalDateTime start = randomDate();
        return TaskBuilder.name(eventTitle())
            .event(start, start.plusMinutes((random.nextInt(6) + 2) * 15))
            .location(choice(locations))
            .build();
    }

    public static ImmutableTask fullTaggedEvent() {
        LocalDateTime start = randomDate();
        return TaskBuilder.name(eventTitle())
            .event(start, start.plusMinutes((random.nextInt(6) + 2) * 15))
            .location(choice(locations))
            .tagged(randomTags())
            .build();
    }
    
    public static ImmutableTask random() {
        switch (random.nextInt(6)) {
            case 0:
                return task();
            case 1:
                return fullTask();
            case 2:
                return fullTaggedTask();
            case 3:
                return event();
            case 4:
                return fullEvent();
            default:
                return fullTaggedEvent();
        }
    }
    
    public static List<ImmutableTask> list() {
        List<ImmutableTask> tasks = Lists.newArrayList(random());
        
        while (random.nextInt(5) != 0) {
            tasks.add(random());
        }
        
        return tasks;
    }

```
###### \java\seedu\todo\testutil\TimeUtil.java
``` java
public class TimeUtil {
    public static final LocalDateTime now = LocalDateTime.now();
    private static final String FORMAT_FULL_DATE = "d MMMM yyyy, h:mm a";
    
    public static LocalDateTime today() {
        return LocalDateTime.of(LocalDate.now(), LocalTime.of(0, 0));
    }
    
    public static LocalDateTime tomorrow() {
        return LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(0, 0));
    }

```
