# A0135805H
###### \java\seedu\todo\commons\events\ui\CommandInputEnterEvent.java
``` java
/**
 * An event when the user presses "ENTER" on the keyboard in the command input.
 */
public class CommandInputEnterEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\todo\commons\events\ui\ExpandCollapseTaskEvent.java
``` java
/**
 * An event to tell the Ui to collapse or expand a given task in the to-do list.
 */
public class ExpandCollapseTaskEvent extends BaseEvent{

    public final ImmutableTask task;
    
    public Boolean toCollapse; 

    /**
     * Constructs an event that tells the Ui to collapse or expend a given task in the to-do list.
     * @param task a single index of the task that is matching to the Ui (index 1 to num of tasks, inclusive)
     */
    public ExpandCollapseTaskEvent(ImmutableTask task) {
        this(task, null);
    }
    
    public ExpandCollapseTaskEvent(ImmutableTask task, Boolean toCollapse) {
        this.task = task;
        this.toCollapse = toCollapse;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\todo\commons\events\ui\ShowHelpEvent.java
``` java
/**
 * An event requesting to view the help page.
 */
public class ShowHelpEvent extends BaseEvent {
    private List<CommandSummary> commandSummaries;
    
    public ShowHelpEvent(List<CommandSummary> commandSummaries) {
        this.commandSummaries = commandSummaries;
    }

    public List<CommandSummary> getCommandSummaries() {
        return commandSummaries;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\todo\commons\events\ui\ShowTagsEvent.java
``` java
/**
 * An event requesting to view the global tags page.
 */
public class ShowTagsEvent extends BaseEvent {

    private List<Tag> listOfTags;

    public ShowTagsEvent(List<Tag> listOfTags) {
        this.listOfTags = listOfTags;
    }

    /**
     * Retrieves the global list of tags sent by the event bus.
     */
    public List<Tag> getListOfTags() {
        return listOfTags;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\todo\commons\util\StringUtil.java
``` java
    /**
     * Partitions the string into three parts:
     *      string[0 .. position - 1], string[position], string[position + 1 .. length - 1], all index inclusive
     * @param string to be partitioned
     * @param position location where the string should be partitioned
     * @return a String array containing the three elements stated above,
     *         where each element must not be null, but can have empty string.
     */
    public static String[] partitionStringAtPosition(String string, int position) {
        String[] stringArray = new String[3];
        if (string == null || string.isEmpty() || position < 0 || position >= string.length()) {
            stringArray[0] = "";
            stringArray[1] = "";
            stringArray[2] = "";
        } else {
            stringArray[0] = string.substring(0, position);
            stringArray[1] = string.substring(position, position + 1);
            stringArray[2] = string.substring(position + 1, string.length());
        }
        return stringArray;
    }

    /**
     * Splits string at only space and comma.
     * @return Returns a String array with all the split components of the string.
     */
    public static String[] split(String string) {
        if (isEmpty(string)) {
            return new String[0];
        } else {
            return Iterables.toArray(Splitter.on(DELIMITER)
                .trimResults()
                .omitEmptyStrings()
                .split(string), String.class);
        }
    }

    /**
     * Given a string list, gets the text from the list in the following manner:
     *      apple, pear, pineapple
     */
    public static String convertListToString(String[] stringList) {
        if (stringList == null || stringList.length == 0) {
            return "";
        }
        StringJoiner stringJoiner = new StringJoiner(", ");
        for (String string : stringList) {
            stringJoiner.add(string);
        }
        return stringJoiner.toString();
    }

    /**
     * Given an iterable, join them together with comma as shown:
     *      apple, pear, pineapple
     */
    public static String convertIterableToString( Iterable<?> iterable) {
        if (iterable == null) {
            return "";
        }
        return StringUtils.join(iterable, ", ");
    }

```
###### \java\seedu\todo\commons\util\TimeUtil.java
``` java
/**
 * Utility methods that deals with time.
 */
public class TimeUtil {

    
    /* Constants */
    private static final Logger logger = LogsCenter.getLogger(TimeUtil.class);

    private static final String WORD_IN = "in";
    private static final String WORD_BY = "by";
    private static final String WORD_SINCE = "since";
    private static final String WORD_AGO = "ago";
    private static final String WORD_FROM = "from";
    private static final String WORD_TO = "to";
    private static final String WORD_TOMORROW = "tomorrow";
    private static final String WORD_YESTERDAY = "yesterday";
    private static final String WORD_TODAY = "today";
    private static final String WORD_TONIGHT = "tonight";
    private static final String WORD_COMMA = ",";
    private static final String WORD_SPACE = " ";

    private static final String DUE_NOW = "due now";
    private static final String DUE_LESS_THAN_A_MINUTE = "in less than a minute";

    private static final String UNIT_MINUTES = "minutes";
    private static final String VALUE_ONE_MINUTE = "1 minute";

    private static final String FORMAT_DATE_WITH_YEAR = "d MMMM yyyy";
    private static final String FORMAT_DATE_NO_YEAR = "d MMMM";
    private static final String FORMAT_TIME = "h:mm a";
    
    private static final Pattern DATE_REGEX = Pattern.compile("\\b([0123]?\\d)([/-])([01]?\\d)(?=\\2\\d{2,4}|\\s|$)");
    
    /* Variables */
    protected Clock clock = Clock.systemDefaultZone();
    protected LocalDateTime now = LocalDateTime.now(clock);
    
    /*Setters*/
    protected void setClock(Clock clock) {
        this.clock = clock;
        
    }
    
    protected void setNow (LocalDateTime now){
        this.now = now;
    }
    /**
     * Gets the task deadline expression for the UI.
     * @param endTime ending time
     * @return a formatted deadline String
     */
    public String getTaskDeadlineText(LocalDateTime endTime) {
        if (endTime == null) {
            logger.log(Level.WARNING, "endTime in getTaskDeadlineText(...) is missing.");
            return "";
        }

        LocalDateTime currentTime = now;
        if (endTime.isAfter(currentTime)) {
            return getDeadlineNotOverdueText(currentTime, endTime);
        } else {
            return getDeadlineOverdueText(currentTime, endTime);
        }
    }

    /**
     * Helper method of {@link #getTaskDeadlineText(LocalDateTime)} to get deadline text
     * when it is still not overdue (currentTime < endTime).
     * @param currentTime the time now
     * @param endTime the due date and time
     * @return a formatted deadline string
     */
    private String getDeadlineNotOverdueText(LocalDateTime currentTime, LocalDateTime endTime) {
        Duration durationCurrentToEnd = Duration.between(currentTime, endTime);
        long minutesToDeadline = durationCurrentToEnd.toMinutes();
        long secondsToDeadline = durationCurrentToEnd.getSeconds();

        StringJoiner stringJoiner = new StringJoiner(WORD_SPACE);

        if (secondsToDeadline <= 59) {
            return DUE_LESS_THAN_A_MINUTE;
        } else if (minutesToDeadline <= 59) {
            stringJoiner.add(WORD_IN).add(getMinutesText(currentTime, endTime));
        } else {
            stringJoiner.add(WORD_BY).add(getDateText(currentTime, endTime) + WORD_COMMA)
                    .add(getTimeText(endTime));
        }
        return stringJoiner.toString();
    }

    /**
     * Helper method of {@link #getTaskDeadlineText(LocalDateTime)} to get deadline text
     * when it is overdue (currentTime > endTime).
     * @param currentTime the time now
     * @param endTime the due date and time
     * @return a formatted deadline string
     */
    private String getDeadlineOverdueText(LocalDateTime currentTime, LocalDateTime endTime) {
        Duration durationCurrentToEnd = Duration.between(currentTime, endTime);
        long minutesToDeadline = durationCurrentToEnd.toMinutes();
        long secondsToDeadline = durationCurrentToEnd.getSeconds();

        StringJoiner stringJoiner = new StringJoiner(WORD_SPACE);

        if (secondsToDeadline >= -59) {
            return DUE_NOW;
        } else if (minutesToDeadline >= -59) {
            stringJoiner.add(getMinutesText(currentTime, endTime)).add(WORD_AGO);
        } else {
            stringJoiner.add(WORD_SINCE).add(getDateText(currentTime, endTime) + WORD_COMMA)
                    .add(getTimeText(endTime));
        }
        return stringJoiner.toString();
    }

    /**
     * Gets the event date and time text for the UI
     * @param startTime of the event
     * @param endTime of the event
     * @return a formatted event duration string
     */
    public String getEventTimeText(LocalDateTime startTime, LocalDateTime endTime) {
        if (startTime == null || endTime == null) {
            logger.log(Level.WARNING, "Either startTime or endTime is missing in getEventTimeText(...)");
            return "";
        } else if (startTime.isAfter(endTime)) {
            logger.log(Level.WARNING, "Start time is after end time in getEventTimeText(...)");
            return "";
        }

        LocalDateTime currentTime = now;
        StringJoiner joiner = new StringJoiner(WORD_SPACE);
        if (isSameDay(startTime, endTime)) {
            joiner.add(getDateText(currentTime, startTime) + WORD_COMMA)
                    .add(WORD_FROM).add(getTimeText(startTime))
                    .add(WORD_TO).add(getTimeText(endTime));
        } else {
            joiner.add(WORD_FROM).add(getDateText(currentTime, startTime) + WORD_COMMA).add(getTimeText(startTime))
                    .add(WORD_TO).add(getDateText(currentTime, endTime) + WORD_COMMA).add(getTimeText(endTime));
        }
        return joiner.toString();
    }


    /**
     * Gives a formatted text of the dateTime based on the current system time, and then returns one of the following:
     *      "Yesterday", "Today", "Tonight", "Tomorrow",
     *      full date without year if this year,
     *      full date with year if other year.
     *
     * @param dateTime to format the date with
     * @return a formatted date text described above
     */
    private String getDateText(LocalDateTime currentTime, LocalDateTime dateTime) {
        if (isYesterday(currentTime, dateTime)) {
            return WORD_YESTERDAY;
        } else if (isTonight(currentTime, dateTime)) {
            return WORD_TONIGHT;
        } else if (isToday(currentTime, dateTime)) {
            return WORD_TODAY;
        } else if (isTomorrow(currentTime, dateTime)) {
            return WORD_TOMORROW;
        } else if (isSameYear(currentTime, dateTime)) {
            return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_DATE_NO_YEAR));
        } else {
            return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_DATE_WITH_YEAR));
        }
    }

    /**
     * Returns a formatted string of the time component of dateTime
     * @param dateTime to format the time with
     * @return a formatted time text (HH:MM A/PM)
     */
    private String getTimeText(LocalDateTime dateTime) {
        return dateTime.format(DateTimeFormatter.ofPattern(FORMAT_TIME));
    }

    /**
     * Counts the number of minutes between the two dateTimes and prints out either:
     *      "1 minute" or "X minutes", for X != 1, X >= 0.
     * @param dateTime1 the first time instance
     * @param dateTime2 the other time instance
     * @return a formatted string to tell number of minutes left (as above)
     */
    private String getMinutesText(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        Duration duration = Duration.between(dateTime1, dateTime2);
        long minutesToDeadline = Math.abs(duration.toMinutes());

        if (minutesToDeadline == 1){
            return VALUE_ONE_MINUTE;
        } else {
            return minutesToDeadline + WORD_SPACE + UNIT_MINUTES;
        }
    }

    public boolean isTomorrow(LocalDateTime dateTimeToday, LocalDateTime dateTimeTomorrow) {
        LocalDate dayBefore = dateTimeToday.toLocalDate();
        LocalDate dayAfter = dateTimeTomorrow.toLocalDate();
        return dayBefore.plusDays(1).equals(dayAfter);
    }
    
    public boolean isToday(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        LocalDate date1 = dateTime1.toLocalDate();
        LocalDate date2 = dateTime2.toLocalDate();
        return date1.equals(date2);
    }

    private boolean isTonight(LocalDateTime dateTimeToday, LocalDateTime dateTimeTonight) {
        return isToday(dateTimeToday, dateTimeTonight)
                && dateTimeTonight.toLocalTime().isAfter(LocalTime.of(17, 59, 59));
    }
    
    private boolean isYesterday(LocalDateTime dateTimeToday, LocalDateTime dateTimeYesterday) {
        return isTomorrow(dateTimeYesterday, dateTimeToday);
    }

    private boolean isSameDay(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        return dateTime1.toLocalDate().equals(dateTime2.toLocalDate());
    }
    
    private boolean isSameYear(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        return dateTime1.getYear() == dateTime2.getYear();
    }
    
    public boolean isOverdue(LocalDateTime endTime) {
        if (endTime == null) {
            logger.log(Level.WARNING, "endTime in isOverdue(...) is null.");
            return false;
        }
        return endTime.isBefore(now);
    }
    
```
###### \java\seedu\todo\logic\commands\AddCommand.java
``` java
    @Override
    protected void validateArguments() {
        validateTagArguments();
    }

    /**
     * Helper method to validate tag arguments.
     */
    private void validateTagArguments() {
        if (tags.hasBoundValue()) {
            String[] tagNames = StringUtil.split(tags.getValue());
            UniqueTagCollectionValidator validator = new UniqueTagCollectionValidator(tags.getName(), errors);
            validator.validateAddTags(tagNames);
        }
    }
}
```
###### \java\seedu\todo\logic\commands\CommandSummary.java
``` java
    /**
     * Re-represents this {@link CommandSummary} as an array of strings in the following format:
     *      [Scenario, Command, Arguments]
     */
    public String[] toArray() {
        return new String[] {scenario, command, arguments};
    }
}
```
###### \java\seedu\todo\logic\commands\TagCommand.java
``` java
/**
 * This class handles all tagging command
 */
public class TagCommand extends BaseCommand {

    /* Constants */
    private static final String ERROR_INCOMPLETE_PARAMETERS
            = "The tag command is unable to recognise your commands.";
    private static final String ERROR_TOO_MANY_PARAMETERS
            = "You have supplied too many parameters.";
    private static final String ERROR_INPUT_INDEX_REQUIRED
            = "A task index is required.";
    private static final String ERROR_INPUT_ADD_TAGS_REQUIRED
            = "A list of tags \"tag1, tag2, ...\" to add is required.";
    private static final String ERROR_INPUT_DELETE_TAGS_REQUIRED
            = "A list of tags \"tag1, tag2, ...\" to delete is required.";
    private static final String ERROR_INPUT_RENAME_TAGS_REQUIRED
            = "Please provide an existing tag name and a new tag name.";
    private static final String ERROR_TWO_PARAMS
            = "You may only provide an existing tag name, and a new tag name for renaming.";

    private static final String SUCCESS_ADD_TAGS = " - tagged successfully";
    private static final String SUCCESS_DELETE_TAGS = " - removed successfully";
    private static final String SUCCESS_RENAME_TAGS = " renamed to ";

    private static final String MESSAGE_ENTER_TO_DISMISS = "Press [Enter] to dismiss.";
    private static final String MESSAGE_NO_TAGS
            = "You have no tags currently. Use the tag command to tag a task.";

    private static final String DESCRIPTION_SHOW_TAGS = "Shows all tags";
    private static final String DESCRIPTION_ADD_TAGS = "Add tags to a task";
    private static final String DESCRIPTION_DELETE_TAGS = "Remove tags";
    private static final String DESCRIPTION_RENAME_TAGS = "Rename a tag";

    private static final String ARGUMENTS_SHOW_TAGS = "";
    private static final String ARGUMENTS_ADD_TAGS = "index tag1 [, tag2, ...]";
    private static final String ARGUMENTS_DELETE_TAGS = "[index] /d tag1 [, tag2, ...]";
    private static final String ARGUMENTS_RENAME_TAGS = "[index] /r old_tag_name new_tag_name";

    private static final int INDEX_OFFSET = 1;
    private static final int INDEX_RENAME_OLD_NAME = 0;
    private static final int INDEX_RENAME_NEW_NAME = 1;

    /* Variables */
    private Argument<Integer> index = new IntArgument("index");

    private Argument<String> addTags = new StringArgument("add");

    private Argument<String> deleteTags = new StringArgument("delete")
            .flag("d");

    private Argument<String> renameTag = new StringArgument("rename")
            .flag("r");

    @Override
    public Parameter[] getArguments() {
        return new Parameter[] {
            index, deleteTags, addTags, renameTag
        };
    }

    /* Methods to get command argument for add tags */
    /**
     * Partitions two flag-less parameters index and list of tags by overriding this method.
     */
    @Override
    protected void setPositionalArgument(String argument) {
        String[] tokens = argument.trim().split(" ", 2);
        getPossibleIndexForAddCommand(tokens[0]);
        if (tokens.length == 2) {
            getPossibleTagsForAddCommand(tokens[1]);
        }
    }

    /**
     * If the input parameter resembles the add command with an index, extracts the index of the add command
     * input.
     */
    private void getPossibleIndexForAddCommand(String argument) {
        boolean isFirstArgNumber = StringUtil.isUnsignedInteger(argument);
        if (isFirstArgNumber) {
            try {
                index.setValue(argument);
            } catch (IllegalValueException e) {
                errors.put(index.getName(), e.getMessage());
            }
        }
    }

    /**
     * If the input parameter resembles the add command with tag names, extracts the tag names of the add
     * command input.
     */
    private void getPossibleTagsForAddCommand(String argument) {
        try {
            addTags.setValue(argument);
        } catch (IllegalValueException e) {
            errors.put(addTags.getName(), e.getMessage());
        }
    }

    /* Remaining Override Methods */
    @Override
    public String getCommandName() {
        return "tag";
    }

    @Override
    public List<CommandSummary> getCommandSummary() {
        return ImmutableList.of(
            new CommandSummary(DESCRIPTION_SHOW_TAGS, getCommandName(), ARGUMENTS_SHOW_TAGS),
            new CommandSummary(DESCRIPTION_ADD_TAGS, getCommandName(), ARGUMENTS_ADD_TAGS),
            new CommandSummary(DESCRIPTION_DELETE_TAGS, getCommandName(), ARGUMENTS_DELETE_TAGS),
            new CommandSummary(DESCRIPTION_RENAME_TAGS, getCommandName(), ARGUMENTS_RENAME_TAGS)
        );
    }

    @Override
    protected void validateArguments() {
        if (!isInputParameterSufficient()) {
            handleUnavailableInputParameters();
        }
        validateRenameParams();
        validateRenameAllParams();
        super.validateArguments();
    }

    @Override
    public CommandResult execute() throws ValidationException {
        //Performs the actual execution with the data. Guarantees that only one action gets to run.
        guaranteeOneActionExecutes();

        CommandResult result = chooseFirstAvailable(
                performShowTagsWhenApplicable(),
                performAddTagToTaskWhenApplicable(),
                performDeleteTagsFromTaskWhenApplicable(),
                performDeleteTagsGloballyWhenApplicable(),
                performRenameTagFromTaskWhenApplicable(),
                performRenameTagWhenApplicable());

        guaranteeCommandResultExists(result); //Just a sanity check.

        highlightTaskWhenComplete();
        return result;
    }

    /* User Interface Helper Methods */
    /**
     * Highlights the task when a task index is available.
     * @throws ValidationException when the index is invalid.
     */
    private void highlightTaskWhenComplete() throws ValidationException {
        if (index.hasBoundValue()) {
            int displayedIndex = index.getValue();
            eventBus.post(new HighlightTaskEvent(model.getTask(displayedIndex)));
            eventBus.post(new ExpandCollapseTaskEvent(model.getTask(displayedIndex)));
        } else {
            //clear all current selections
            eventBus.post(new HighlightTaskEvent(null));
        }
    }

    /* Show Tags Methods */
    /**
     * Returns true if the command parameters matches the action of show global tags
     */
    private boolean isShowTags() {
        return !index.hasBoundValue() && !addTags.hasBoundValue() && !deleteTags.hasBoundValue()
                && !renameTag.hasBoundValue();
    }

    /**
     * Performs the following execution if the command indicates so:
     *      Show a global list of tags
     */
    private CommandResult performShowTagsWhenApplicable() {
        if (isShowTags() && model.getGlobalTagsList().isEmpty()) {
            return new CommandResult(MESSAGE_NO_TAGS);

        } else if (isShowTags()) {
            ShowTagsEvent tagsEvent = new ShowTagsEvent(model.getGlobalTagsList());
            EventsCenter.getInstance().post(tagsEvent);
            return new CommandResult(MESSAGE_ENTER_TO_DISMISS);
        }
        return null;
    }

    /* Add Tags to Task Method */
    /**
     * Returns true if the command parameters matches the action of adding tag(s) to a task.
     */
    private boolean isAddTagsToTask() {
        return index.hasBoundValue() && addTags.hasBoundValue() && !deleteTags.hasBoundValue()
                && !renameTag.hasBoundValue();
    }

    /**
     * Performs the following execution if the command indicates so:
     *      Adds Tags to a particular Task
     */
    private CommandResult performAddTagToTaskWhenApplicable() throws ValidationException {
        Integer displayedIndex = index.getValue();
        String[] tagsToAdd = StringUtil.split(addTags.getValue());

        if (isAddTagsToTask()) {
            model.addTagsToTask(displayedIndex, tagsToAdd);
            ImmutableTask task = model.getObservableList().get(displayedIndex - INDEX_OFFSET);
            eventBus.post(new HighlightTaskEvent(task));
            return new CommandResult(StringUtil.convertListToString(tagsToAdd) + SUCCESS_ADD_TAGS);
        }
        return null;
    }

    /* Delete Tags from Task */
    /**
     * Returns true if the command parameters matches the action of deleting tag(s) from a task.
     */
    private boolean isDeleteTagsFromTask() {
        return index.hasBoundValue() && !addTags.hasBoundValue() && deleteTags.hasBoundValue()
                && !renameTag.hasBoundValue();
    }

    /**
     * Performs the following execution if the command indicates so:
     *      Deletes tags from a task.
     */
    private CommandResult performDeleteTagsFromTaskWhenApplicable() throws ValidationException {
        Integer displayedIndex = index.getValue();
        String[] tagsToDelete = StringUtil.split(deleteTags.getValue());

        if (isDeleteTagsFromTask()) {
            model.deleteTagsFromTask(displayedIndex, tagsToDelete);
            return new CommandResult(StringUtil.convertListToString(tagsToDelete) + SUCCESS_DELETE_TAGS);
        }
        return null;
    }

    /* Delete Tags from All Tasks */
    /**
     * Returns true if the command parameters matches the action of deleting tag(s) from all tasks.
     */
    private boolean isDeleteTagsFromAllTasks() {
        return !index.hasBoundValue() && !addTags.hasBoundValue() && deleteTags.hasBoundValue()
                && !renameTag.hasBoundValue();
    }

    /**
     * Performs the following execution if the command indicates so:
     *      Deletes tags from all tasks.
     */
    private CommandResult performDeleteTagsGloballyWhenApplicable() throws ValidationException {
        String[] tagsToDelete = StringUtil.split(deleteTags.getValue());

        if (isDeleteTagsFromAllTasks()) {
            model.deleteTags(tagsToDelete);
            return new CommandResult(StringUtil.convertListToString(tagsToDelete) + SUCCESS_DELETE_TAGS);
        }
        return null;
    }

    /* Rename Tag from a task */
    /**
     * Returns true if the command parameter matches the action of renaming a tag from a task.
     */
    private boolean isRenameTagFromTask() {
        return index.hasBoundValue() && !addTags.hasBoundValue() && !deleteTags.hasBoundValue()
                && renameTag.hasBoundValue();
    }

    /**
     * Performs the following execution if the command indicates so:
     *      Rename a specific tag from a task.
     */
    private CommandResult performRenameTagFromTaskWhenApplicable() throws ValidationException {
        if (isRenameTagFromTask()) {
            String[] renameTagsParam = StringUtil.split(renameTag.getValue());
            String oldName = renameTagsParam[INDEX_RENAME_OLD_NAME];
            String newName = renameTagsParam[INDEX_RENAME_NEW_NAME];
            model.renameTag(index.getValue(), oldName, newName);
            return new CommandResult(oldName + SUCCESS_RENAME_TAGS + newName);
        }
        return null;
    }

    /**
     * Performs validation to rename params (check for sufficient parameters to rename).
     */
    private void validateRenameParams() {
        if (isRenameTagFromTask()) {
            validateParameterForTwoItems(renameTag.getName(), renameTag.getValue());
        }
    }

    /* Renaming Tags From All Tasks*/
    /**
     * Returns true if the command parameters matches the action of renaming tags.
     */
    private boolean isRenameTagOfAllTasks() {
        return !index.hasBoundValue() && !addTags.hasBoundValue() && !deleteTags.hasBoundValue()
                && renameTag.hasBoundValue();
    }

    /**
     * Performs validation to rename params (check for sufficient parameters to rename).
     */
    private void validateRenameAllParams() {
        if (isRenameTagOfAllTasks()) {
            validateParameterForTwoItems(renameTag.getName(), renameTag.getValue());
        }
    }

    /**
     * Performs the following execution if the command indicates so:
     *      Rename a specific tag globally.
     */
    private CommandResult performRenameTagWhenApplicable() throws ValidationException {
        if (isRenameTagOfAllTasks()) {
            String[] renameTagsParam = StringUtil.split(renameTag.getValue());
            String oldName = renameTagsParam[INDEX_RENAME_OLD_NAME];
            String newName = renameTagsParam[INDEX_RENAME_NEW_NAME];
            model.renameTag(oldName, newName);
            return new CommandResult(oldName + SUCCESS_RENAME_TAGS + newName);
        }
        return null;
    }

    /* Command Validation Methods */
    /**
     * Guarantees that only one action gets to run, otherwise throws {@link ValidationException}.
     */
    private void guaranteeOneActionExecutes() throws ValidationException {
        if (!isInputParameterSufficient()) {
            throw new ValidationException(ERROR_INCOMPLETE_PARAMETERS);
        }
    }

    /**
     * Guarantees that result is not null. Otherwise, throw an error {@link ValidationException}.
     */
    private void guaranteeCommandResultExists(CommandResult result) throws ValidationException {
        if (result == null) {
            throw new ValidationException(ERROR_INCOMPLETE_PARAMETERS);
        }
    }

    /**
     * Checks if the input parameters are sufficient, by checking if it matches any of the input case.
     */
    private boolean isInputParameterSufficient() {
        return getNumberOfTruth(isShowTags(), isAddTagsToTask(), isDeleteTagsFromTask(),
                isDeleteTagsFromAllTasks(), isRenameTagOfAllTasks(), isRenameTagFromTask()) == 1;
    }

    /**
     * Validates the given {@code param} if there is exactly 2 items.
     */
    private void validateParameterForTwoItems(String fieldName, String param) {
        String[] params = StringUtil.split(param);
        if (params == null || params.length != 2) {
            errors.put(fieldName, ERROR_TWO_PARAMS);
        }
    }

    /**
     * Sets error messages for insufficient input parameters, dependent on input parameters supplied.
     */
    private void handleUnavailableInputParameters() {
        boolean hasIndex = index.hasBoundValue();
        boolean hasAdd = addTags.hasBoundValue();
        boolean hasDelete = deleteTags.hasBoundValue();
        boolean hasRename = renameTag.hasBoundValue();

        Boolean errorPlaced = chooseFirstTrue(
                handleTooManyParameters(hasAdd, hasDelete, hasRename),
                handleMissingIndex(hasIndex, hasAdd, hasRename),
                handleMissingTagParams(hasIndex, hasAdd, hasDelete, hasRename));

        handleGenericIncompleteParams(errorPlaced);
    }

    /**
     * Sets a generic error for the error bag for {@link #handleUnavailableInputParameters()} if specific
     * error checks did not spot any param errors.
     * @param errorPlaced a boolean value indicated whether an error has been placed already.
     */
    private void handleGenericIncompleteParams(Boolean errorPlaced) {
        if (errorPlaced != null && !errorPlaced) {
            errors.put(ERROR_INCOMPLETE_PARAMETERS);
        }
    }

    /**
     * Sets the error bag {@link #errors} if the parameters expects tags names as parameters but is missing.
     * @return True when error is set.
     */
    private boolean handleMissingTagParams(boolean hasIndex, boolean hasAdd, boolean hasDelete, boolean hasRename) {
        if (hasIndex && !hasAdd && !hasDelete && !hasRename) {
            errors.put(addTags.getName(), ERROR_INPUT_ADD_TAGS_REQUIRED);
            errors.put(deleteTags.getName(), ERROR_INPUT_DELETE_TAGS_REQUIRED);
            errors.put(renameTag.getName(), ERROR_INPUT_RENAME_TAGS_REQUIRED);
            return true;
        }
        return false;
    }

    /**
     * Sets the error bag {@link #errors} if the parameters expects an index but is missing.
     * @return True when error is set.
     */
    private boolean handleMissingIndex(boolean hasIndex, boolean hasAdd, boolean hasRename) {
        if ((hasAdd && !hasIndex) || (hasRename && !hasIndex)) {
            errors.put(index.getName(), ERROR_INPUT_INDEX_REQUIRED);
            return true;
        }
        return false;
    }

    /**
     * Sets the error bag {@link #errors} if the parameters have too many errors.
     * @return True when error is set.
     */
    private boolean handleTooManyParameters(boolean hasAdd, boolean hasDelete, boolean hasRename) {
        if (getNumberOfTruth(hasAdd, hasDelete, hasRename) > 1) {
            errors.put(ERROR_TOO_MANY_PARAMETERS);
            return true;
        }
        return false;
    }

    /* Helper Methods */
    /**
     * Returns number of true booleans.
     */
    private static int getNumberOfTruth(boolean... booleans) {
        int count = 0;
        for (boolean bool : booleans) {
            if (bool) {
                count += 1;
            }
        }
        return count;
    }

    /**
     * Returns the first object that cause the {@code predicate} to be true. Otherwise, return null.
     */
    @SuppressWarnings("unchecked")
    private static <T> T chooseFirst(Predicate<T> predicate, T... objects) {
        Optional<T> optionalObject = Arrays.stream(objects).filter(predicate).findFirst();
        return optionalObject.isPresent() ? optionalObject.get() : null;
    }

    /**
     * Returns the first object that is available. Otherwise, return null.
     */
    @SuppressWarnings("unchecked")
    private static <T> T chooseFirstAvailable(T... objects) {
        return chooseFirst(t -> t != null, objects);
    }

    /**
     * Returns the first object that is true. Otherwise, return null.
     */
    private static Boolean chooseFirstTrue(Boolean ... objects) {
        return chooseFirst(aBoolean -> aBoolean != null && aBoolean, objects);
    }
}
```
###### \java\seedu\todo\model\ErrorBag.java
``` java
    /**
     * Merge the given error bag in {@code errorBag} to this instance of {@link ErrorBag}.
     */
    public void merge(ErrorBag errorBag) {
        this.nonFieldErrors.addAll(errorBag.getNonFieldErrors());
        this.fieldErrors.putAll(errorBag.getFieldErrors());
    }
}
```
###### \java\seedu\todo\model\Model.java
``` java
    /**
     * Gets an immutable copy of the task
     */
    ImmutableTask getTask(int displayedIndex) throws ValidationException;

    /**
     * Gets a copy of the list of tags
     */
    List<Tag> getGlobalTagsList();

    /**
     * Adds the supplied list of tags (using tag names) to the specified task.
     * Will do validation to the tags and throws error at the class using this method.
     *
     * @param index The task displayed index.
     * @param tagNames The list of tag names to be added.
     * @throws ValidationException when the given index is invalid, or the given {@code tagNames} contain
     *                             illegal characters.
     */
    void addTagsToTask(int index, String... tagNames) throws ValidationException;

    /**
     * Adds the supplied list of tags (using tag names) to the specified task.
     * Does not throw any validation error. Assumes that validation has been done at the command level.
     * @param task The mutable task.
     * @param tagNames The list of tag names to be added.
     */
    void addTagsToTask(MutableTask task, String... tagNames);

    /**
     * Deletes a list of tags (using tag names) from the specified task.
     *
     * @param index The task displayed index.
     * @param tagNames The list of tag names to be deleted.
     * @throws ValidationException when the given index is invalid, or when the tag is not found (no-op).
     */
    void deleteTagsFromTask(int index, String... tagNames) throws ValidationException;

    /**
     * Deletes the list of tags globally.
     *
     * @param tagNames The list of tag names to be deleted.
     * @throws ValidationException when the tag is not found (no-op).
     */
    void deleteTags(String... tagNames) throws ValidationException;

    /**
     * Renames a tag across all tasks.
     * @param oldName Name of the tag to be renamed.
     * @param newName New name that the tag will assume.
     * @throws ValidationException when the tag is not found, or the new name clashes with existing names.
     */
    void renameTag(String oldName, String newName) throws ValidationException;

    /**
     * Renames a tag for a particular task.
     * @param index The task displayed index to be renamed.
     * @param oldName Name of the tag to be renamed.
     * @param newName New name that the tag will assume.
     * @throws ValidationException when the tag is not found, or the new name clashes with existing names.
     */
    void renameTag(int index, String oldName, String newName) throws ValidationException;
}
```
###### \java\seedu\todo\model\tag\Tag.java
``` java
/**
 * Represents a Tag in a task.
 *
 * Guarantees: immutable. To rename, a new Tag object must be created. (Renaming method is unsupported)
 *
 * However, since alphanumeric name is not critical to {@link Tag},
 * the validation is done at {@link seedu.todo.model.TodoModel}
 */
public class Tag {
    /* Variables */
    //Stores a unique tag name, that is alphanumeric, and contains dashes and underscores.
    private String tagName;

    /**
     * Constructs a new tag with the given tag name.
     *
     * This class is intentional to be package private, so only {@link UniqueTagCollection}
     * can construct new tags.
     */
    public Tag(String name) {
        this.tagName = name;
    }

```
###### \java\seedu\todo\model\tag\UniqueTagCollection.java
``` java
/**
 * A list of tags that enforces no nulls and uniqueness between its elements.
 * Also supports minimal set of list operations for the app's features.
 *
 * Note: This class will disallow external access to {@link #uniqueTagsToTasksMap} so to
 * maintain uniqueness of the tag names.
 */
public class UniqueTagCollection implements Iterable<Tag>, UniqueTagCollectionModel {

    //Stores a list of tags with unique tag names.
    private final Map<Tag, Set<ImmutableTask>> uniqueTagsToTasksMap = new HashMap<>();

    /* Constructor */
    /**
     * Constructs this tag collection
     */
    public UniqueTagCollection(List<ImmutableTask> globalTaskList) {
        update(globalTaskList);
    }

    /* Interfacing Methods */
    @Override
    public void update(List<ImmutableTask> globalTaskList) {
        uniqueTagsToTasksMap.clear();
        globalTaskList.forEach(task -> task.getTags().forEach(tag -> associateTaskToTag(task, tag)));
    }

    @Override
    public void notifyTaskDeleted(ImmutableTask task) {
        task.getTags().forEach(tag -> dissociateTaskFromTag(task, tag));
    }

    @Override
    public Collection<Tag> associateTaskToTags(ImmutableTask task, String[] tagNames) {
        return Arrays.stream(tagNames)
                .map(name -> associateTaskToTag(task, getTagWithName(name)))
                .collect(Collectors.toSet());
    }

    @Override
    public Collection<Tag> dissociateTaskFromTags(ImmutableTask task, String[] tagNames) {
        //Data validation at TodoModel should have checked if this is available.
        //Even if it is not, getTagWithName(...) will recreate the tag which gets deleted again, safe op.

        return Arrays.stream(tagNames)
                .map(name -> dissociateTaskFromTag(task, getTagWithName(name)))
                .collect(Collectors.toSet());
    }

    @Override
    public Collection<Tag> deleteTags(String[] tagNames) {
        //Data validation at TodoModel should have checked if this is available.
        //Even if it is not, getTagWithName(...) will recreate the tag which gets deleted again, safe op.

        return Arrays.stream(tagNames)
                .map(name -> {
                    Tag tag = getTagWithName(name);
                    uniqueTagsToTasksMap.remove(tag);
                    return tag;
                }).collect(Collectors.toSet());
    }

    /* Helper Methods */
    /**
     * Links a {@code task} to the {@code tag} in the {@link #uniqueTagsToTasksMap}.
     * @return an instance of the {@code tag}
     */
    private Tag associateTaskToTag(ImmutableTask task, Tag tag) {
        Set<ImmutableTask> setOfTasks = uniqueTagsToTasksMap.get(tag);
        if (setOfTasks == null) {
            setOfTasks = new HashSet<>();
            uniqueTagsToTasksMap.put(tag, setOfTasks);
        }
        setOfTasks.add(task);
        return tag;
    }

    /**
     * Removes the association between the {@code task} from the {@code tag} in {@link #uniqueTagsToTasksMap}.
     * If the tag do not have any associated task, the tag will be removed from the map.
     * @return an instance of the {@code tag}
     */
    private Tag dissociateTaskFromTag(ImmutableTask task, Tag tag) {
        Set<ImmutableTask> setOfTasks = uniqueTagsToTasksMap.get(tag);
        if (setOfTasks != null) {
            setOfTasks.remove(task);

            if (setOfTasks.isEmpty()) {
                uniqueTagsToTasksMap.remove(tag);
            }
        }
        return tag;
    }

    /**
     * Obtains an instance of {@link Tag} with the supplied {@code tagName} from the
     * {@link #uniqueTagsToTasksMap}.
     *
     * Note: If such an instance is not found, a new {@link Tag} instance will be added to the
     *       {@link #uniqueTagsToTasksMap}.
     *
     * @param tagName The name of the {@link Tag}.
     * @return A {@link Tag} object that has the name {@code tagName}.
     */
    private Tag getTagWithName(String tagName) {
        Optional<Tag> possibleTag = uniqueTagsToTasksMap.keySet().stream()
                .filter(tag -> tag.getTagName().equals(tagName))
                .findAny();

        Tag targetTag;
        if (possibleTag.isPresent()) {
            targetTag = possibleTag.get();
        } else {
            targetTag = new Tag(tagName);
            uniqueTagsToTasksMap.put(targetTag, new HashSet<>());
        }
        return targetTag;
    }

    /**
     * Simply finds a tag with the {@code tagName}.
     */
    private Optional<Tag> findTagWithName(String tagName) {
        return uniqueTagsToTasksMap.keySet().stream()
                .filter(tag -> tag.getTagName().equals(tagName))
                .findAny();
    }

    /* Interfacing Getters */
    @Override
    public List<Tag> getUniqueTagList() {
        return new ArrayList<>(uniqueTagsToTasksMap.keySet());
    }

    @Override
    public Set<ImmutableTask> getTasksLinkedToTag(String tagName) {
        Optional<Tag> possibleTag = findTagWithName(tagName);
        if (possibleTag.isPresent()) {
            //We are getting a copy of the set of tasks.
            Set<ImmutableTask> tasks = uniqueTagsToTasksMap.get(possibleTag.get());
            return new HashSet<>(tasks);
        } else {
            return new HashSet<>();
        }
    }

```
###### \java\seedu\todo\model\tag\UniqueTagCollectionModel.java
``` java
/**
 * An interface that spells out the available methods for maintaining a unique tag list.
 */
public interface UniqueTagCollectionModel {

    /* Model Interfacing Methods*/
    /**
     * Update the {@link UniqueTagCollectionModel} with the main to-do list {@code globalTaskList}
     * stored in {@link seedu.todo.model.TodoModel}, for a new set of {@link Tag}
     *
     * @param globalTaskList To extract the unique list of {@link Tag}s from.
     */
    void update(List<ImmutableTask> globalTaskList);

    /**
     * Notifies the {@link UniqueTagCollectionModel} that the given {@code task} is deleted,
     * so that the {@link UniqueTagCollectionModel} can update the relations accordingly.
     */
    void notifyTaskDeleted(ImmutableTask task);


    /* Tag Command Interfacing Methods */
    /**
     * Registers the given {@code task}s to a {@link Tag} in the {@link UniqueTagCollectionModel}.
     * However, this method will not save the tags to the {@code task} since it is immutable.
     * Note: that data validation is done at the {@link seedu.todo.model.Model} side.
     *
     * @param task The immutable task to be attached under the {@link Tag}.
     * @param tagNames The list of tag names.
     * @return Returns the corresponding collections of {@link Tag}s object with {@code tagName}
     *         so this tag can be added to the {@code task}.\
     */
    Collection<Tag> associateTaskToTags(ImmutableTask task, String[] tagNames);


    /* Old Tag Command Interfacing Methods */
    /**
     * Unregisters the given {@code task} from the {@link Tag}s in the {@link UniqueTagCollectionModel}.
     * This method will not remove the tags to the task since it is immutable.
     * Also, data validation should be done at the {@link seedu.todo.model.Model} side.
     *
     * @param task The task to be detached from the {@link Tag}.
     * @param tagNames The names of the {@link Tag} to be deleted.
     * @return Returns the corresponding {@link Tag} object with {@code tagName}
     *         so this tag can be removed from the {@code task}.
     */
    Collection<Tag> dissociateTaskFromTags(ImmutableTask task, String[] tagNames);

    /**
     * Deletes the list of tags with {@code tagNames} from the data structure.
     * @return a collection of deleted tags.
     */
    Collection<Tag> deleteTags(String[] tagNames);

    /**
     * Gets a copy of the list of tags.
     */
    List<Tag> getUniqueTagList();

    /**
     * Gets a copy of list of task associated with the {@link Tag} with the name {@code tagName}
     */
    Set<ImmutableTask> getTasksLinkedToTag(String tagName);
}
```
###### \java\seedu\todo\model\tag\UniqueTagCollectionValidator.java
``` java
/**
 * Handles the data validation for {@link UniqueTagCollection} in both
 * {@link seedu.todo.logic.commands.AddCommand} and {@link seedu.todo.logic.commands.TagCommand}
 */
public class UniqueTagCollectionValidator {

    /* Constants */
    private static final int MAX_ALLOWED_TAGS = 5;

    private static final String YOU_SUPPLIED = " They are: ";

    private static final String ERROR_MAX_TAGS_ALLOWED = "You have added too many tags. " +
            "Each task may have up to " + MAX_ALLOWED_TAGS + " tags.";
    private static final String ERROR_TAGS_ILLEGAL_CHAR
            = "Tags may only include alphanumeric characters, including dashes and underscores.";
    private static final String ERROR_TAGS_TOO_LONG
            = "Tags may only be at most 20 characters long.";
    private static final String ERROR_TAGS_DUPLICATED
            = "You might have keyed in duplicated tag names.";
    private static final String ERROR_TAGS_DO_NOT_EXIST
            = "The tag names you have entered do not exist.";
    private static final String ERROR_TAGS_EXIST
            = "The tag names you have entered are already in the task.";
    private static final String ERROR_TAGS_EMPTY
            = "You need to supply tag names.";

    private static final Pattern TAG_VALIDATION_REGEX = Pattern.compile("^[\\w\\d_-]+$");

    /* Variables */
    private String parameterName;
    private ErrorBag errorBag;

    /* Constructor */
    /**
     * Constructs a validator with the name of the parameter {@code parameterName} and a reference to
     * {@link ErrorBag}
     */
    public UniqueTagCollectionValidator(String parameterName, ErrorBag errorBag) {
        this.parameterName = parameterName;
        this.errorBag = errorBag;
    }

    /**
     * Constructs a validator with the name of the parameter but without an external error bag.
     */
    public UniqueTagCollectionValidator(String parameterName) {
        this(parameterName, new ErrorBag());
    }

    /* Public Methods */
    /**
     * Throws an exception if there is something in the error bag.
     */
    public void throwsExceptionIfNeeded() throws ValidationException {
        //Message not required.
        errorBag.validate("");
    }

    /**
     * Validates the add tags command for {@link seedu.todo.logic.commands.AddCommand}.
     */
    public void validateAddTags(String[] tagNames) {
        validateAddTags(null, tagNames);
    }

    /**
     * Validates the add command.
     */
    public void validateAddTags(ImmutableTask task, String[] tagNames) {
        validateIllegalNameChar(tagNames);
        validateNameCharLimit(tagNames);
        validateDuplicatedNameTag(tagNames);
        validateNumberOfTags(task, tagNames);
        validateTagNameMissing(tagNames);
        validateTagNamesDoNotExist(task, tagNames);
    }

    /**
     * Validates the delete tag from task command.
     */
    public void validateDeleteTags(ImmutableTask task, String[] tagNames) {
        validateTagNamesExist(task, tagNames);
        validateTagNameMissing(tagNames);
    }

    /**
     * Validates the delete tag globally command.
     */
    public void validateDeleteTags(UniqueTagCollectionModel tagCollection, String[] tagNames) {
        validateTagNamesExist(tagCollection.getUniqueTagList(), tagNames);
        validateTagNameMissing(tagNames);
    }

    /**
     * Validates the rename tag from task command.
     */
    public void validateRenameCommand(ImmutableTask task, String oldName, String newName) {
        validateTagNamesExist(task.getTags(), oldName);
        validateTagNamesDoNotExist(task.getTags(), newName);
        validateIllegalNameChar(newName);
        validateNameCharLimit(newName);
        validateTagNameMissing(oldName, newName);
    }

    /**
     * Validates the global rename command.
     */
    public void validateGlobalRenameCommand(UniqueTagCollectionModel tagCollection, String oldName, String newName) {
        validateTagNamesExist(tagCollection.getUniqueTagList(), oldName);
        validateTagNamesDoNotExist(tagCollection.getUniqueTagList(), newName);
        validateIllegalNameChar(newName);
        validateNameCharLimit(newName);
        validateTagNameMissing(oldName, newName);
    }

    /* Parameter Validation Helper */
    /**
     * Checks if the total number of tags after adding is within {@link #MAX_ALLOWED_TAGS}.
     */
    private void validateNumberOfTags(ImmutableTask task, String[] tagNames) {
        Set<String> tags = new HashSet<>(toLowerCaseList(tagNames));
        if (task != null) {
            tags.addAll(Tag.getLowerCaseNames(task.getTags()));
        }
        
        if (tags.size() > MAX_ALLOWED_TAGS) {
            errorBag.put(parameterName, ERROR_MAX_TAGS_ALLOWED);
        }
    }

    /**
     * Checks to ensure that given tag names are alphanumeric, which also can contain dashes and underscores.
     */
    private void validateIllegalNameChar(String... tagNames) {
        List<String> possibleViolations = Arrays.stream(tagNames).filter(tagName -> !isValidTagName(tagName))
                .collect(Collectors.toList());

        if (!possibleViolations.isEmpty()) {
            errorBag.put(parameterName, ERROR_TAGS_ILLEGAL_CHAR + YOU_SUPPLIED
                    + StringUtil.convertIterableToString(possibleViolations));
        }
    }

    /**
     * Checks to ensure that the provided character limit is within 20 characters.
     */
    private void validateNameCharLimit(String... tagNames) {
        List<String> possibleViolations = Arrays.stream(tagNames).filter(tagName -> tagName.length() > 20)
                .collect(Collectors.toList());

        if (!possibleViolations.isEmpty()) {
            errorBag.put(parameterName, ERROR_TAGS_TOO_LONG + YOU_SUPPLIED
                    + StringUtil.convertIterableToString(possibleViolations));
        }
    }

    /**
     * Checks to ensure that given tag names have no duplicated entries.
     */
    private void validateDuplicatedNameTag(String... tagNames) {
        if (!CollectionUtil.elementsAreUnique(toLowerCaseList(tagNames))) {
            errorBag.put(parameterName, ERROR_TAGS_DUPLICATED);
        }
    }

    /**
     * Checks to ensure that tag names exist in the {@code tagPool}.
     */
    private void validateTagNamesExist(Collection<Tag> tagPool, String... tagNames) {
        List<String> missingTags = toLowerCaseList(tagNames);
        missingTags.removeAll(Tag.getLowerCaseNames(tagPool));

        if (!missingTags.isEmpty()) {
            errorBag.put(parameterName, ERROR_TAGS_DO_NOT_EXIST + YOU_SUPPLIED
                    + StringUtil.convertIterableToString(missingTags));
        }
    }

    /**
     * Checks to ensure that tag names found in {@code task} exist in the {@code tagPool}.
     */
    private void validateTagNamesExist(ImmutableTask task, String... tagNames) {
        if (task != null) {
            validateTagNamesExist(task.getTags(), tagNames);
        }
    }

    /**
     * Checks to ensure that tag names do not exist in the {@code tagPool}.
     */
    private void validateTagNamesDoNotExist(Collection<Tag> tagPool, String... tagNames) {
        if (!Collections.disjoint(Tag.getLowerCaseNames(tagPool), toLowerCaseList(tagNames))) {
            errorBag.put(parameterName, ERROR_TAGS_EXIST + YOU_SUPPLIED + Arrays.toString(tagNames));
        }
    }

    /**
     * Checks to ensure that tag names found in {@code task} do not exist in the {@code tagPool}.
     */
    private void validateTagNamesDoNotExist(ImmutableTask task, String... tagNames) {
        if (task != null) {
            validateTagNamesDoNotExist(task.getTags(), tagNames);
        }
    }

    /**
     * Checks to prevent the case where the tag names provided are actually empty.
     */
    private void validateTagNameMissing(String... tagNames) {
        if (tagNames == null || tagNames.length == 0) {
            errorBag.put(parameterName, ERROR_TAGS_EMPTY);
        }
    }

    /* Private Helper Methods */
    /**
     * Returns true if a given string is a valid tag name (alphanumeric, can contain dashes and underscores)
     * Originated from {@link Tag}
     */
    private static boolean isValidTagName(String test) {
        return TAG_VALIDATION_REGEX.matcher(test).matches();
    }

    /**
     * Returns a list of tag names in lower case.
     */
    private static List<String> toLowerCaseList(String... tagNames) {
        return Arrays.stream(tagNames)
                .map(String::toLowerCase)
                .collect(Collectors.toCollection(ArrayList::new));
    }

    /* Public Helper Methods */
    /**
     * Automates the process for performing data validation.
     *
     * @param actionName Name of the Command action
     * @param consumer The method call that performs the actual validation.
     */
    public static UniqueTagCollectionValidator validate(String actionName,
            Consumer<UniqueTagCollectionValidator> consumer) throws ValidationException {

        UniqueTagCollectionValidator validator = new UniqueTagCollectionValidator(actionName);
        consumer.accept(validator);
        validator.throwsExceptionIfNeeded();
        return validator;
    }
}
```
###### \java\seedu\todo\model\TodoList.java
``` java
    @Override
    public void updateAll(Consumer<MutableTask> update) throws ValidationException {
        //Perform one round of validation first.
        for (MutableTask task : tasks) {
            ValidationTask validationTask = new ValidationTask(task);
            update.accept(validationTask);
            validationTask.validate();
        }

        //When there is no errors, actually do it.
        tasks.forEach(update::accept);
    }

```
###### \java\seedu\todo\model\TodoListModel.java
``` java
    /**
     * Updates every single task, visible and non-visible, that are found inside the {@link TodoListModel}.
     * Refer to {@link #update(List, Consumer)} for more details on usage.
     */
    void updateAll(Consumer<MutableTask> update) throws ValidationException;

```
###### \java\seedu\todo\model\TodoModel.java
``` java
    @Override
    public List<Tag> getGlobalTagsList() {
        return uniqueTagCollection.getUniqueTagList();
    }

    @Override
    public void addTagsToTask(int index, String... tagNames) throws ValidationException {
        saveUndoState();
        addTagsToTaskHelper(index, tagNames);
    }

    @Override
    public void addTagsToTask(MutableTask task, String... tagNames) {
        saveUndoState();
        //Do not perform validation (disallowed by Consumer interface). Perform actual tag adding.
        addTagsToTaskHelper(task, tagNames);
    }

    @Override
    public void deleteTagsFromTask(int index, String... tagNames) throws ValidationException {
        saveUndoState();
        deleteTagsFromTaskHelper(index, tagNames);
    }

    @Override
    public void deleteTags(String... tagNames) throws ValidationException {
        saveUndoState();
        deleteTagsHelper(tagNames);
    }

    @Override
    public void renameTag(String oldName, String newName) throws ValidationException {
        saveUndoState();
        renameTagHelper(oldName, newName);
    }

    @Override
    public void renameTag(int index, String oldName, String newName) throws ValidationException {
        saveUndoState();
        renameTagFromTaskHelper(index, oldName, newName);
    }

    /**
     * Gets the {@link ImmutableTask} object at the respective displayed index.
     * @throws ValidationException when the index is invalid.
     */
    @Override
    public ImmutableTask getTask(int displayedIndex) throws ValidationException {
        int index = getTaskIndex(displayedIndex);
        return tasks.get(index);
    }

    /* Helper Method */
    /**
     * Helper method that validate and handles tag adding operation
     */
    private void addTagsToTaskHelper(int index, String... tagNames)
            throws ValidationException {
        int taskIndex = getTaskIndex(index);
        ImmutableTask task = getTask(index);

        UniqueTagCollectionValidator
                .validate("add tags", validator -> validator.validateAddTags(task, tagNames));

        todoList.update(taskIndex, mutableTask -> {
            assert mutableTask.equals(task); //Just a sanity check.
            addTagsToTaskHelper(mutableTask, tagNames);
        });
    }

    /**
     * Helper method that handles tag adding operation without validation
     */
    private void addTagsToTaskHelper(MutableTask task, String... tagNames) {
        Set<Tag> newTags = new HashSet<>(uniqueTagCollection.associateTaskToTags(task, tagNames));
        newTags.addAll(task.getTags());
        task.setTags(newTags);
    }

    /**
     * Helper method that validates and handles tag deletion from task operation
     */
    private void deleteTagsFromTaskHelper(int index, String... tagNames) throws ValidationException {
        int taskIndex = getTaskIndex(index);
        ImmutableTask task = getTask(index);

        UniqueTagCollectionValidator
                .validate("delete tags", validator -> validator.validateDeleteTags(task, tagNames));

        todoList.update(taskIndex, mutableTask -> {
            Set<Tag> tagsFromTask = new HashSet<>(mutableTask.getTags());
            Collection<Tag> deletedTags = uniqueTagCollection.dissociateTaskFromTags(mutableTask, tagNames);
            tagsFromTask.removeAll(deletedTags);
            mutableTask.setTags(tagsFromTask);
        });
    }

    /**
     * Helper method that validates and handles tag deletion operation
     */
    private void deleteTagsHelper(String... tagNames) throws ValidationException {
        UniqueTagCollectionValidator.validate("delete tags",
                validator -> validator.validateDeleteTags(uniqueTagCollection, tagNames));

        Collection<Tag> deletedTags = uniqueTagCollection.deleteTags(tagNames);
        todoList.updateAll(mutableTask -> {
            Set<Tag> tagsFromTask = new HashSet<>(mutableTask.getTags());
            tagsFromTask.removeAll(deletedTags);
            mutableTask.setTags(tagsFromTask);
        });
    }

    /**
     * Helper method that validates and handles global tag renaming operation
     */
    private void renameTagHelper(String oldName, String newName) throws ValidationException {
        UniqueTagCollectionValidator.validate("rename tag",
                validator -> validator.validateGlobalRenameCommand(uniqueTagCollection, oldName, newName));

        Set<ImmutableTask> tasksWithTag = uniqueTagCollection.getTasksLinkedToTag(oldName);
        deleteTagsHelper(oldName);

        todoList.updateAll(mutableTask -> {
            if (tasksWithTag.contains(mutableTask)) {
                addTagsToTaskHelper(mutableTask, newName);
            }
        });
    }

    /**
     * Helper method that validates and handles tag renaming operation
     */
    private void renameTagFromTaskHelper(int index, String oldName, String newName) throws ValidationException {
        ImmutableTask task = getTask(index);

        UniqueTagCollectionValidator.validate("rename tag",
                validator -> validator.validateRenameCommand(task, oldName, newName));

        deleteTagsFromTaskHelper(index, oldName);
        addTagsToTaskHelper(index, newName);
    }
}
```
###### \java\seedu\todo\ui\controller\CommandController.java
``` java
/**
 * Processes the input command from {@link CommandInputView}, pass it to {@link seedu.todo.logic.Logic}
 * and hands the {@link seedu.todo.logic.commands.CommandResult} to {@link CommandFeedbackView} and
 * {@link CommandErrorView}.
 * Also, {@link CommandPreviewView} is also linked here to listen to user input.
 */
public class CommandController {
    /* Variables */
    private Logic logic;
    private CommandInputView inputView;
    private CommandPreviewView previewView;
    private CommandFeedbackView feedbackView;
    private CommandErrorView errorView;

    /* Private Constructor */
    private CommandController() {}

    /**
     * Constructs a link between the classes defined in the parameters.
     */
    public static CommandController constructLink(Logic logic, CommandInputView inputView,
            CommandPreviewView previewView, CommandFeedbackView feedbackView, CommandErrorView errorView) {

        CommandController controller = new CommandController();
        controller.logic = logic;
        controller.inputView = inputView;
        controller.previewView = previewView;
        controller.feedbackView = feedbackView;
        controller.errorView = errorView;
        controller.start();
        return controller;
    }

    /**
     * Asks {@link #inputView} to start listening for a new key strokes.
     * Once the callback returns a command, {@link #handleInput(KeyCode, String)} will process the input.
     */
    private void start() {
        inputView.listenToInput(this::handleInput);
    }

```
###### \java\seedu\todo\ui\controller\CommandController.java
``` java
    /**
     * Displays error in the respective UI elements
     * @param errorBag group of errors to display
     */
    private void viewDisplayError(ErrorBag errorBag) {
        inputView.flagError();
        feedbackView.flagError();
        errorView.displayErrors(errorBag);
    }

    /**
     * Displays success behaviour in the respective UI elements
     */
    private void viewDisplaySuccess() {
        inputView.resetViewState();
        feedbackView.unFlagError();
        errorView.hideCommandErrorView();
    }

    /**
     * Displays a message with regards to the user's input
     * @param message to be displayed to user
     */
    private void displayMessage(String message) {
        feedbackView.displayMessage(message);
    }
}
```
###### \java\seedu\todo\ui\UiManager.java
``` java
    @Subscribe
    private void handleExpandCollapseTaskEvent(ExpandCollapseTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTodoListView().toggleExpandCollapsed(event.task, event.toCollapse);
    }

    @Subscribe
    private void handleShowHelpEvent(ShowHelpEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getHelpView().displayCommandSummaries(event.getCommandSummaries());
    }

```
###### \java\seedu\todo\ui\UiManager.java
``` java
    @Subscribe
    private void handleCommandInputEnterEvent(CommandInputEnterEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getHelpView().hideHelpPanel();
        mainWindow.getGlobalTagView().hideGlobalTagViewPanel();
        mainWindow.getCommandFeedbackView().clearMessage();
    }

    @Subscribe
    private void handleHighlightTaskEvent(HighlightTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTodoListView().scrollAndSelect(event.getTask());
    }

```
###### \java\seedu\todo\ui\util\FxViewUtil.java
``` java
/**
 * Contains generic utility methods for JavaFX views
 */
public class FxViewUtil {

```
###### \java\seedu\todo\ui\util\FxViewUtil.java
``` java
    /**
     * Applies an anchor to the left, right and bottom boundary of {@code node}.
     */
    public static void applyAnchorBoundaryParameters(Node node, double left, double right, double bottom) {
        AnchorPane.setLeftAnchor(node, left);
        AnchorPane.setRightAnchor(node, right);
        AnchorPane.setBottomAnchor(node, bottom);
    }

    /**
     * Hides a specified UI element, and ensures that it does not occupy any space.
     */
    public static void setCollapsed(Node node, boolean isCollapsed) {
        node.setVisible(!isCollapsed);
        node.setManaged(!isCollapsed);
    }
    
    /**
     * Set the text to UI element when available, collapse the UI element when not.
     */
    public static void displayTextWhenAvailable(Label labelToDisplay, Node nodeToHide,
                                                Optional<String> optionalString) {
        if (optionalString.isPresent()) {
            labelToDisplay.setText(optionalString.get());
        } else {
            labelToDisplay.setText("");
            setCollapsed(nodeToHide, true);
        }
    }

    /**
     * Sets a recurring task on the UI specified in handler to repeat every specified seconds.
     * Does not start until the user executes .play()
     * @param seconds duration between each repeats
     * @param handler method to run is specified here
     * @return {@link Timeline} object to run.
     */
    public static Timeline setRecurringUiTask(int seconds, EventHandler<ActionEvent> handler) {
        Timeline recurringTask = new Timeline(new KeyFrame(Duration.seconds(seconds), handler));
        recurringTask.setCycleCount(Timeline.INDEFINITE);
        return recurringTask;
    }

    /**
     * Converts an index from a list to the index that is displayed to the user via the Ui
     */
    public static int convertToListIndex(int uiIndex) {
        return uiIndex - 1;
    }

    /**
     * Converts an index displayed on the Ui to the user, to the index used on the list
     */
    public static int convertToUiIndex(int listIndex) {
        return listIndex + 1;
    }
}
```
###### \java\seedu\todo\ui\util\UiPartLoaderUtil.java
``` java
    /**
     * Attaches only one children view element to a specified placeholder.
     * However, if either one of the params is null, it will result in no-op.
     * Also, if there are any other children in the placeholder, they will be cleared first.
     *
     * @param placeholder to add the childrenView to, no-op if null
     * @param childrenView to be attached to the placeholder, no-op if null
     */
    private static void attachToPlaceholder(AnchorPane placeholder, Node childrenView) {
        if (placeholder != null && childrenView != null) {
            ObservableList<Node> placeholderChildren = placeholder.getChildren();
            placeholderChildren.clear();
            placeholderChildren.add(childrenView);
        }
    }
}
```
###### \java\seedu\todo\ui\util\ViewGeneratorUtil.java
``` java
/**
 * A utility class that generates commonly used UI elements, such as Labels.
 */
public class ViewGeneratorUtil {

    /**
     * Generates a {@link Text} object with the class style applied onto the object.
     * @param string to be wrapped in the {@link Text} object
     * @param classStyle css style to be applied to the label
     * @return a {@link Text} object
     */
    public static Text constructText(String string, String classStyle) {
        Text text = new Text(string);
        ViewStyleUtil.addClassStyles(text, classStyle);
        return text;
    }

    /**
     * Constructs a label view with a dark grey rounded background.
     */
    public static Label constructRoundedText(String string) {
        Label label = constructLabel(string, "roundLabel");
        label.setPadding(new Insets(0, 8, 0, 8));
        return label;
    }

    /**
     * Generates a {@link Label} object with the class style applied onto the object.
     * @param string to be wrapped in the {@link Label} object
     * @param classStyle css style to be applied to the label
     * @return a {@link Label} object
     */
    public static Label constructLabel(String string, String classStyle) {
        Label label = new Label(string);
        ViewStyleUtil.addClassStyles(label, classStyle);
        return label;
    }

    /**
     * Place all the specified texts into a {@link TextFlow} object.
     */
    public static TextFlow placeIntoTextFlow(Text... texts) {
        return new TextFlow(texts);
    }
}
```
###### \java\seedu\todo\ui\util\ViewStyleUtil.java
``` java
/**
 * Deals with the CSS styling of View elements
 */
public class ViewStyleUtil {

    /* Style Classes Constants */
    public static final String STYLE_COLLAPSED = "collapsed";
    public static final String STYLE_COLLAPSIBLE = "collapsible";
    public static final String STYLE_COMPLETED = "completed";
    public static final String STYLE_OVERDUE = "overdue";
    public static final String STYLE_SELECTED = "selected";
    public static final String STYLE_TEXT_4 = "text4";
    public static final String STYLE_ERROR = "error";
    public static final String STYLE_CODE = "code";
    public static final String STYLE_CODE_BOLDER = "codeBolder";
    public static final String STYLE_UNDERLINE = "underline";
    public static final String STYLE_ONGOING = "ongoing";

    /*Static Helper Methods*/
    /**
     * Adds only one instance of all the class styles to the node object
     * @param node view object to add the class styles to
     * @param classStyles all the class styles that is to be added to the node
     */
    public static void addClassStyles(Node node, String... classStyles) {
        for (String classStyle : classStyles) {
            addClassStyle(node, classStyle);
        }
    }

    /**
     * Remove all instance of all the class styles to the node object
     * @param node view object to add the class styles to
     * @param classStyles all the class styles that is to be removed from the node
     */
    public static void removeClassStyles(Node node, String... classStyles) {
        for (String classStyle : classStyles) {
            removeClassStyle(node, classStyle);
        }
    }

    /**
     * Adds or removes class style based on a boolean parameter
     * @param isAdding true to add, false to remove
     * @param node view object to add the class styles to
     * @param classStyles all the class styles that is to be added to/removed from the node
     */
    public static void addRemoveClassStyles(boolean isAdding, Node node, String... classStyles) {
        for (String classStyle : classStyles) {
            if (isAdding) {
                addClassStyles(node, classStyle);
            } else {
                removeClassStyles(node, classStyle);
            }
        }
    }

    /**
     * Toggles one style class to the node:
     * If supplied style class is available, remove it. Else, add one instance of it.
     *
     * @return true if toggled from OFF -> ON
     */
    public static boolean toggleClassStyle(Node node, String classStyle) {
        boolean wasPreviouslyOff = !node.getStyleClass().contains(classStyle);
        if (wasPreviouslyOff) {
            addClassStyles(node, classStyle);
        } else {
            removeClassStyles(node, classStyle);
        }
        return wasPreviouslyOff;
    }

    /* Private Helper Methods */
    /**
     * Adds only one instance of a single class style to the node object
     */
    private static void addClassStyle(Node node, String classStyle) {
        if (!node.getStyleClass().contains(classStyle)) {
            node.getStyleClass().add(classStyle);
        }
    }

    /**
     * Removes all instances of a single class style from the node object
     */
    private static void removeClassStyle(Node node, String classStyle) {
        while (node.getStyleClass().contains(classStyle)) {
            node.getStyleClass().remove(classStyle);
        }
    }
}
```
###### \java\seedu\todo\ui\view\CommandErrorView.java
``` java
/**
 * A view class that displays specific command errors in greater detail.
 */
public class CommandErrorView extends UiPart {
    /* Constants */
    private static final String FXML = "CommandErrorView.fxml";

    /* Layouts */
    private AnchorPane placeholder;
    private VBox errorViewBox;
    @FXML private VBox nonFieldErrorBox;
    @FXML private VBox fieldErrorBox;
    @FXML private GridPane nonFieldErrorGrid;
    @FXML private GridPane fieldErrorGrid;

```
###### \java\seedu\todo\ui\view\CommandErrorView.java
``` java
    /**
     * Configure the UI layout of {@link CommandErrorView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(errorViewBox, 0.0, 0.0, 0.0);
    }

    /**
     * Displays both field and non-field errors to the user
     * @param errorBag that contains both field and non-field errors
     */
    public void displayErrors(ErrorBag errorBag) {
        showCommandErrorView();
        clearOldErrorsFromViews();
        displayFieldErrors(errorBag.getFieldErrors());
        displayNonFieldErrors(errorBag.getNonFieldErrors());
    }

    /**
     * Feeds non field errors to the {@link #nonFieldErrorGrid}.
     * If there are no non-field errors, then {@link #nonFieldErrorBox} will be hidden.
     * @param nonFieldErrors that stores a list of non-field errors
     */
    private void displayNonFieldErrors(List<String> nonFieldErrors) {
        if (nonFieldErrors.isEmpty()) {
            hideErrorBox(nonFieldErrorBox);
        } else {
            int rowCounter = 0;
            for (String error : nonFieldErrors) {
                addRowToGrid(nonFieldErrorGrid, rowCounter++, rowCounter + ".", error);
            }
        }
    }

    /**
     * Feeds field errors to the {@link #fieldErrorGrid}.
     * If there are no field errors, then {@link #fieldErrorBox} will be hidden.
     * @param fieldErrors that stores the field errors
     */
    private void displayFieldErrors(Map<String, String> fieldErrors) {
        if (fieldErrors.isEmpty()) {
            hideErrorBox(fieldErrorBox);
        } else {
            int rowCounter = 0;
            for (Map.Entry<String, String> fieldError : fieldErrors.entrySet()) {
                addRowToGrid(fieldErrorGrid, rowCounter++, fieldError.getKey(), fieldError.getValue());
            }
        }
    }

    /* Override Methods */
    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeholder = placeholder;
    }

    @Override
    public void setNode(Node node) {
        this.errorViewBox = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    /*Helper Methods*/
    /**
     * Adds a row of text to the targetGrid
     * @param targetGrid to add a row of text on
     * @param rowIndex which row to add this row of text
     * @param leftText text for the first column
     * @param rightText text for the second column
     */
    private void addRowToGrid(GridPane targetGrid, int rowIndex, String leftText, String rightText) {
        Label leftLabel = ViewGeneratorUtil.constructLabel(leftText, ViewStyleUtil.STYLE_TEXT_4);
        Label rightLabel = ViewGeneratorUtil.constructLabel(rightText, ViewStyleUtil.STYLE_TEXT_4);
        rightLabel.setWrapText(true);
        targetGrid.addRow(rowIndex, leftLabel, rightLabel);
    }

    /**
     * Clears all elements in the given grid.
     */
    private void clearGrid(GridPane gridPane) {
        gridPane.getChildren().clear();
    }

    /**
     * Hides a field or non-field error box.
     * @param vBox can be either {@link #fieldErrorBox} or {@link #nonFieldErrorBox}
     */
    private void hideErrorBox(VBox vBox) {
        FxViewUtil.setCollapsed(vBox, true);
    }

    /**
     * Shows a field or non-field error box.
     * @param vBox can be either {@link #fieldErrorBox} or {@link #nonFieldErrorBox}
     */
    private void showErrorBox(VBox vBox) {
        FxViewUtil.setCollapsed(vBox, false);
    }

    /**
     * Hides the entire {@link CommandErrorView}
     */
    public void hideCommandErrorView() {
        FxViewUtil.setCollapsed(placeholder, true);
    }

    /**
     * Displays the entire {@link CommandErrorView}
     */
    private void showCommandErrorView() {
        FxViewUtil.setCollapsed(placeholder, false);
    }

    /**
     * Clears previous errors from the grid, and then unhide all the error boxes.
     */
    private void clearOldErrorsFromViews() {
        clearGrid(nonFieldErrorGrid);
        clearGrid(fieldErrorGrid);
        showErrorBox(nonFieldErrorBox);
        showErrorBox(fieldErrorBox);
    }
}
```
###### \java\seedu\todo\ui\view\CommandFeedbackView.java
``` java
/**
 * Display textual feedback to command input via this view with {@link #displayMessage(String)}.
 */
public class CommandFeedbackView extends UiPart {
    /* Constants */
    private static final String FXML = "CommandFeedbackView.fxml";

    /* Variables */
    private final Logger logger = LogsCenter.getLogger(CommandFeedbackView.class);

    /* Layout Elements */
    @FXML private Label commandFeedbackLabel;
    private AnchorPane textContainer;

```
###### \java\seedu\todo\ui\view\CommandFeedbackView.java
``` java
    /* Interfacing Methods */
    /**
     * Displays a message onto the {@link #commandFeedbackLabel}.
     * @param message The feedback message to be shown to the user.
     */
    public void displayMessage(String message) {
        commandFeedbackLabel.setText(message);
    }

    /**
     * Clears any message in {@link #commandFeedbackLabel}.
     */
    public void clearMessage() {
        commandFeedbackLabel.setText("");
    }

    /**
     * Indicate an error visually on the {@link #commandFeedbackLabel}.
     */
    public void flagError() {
        ViewStyleUtil.addClassStyles(commandFeedbackLabel, ViewStyleUtil.STYLE_ERROR);
    }

    /**
     * Remove the error flag visually on the {@link #commandFeedbackLabel}.
     */
    public void unFlagError() {
        ViewStyleUtil.removeClassStyles(commandFeedbackLabel, ViewStyleUtil.STYLE_ERROR);
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        this.textContainer = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\todo\ui\view\CommandInputView.java
``` java
/**
 * A view class that handles the Input text box directly.
 */
public class CommandInputView extends UiPart {
    /* Constants */
    private static final String FXML = "CommandInputView.fxml";

    /* Layout Elements */
    private AnchorPane commandInputPane;
    @FXML private TextArea commandTextField;

```
###### \java\seedu\todo\ui\view\CommandInputView.java
``` java
    /**
     * Configure the UI properties of {@link CommandInputView}
     */
    private void configureProperties() {
        setCommandInputHeightAutoResizeable();
        unflagErrorWhileTyping();
        listenAndRaiseEnterEvent();
    }

```
###### \java\seedu\todo\ui\view\CommandInputView.java
``` java
    /**
     * Listens for Enter keystrokes, and raises an event when it happens.
     */
    public void listenAndRaiseEnterEvent() {
        this.commandTextField.addEventHandler(KeyEvent.KEY_PRESSED, event -> {
            if (event.getCode() == KeyCode.ENTER) {
                EventsCenter.getInstance().post(new CommandInputEnterEvent());
                event.consume(); //To prevent commandTextField from printing a new line.
            }
        });
    }

    /* UI Methods */
    /**
     * Resets the text box by {@link #unflagError()} after a key is pressed
     */
    private void unflagErrorWhileTyping() {
        this.commandTextField.addEventFilter(KeyEvent.KEY_PRESSED, event -> unflagError());
    }

    /**
     * Allow {@link #commandTextField} to adjust automatically with the height of the content of the
     * text area itself.
     */
    private void setCommandInputHeightAutoResizeable() {
        new TextAreaResizer(commandTextField);
    }

    /**
     * Resets the state of the text box, by clearing the text box and clear the errors.
     */
    public void resetViewState() {
        unflagError();
        clear();
    }

    /**
     * Indicate an error visually on the {@link #commandTextField}
     */
    public void flagError() {
        ViewStyleUtil.addClassStyles(commandTextField, ViewStyleUtil.STYLE_ERROR);
    }

    /**
     * Remove the error flag visually on the {@link #commandTextField}
     */
    private void unflagError() {
        ViewStyleUtil.removeClassStyles(commandTextField, ViewStyleUtil.STYLE_ERROR);
    }

    /**
     * Clears the texts inside the text box
     */
    private void clear() {
        commandTextField.clear();
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        commandInputPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

```
###### \java\seedu\todo\ui\view\EmptyListView.java
``` java
/**
 * Displays the message when {@link TodoListView} is empty.
 */
public class EmptyListView extends UiPart {

    /* Constants */
    private static final String FXML = "EmptyListView.fxml";

    private static final String EMPTY_MESSAGE_DEFAULT
            = "Hello. Type 'add' to add a new task or event.";
    private static final String EMPTY_MESSAGE_COMPLETED
            = "You have no completed tasks and past events.";
    private static final String EMPTY_MESSAGE_INCOMPLETE
            = "You have no incomplete tasks and upcoming events.";
    private static final String EMPTY_MESSAGE_DUE_SOON
            = "You have no tasks due soon.";
    private static final String EMPTY_MESSAGE_EVENTS
            = "You have no upcoming events.";
    private static final String EMPTY_MESSAGE_TODAY
            = "You have no tasks and events for today.";

    private static final String EMOJI_DEFAULT = "/images/emoji-default.png";
    private static final String EMOJI_COMPLETED = "/images/emoji-completed.png";
    private static final String EMOJI_INCOMPLETE = "/images/emoji-incomplete.png";
    private static final String EMOJI_EVENTS = "/images/emoji-events.png";
    private static final String EMOJI_DUESOON = "/images/emoji-duesoon.png";
    private static final String EMOJI_TODAY = "/images/emoji-today.png";

    /*Layouts*/
    private AnchorPane emptyListPlaceholder;
    @FXML private VBox emptyListView;
    @FXML private ImageView emptyListImage;
    @FXML private Label emptyListLabel;

    /**
     * Loads and initialise the {@link #emptyListView} to the {@code placeholder}.
     * @param primaryStage of the application
     * @param placeholder where the view element {@link #emptyListView} should be placed
     * @param todoList for checking whether the list is empty.
     * @param viewProperty the view that the user is at.
     * @return an instance of this class
     */
    public static EmptyListView load(Stage primaryStage, AnchorPane placeholder,
            ObservableList<ImmutableTask> todoList, ObjectProperty<TaskViewFilter> viewProperty) {

        EmptyListView emptyListView =  UiPartLoaderUtil
                .loadUiPart(primaryStage, placeholder, new EmptyListView());

        emptyListView.configureLayout();
        emptyListView.setEmptyListConnections(todoList, viewProperty);
        return emptyListView;
    }

    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(emptyListView, 0.0, 0.0, 0.0, 0.0);
    }


    /* Empty List View Methods */
    /**
     * Configures the {@link EmptyListView} with the {@code todoList} property and {@code viewProperty}
     * property.
     */
    private void setEmptyListConnections(ObservableList<ImmutableTask> todoList,
                                         ObjectProperty<TaskViewFilter> viewProperty) {

        ListChangeListener<ImmutableTask> visibilityUpdate
                = c -> setEmptyListViewVisibility(todoList.isEmpty());

        ChangeListener<TaskViewFilter> viewUpdate
                = (observable, oldValue, newValue) -> setEmptyListContent(newValue);

        todoList.addListener(visibilityUpdate);
        visibilityUpdate.onChanged(null);

        viewProperty.addListener(viewUpdate);
        viewUpdate.changed(null, null, viewProperty.get());
    }

    /**
     * Displays the {@link #emptyListView} if {@code isVisible} is true, hides otherwise.
     */
    private void setEmptyListViewVisibility(boolean isVisible) {
        FxViewUtil.setCollapsed(emptyListPlaceholder, !isVisible);
    }

    /**
     * Sets the content of empty list based on {@link TaskViewFilter}
     */
    private void setEmptyListContent(TaskViewFilter filter) {
        if (filter == TaskViewFilter.COMPLETED) {
            setEmptyListContent(EMPTY_MESSAGE_COMPLETED, EMOJI_COMPLETED);

        } else if (filter == TaskViewFilter.INCOMPLETE) {
            setEmptyListContent(EMPTY_MESSAGE_INCOMPLETE, EMOJI_INCOMPLETE);

        } else if (filter == TaskViewFilter.DUE_SOON) {
            setEmptyListContent(EMPTY_MESSAGE_DUE_SOON, EMOJI_DUESOON);

        } else if (filter == TaskViewFilter.EVENTS) {
            setEmptyListContent(EMPTY_MESSAGE_EVENTS, EMOJI_EVENTS);

        } else if (filter == TaskViewFilter.TODAY) {
            setEmptyListContent(EMPTY_MESSAGE_TODAY, EMOJI_TODAY);

        } else {
            setEmptyListContent(EMPTY_MESSAGE_DEFAULT, EMOJI_DEFAULT);
        }
    }

    /**
     * Sets the content of empty list by {@code message} and {@code imageUrl}
     */
    private void setEmptyListContent(String message, String imageUrl) {
        emptyListLabel.setText(message);
        emptyListImage.setImage(new Image(imageUrl));
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        this.emptyListView = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.emptyListPlaceholder = placeholder;
    }
}
```
###### \java\seedu\todo\ui\view\FilterBarView.java
``` java
/**
 * Shows a row of filter categories via {@link TaskViewFilter}
 * to filter the tasks in {@link TodoListView}
 */
public class FilterBarView extends UiPart {
    /* Constants */
    private final Logger logger = LogsCenter.getLogger(FilterBarView.class);
    private static final String FXML = "FilterBarView.fxml";

    /* Layout Views */
    private FlowPane filterViewPane;

    /* Variables */
    private Map<TaskViewFilter, HBox> taskFilterBoxesMap = new HashMap<>();

    /* Layout Initialisation */
    /**
     * Loads and initialise the {@link #filterViewPane} to the {@link seedu.todo.ui.MainWindow}
     * @param primaryStage of the application
     * @param placeholder where the view element {@link #filterViewPane} should be placed
     * @return an instance of this class
     */
    public static FilterBarView load(Stage primaryStage, AnchorPane placeholder,
                                     ObservableValue<TaskViewFilter> filter) {

        FilterBarView filterView = UiPartLoaderUtil
                .loadUiPart(primaryStage, placeholder, new FilterBarView());
        filterView.configureLayout();
        filterView.configureProperties();
        filterView.bindListener(filter);
        return filterView;
    }

    /**
     * Configure the UI layout of {@link FilterBarView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(filterViewPane, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Initialise and configure the UI properties of {@link FilterBarView}
     */
    private void configureProperties() {
        initialiseAllViewFilters();
        selectOneViewFilter(TaskViewFilter.DEFAULT);
    }

    /**
     * Display all the {@link TaskViewFilter} on the {@link #filterViewPane}
     */
    private void initialiseAllViewFilters() {
        for (TaskViewFilter filter : TaskViewFilter.all()) {
            appendEachViewFilter(filter);
        }
    }

    /**
     * Add one {@link TaskViewFilter} on the {@link #filterViewPane}
     * and save an instance to the {@link #taskFilterBoxesMap}
     * @param filter to add onto the pane
     */
    private void appendEachViewFilter(TaskViewFilter filter) {
        HBox textContainer = constructViewFilterBox(filter);
        taskFilterBoxesMap.put(filter, textContainer);
        filterViewPane.getChildren().add(textContainer);
    }

    /**
     * Given a filter, construct a view element to be displayed on the {@link #filterViewPane}
     * @param filter to be displayed
     * @return a view element
     */
    private HBox constructViewFilterBox(TaskViewFilter filter) {
        String filterName = WordUtils.capitalize(filter.name);
        String[] partitionedText = StringUtil.partitionStringAtPosition(filterName, filter.shortcutCharPosition);

        Label leftLabel = new Label(partitionedText[0]);
        Label centreLabel = new Label(partitionedText[1]);
        Label rightLabel = new Label(partitionedText[2]);
        ViewStyleUtil.addClassStyles(centreLabel, ViewStyleUtil.STYLE_UNDERLINE);

        HBox textContainer = new HBox(leftLabel, centreLabel, rightLabel);
        textContainer.getStyleClass().add("viewFilterItem");
        return textContainer;
    }

    /**
     * Binds this component with the {@link TaskViewFilter} property it listens to
     */
    private void bindListener(ObservableValue<TaskViewFilter> filter) {
        filter.addListener((observable, oldValue, newValue) -> selectOneViewFilter(newValue));
    }
    
    /**
     * Select exactly one filter from {@link #filterViewPane}
     */
    public void selectOneViewFilter(TaskViewFilter filter) {
        clearAllViewFiltersSelection();
        selectViewFilter(filter);
    }

    /* Helper Methods */
    /**
     * Clears all selection from the {@link #filterViewPane}
     */
    private void clearAllViewFiltersSelection() {
        for (HBox filterBox : taskFilterBoxesMap.values()) {
            ViewStyleUtil.removeClassStyles(filterBox, ViewStyleUtil.STYLE_SELECTED);
        }
    }

    /**
     * Mark the filter as selected on {@link #filterViewPane}
     * However, if filter is null, nothing is done.
     */
    private void selectViewFilter(TaskViewFilter filter) {
        if (filter != null) {
            HBox filterBox = taskFilterBoxesMap.get(filter);
            ViewStyleUtil.addClassStyles(filterBox, ViewStyleUtil.STYLE_SELECTED);
        }
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        this.filterViewPane = (FlowPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\todo\ui\view\HelpView.java
``` java
/**
 * A view that displays all the help commands in a single view.
 */
public class HelpView extends UiPart {

    /* Constants */
    private static final String FXML = "HelpView.fxml";
    private static final int PREF_WIDTH = 340;

    /* Variables */
    private final Logger logger = LogsCenter.getLogger(HelpView.class);

    /*Layouts*/
    private VBox helpPanelView;
    @FXML private GridPane helpGrid;

    /**
     * Loads and initialise the feedback view element to the placeHolder
     * @param primaryStage of the application
     * @param placeholder where the view element {@link #helpPanelView} should be placed
     * @return an instance of this class
     */
    public static HelpView load(Stage primaryStage, AnchorPane placeholder) {
        HelpView helpView = UiPartLoaderUtil.loadUiPart(primaryStage, placeholder, new HelpView());
        helpView.configureLayout();
        helpView.hideHelpPanel();
        return helpView;
    }

    /**
     * Configure the UI layout of {@link CommandErrorView}
     */
    private void configureLayout() {
        FxViewUtil.applyAnchorBoundaryParameters(helpPanelView, 0.0, 0.0, 0.0);
    }

    /**
     * Displays a list of commands into the helpPanelView
     */
    public void displayCommandSummaries(List<CommandSummary> commandSummaries) {
        this.showHelpPanel();
        helpGrid.getChildren().clear();
        int rowIndex = 0;
        for (CommandSummary commandSummary : commandSummaries) {
            appendCommandSummary(rowIndex++, commandSummary);
        }
    }

    /**
     * Add a command summary to each row of the helpGrid
     * @param rowIndex the row number to which the command summary should append to
     * @param commandSummary to be displayed
     */
    private void appendCommandSummary(int rowIndex, CommandSummary commandSummary) {
        Text commandScenario = ViewGeneratorUtil
                .constructText(commandSummary.scenario, ViewStyleUtil.STYLE_TEXT_4);
        Text commandName = ViewGeneratorUtil
                .constructText(commandSummary.command, ViewStyleUtil.STYLE_TEXT_4);
        Text commandArgument = ViewGeneratorUtil
                .constructText(" " + commandSummary.arguments, ViewStyleUtil.STYLE_TEXT_4);

        ViewStyleUtil.addClassStyles(commandArgument, ViewStyleUtil.STYLE_CODE);
        ViewStyleUtil.addClassStyles(commandName, ViewStyleUtil.STYLE_CODE_BOLDER);
        TextFlow combinedCommand = ViewGeneratorUtil.placeIntoTextFlow(commandName, commandArgument);
        combinedCommand.setPrefWidth(PREF_WIDTH);

        helpGrid.addRow(rowIndex, commandScenario, combinedCommand);
    }

    /* Ui Methods */
    public void hideHelpPanel() {
        FxViewUtil.setCollapsed(helpPanelView, true);
    }

    private void showHelpPanel() {
        FxViewUtil.setCollapsed(helpPanelView, false);
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        this.helpPanelView = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\todo\ui\view\TaskCardView.java
``` java
/**
 * This class links up with TaskCardView.fxml layout to display details of a given
 * ReadOnlyTask to users via the TaskListPanel.fxml.
 */
public class TaskCardView extends UiPart {
    /*Constants*/
    public static final String TAG_LABEL_ID = "tagLabel";

    private static final String FXML = "TaskCardView.fxml";
    private static final String TASK_TYPE = "Task";
    private static final String EVENT_TYPE = "Event";
    private static final int INSERT_TAG_INDEX = 2;

    /*Static Field*/
    /*
        Provides a global reference between an ImmutableTask to the wrapper TaskCardView class,
        since we have no direct access of TaskCardView from the ListView object.
     */
    private static final Map<ImmutableTask, TaskCardView> taskCardMap = new HashMap<>();

```
###### \java\seedu\todo\ui\view\TaskCardView.java
``` java
    /**
     * Displays all other view elements, including title, type label, pin image, description and location texts.
     */
    private void displayEverythingElse() {
        titleLabel.setText(String.valueOf(displayedIndex) + ". " + task.getTitle());
        pinImage.setVisible(task.isPinned());
        typeLabel.setText(task.isEvent() ? EVENT_TYPE : TASK_TYPE);
        FxViewUtil.displayTextWhenAvailable(descriptionLabel, descriptionBox, task.getDescription());
        FxViewUtil.displayTextWhenAvailable(locationLabel, locationBox, task.getLocation());
    }
    
    /**
     * Displays the tags in lexicographical order, ignoring case.
     */
    private void displayTags(){
        task.getTags()
            .stream()
            .map(Tag::getTagName)
            .sorted(Comparator.reverseOrder())
            .forEach(tagName -> {
                titleFlowPane.getChildren().add(INSERT_TAG_INDEX, constructTagLabel(tagName));
            });
    }

    /**
     * Constructs an appropriately styled tag label.
     */
    private Label constructTagLabel(String tagName) {
        Label tagLabel = ViewGeneratorUtil.constructRoundedText(tagName);
        tagLabel.setId(TAG_LABEL_ID);
        return tagLabel;
    }
    
```
###### \java\seedu\todo\ui\view\TaskCardView.java
``` java
    /**
     * Initialise the view to show collapsed state if it can be collapsed,
     * else hide the {@link #moreInfoLabel} otherwise.
     */
    private void initialiseCollapsibleView() {
        ViewStyleUtil.addRemoveClassStyles(true, taskCard, ViewStyleUtil.STYLE_COLLAPSED);
        FxViewUtil.setCollapsed(moreInfoLabel, !isTaskCollapsible());
    }
    
    /**
     * Displays formatted task or event timings in the time field.
     */
    private void displayTimings() {
        String displayTimingOutput;
        Optional<LocalDateTime> startTime = task.getStartTime();
        Optional<LocalDateTime> endTime = task.getEndTime();
        boolean isEventWithTime = task.isEvent() && startTime.isPresent() && endTime.isPresent();
        boolean isTaskWithTime = !task.isEvent() && endTime.isPresent();
        
        if (isEventWithTime) {
            displayTimingOutput = timeUtil.getEventTimeText(startTime.get(), endTime.get());
        } else if (isTaskWithTime) {
            displayTimingOutput = timeUtil.getTaskDeadlineText(endTime.get());
        } else {
            FxViewUtil.setCollapsed(dateBox, true);
            return;
        }
        dateLabel.setText(displayTimingOutput);
    }

    /**
     * Allows timing, and deadline highlight style to be updated automatically.
     */
    private void setTimingAutoUpdate() {
        Timeline timeline = FxViewUtil.setRecurringUiTask(30, event -> {
            displayTimings();
            setStyle();
        });
        timeline.play();
    }

    /* Methods interfacing with UiManager*/
    /**
     * Toggles the task card's collapsed or expanded state, only if this card is collapsible.
     */
    public void toggleCardCollapsing() {
        if (isTaskCollapsible()) {
            //Sets both the collapsed style of the card, and mark the visibility of the "more" label.
            boolean isCollapsing = ViewStyleUtil.toggleClassStyle(taskCard, ViewStyleUtil.STYLE_COLLAPSED);
            FxViewUtil.setCollapsed(moreInfoLabel, !isCollapsing);
        }
    }
    
    public void setCardCollapsing(boolean isCollapsing) {
        if (isTaskCollapsible()) {
            ViewStyleUtil.addRemoveClassStyles(isCollapsing, taskCard, ViewStyleUtil.STYLE_COLLAPSED);
            FxViewUtil.setCollapsed(moreInfoLabel, !isCollapsing);
        }
    }
    

    /**
     * Displays in the Ui whether this card is selected
     * @param isSelected true when the card is selected
     */
    public void markAsSelected(boolean isSelected) {
        ViewStyleUtil.addRemoveClassStyles(isSelected, taskCard, ViewStyleUtil.STYLE_SELECTED);
    }

    /* Helper Methods */
    /**
     * Returns true if this task card can be collapsed, based on the information given from the
     * {@link ImmutableTask}
     */
    private boolean isTaskCollapsible() {
        return task.getDescription().isPresent();
    }

    /* Getters */
    /**
     * Gets the mapped {@link TaskCardView} object from an {@link ImmutableTask} object
     * @param task that is being wrapped by the {@link TaskCardView} object
     * @return a {@link TaskCardView} object that contains this task (can be null if not available)
     */
    public static TaskCardView getTaskCard(ImmutableTask task) {
        return taskCardMap.get(task);
    }

    public int getDisplayedIndex() {
        return displayedIndex;
    }

    public VBox getLayout() {
        return taskCard;
    }

    /* Override Methods */
    @Override
    public void setNode(Node node) {
        taskCard = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\todo\ui\view\TodoListView.java
``` java
/**
 * A panel that holds all the tasks inflated from TaskCardView.
 */
public class TodoListView extends UiPart {
    /*Constants*/
    private static final String FXML = "TodoListView.fxml";
    
    /*Variables*/
    private final Logger logger = LogsCenter.getLogger(TodoListView.class);
    
    /*Layout Declarations*/
    private VBox panel;
    @FXML private ListView<ImmutableTask> todoListView;

```
###### \java\seedu\todo\ui\view\TodoListView.java
``` java
    /**
     * Configures the {@link TodoListView}
     *
     * @param todoList A list of {@link ImmutableTask} to be displayed on this {@link #todoListView}.
     */
    private void configure(ObservableList<ImmutableTask> todoList) {
        setTodoListConnections(todoList);
    }

    /* To-do List Ui Methods */
    /**
     * Links the list of {@link ImmutableTask} to the {@link #todoListView}.
     *
     * @param todoList A list of {@link ImmutableTask} to be displayed on this {@link #todoListView}.
     */
    private void setTodoListConnections(ObservableList<ImmutableTask> todoList) {
        todoListView.setItems(todoList);
        todoListView.setCellFactory(param -> new TodoListViewCell());
    }

    /**
     * Toggles the expanded/collapsed view of a task card.
     *
     * @param task The specific to be expanded or collapsed from view.
     */
    public void toggleExpandCollapsed(ImmutableTask task, Boolean toCollapse) {
        TaskCardView taskCardView = TaskCardView.getTaskCard(task);
        if (taskCardView != null && toCollapse == null) {
            taskCardView.toggleCardCollapsing();
        }
        else if (taskCardView != null && toCollapse != null) {
            taskCardView.setCardCollapsing(toCollapse);
        }
    }

    /**
     * Scrolls the {@link #todoListView} to the particular task card.
     *
     * @param task for the list to scroll to.
     */
    public void scrollAndSelect(ImmutableTask task) {
        todoListView.getSelectionModel().clearSelection();
        if (task!=null) {
            todoListView.getSelectionModel().select(task);
        }
        
    }


    /* Override Methods */
    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

```
###### \java\seedu\todo\ui\view\TodoListView.java
``` java
        /**
         * Sets the style properties of a cell on the to-do list, that cannot be done in any other places.
         */
        private void setTaskCardStyleProperties(TaskCardView taskCardView) {
            this.setPadding(Insets.EMPTY);
            this.selectedProperty().addListener((observable, oldValue, newValue)
                    -> taskCardView.markAsSelected(newValue));
        }
    }
}
```
###### \resources\style\DefaultStyle.css
``` css
.main {
    -fx-background-color: #2D2D2D;
    -fx-border-color: #00A4FF;
    -fx-border-width: 1px;
    -fx-padding: 12;
    -fx-spacing: 4;
    -fx-font-family: "Roboto";
}

.text1 {
    -fx-text-fill: #f3f3f3;
    -fx-fill: #f3f3f3;
    -fx-font-family: "Roboto Bold";
    -fx-font-size: 17pt;
}

.text2 {
    -fx-text-fill: #f3f3f3;
    -fx-fill: #f3f3f3;
    -fx-font-family: "Roboto Medium";
    -fx-font-size: 15pt;
}

.text3 {
    -fx-text-fill: #f3f3f3;
    -fx-fill: #f3f3f3;
    -fx-font-family: "Roboto Medium";
    -fx-font-size: 13pt;
}

.text4 {
    -fx-text-fill: #f3f3f3;
    -fx-fill: #f3f3f3;
    -fx-font-size: 12pt;
}

.code {
    -fx-font-family: "Roboto Mono";
}

.codeBolder {
    -fx-font-family: "Roboto Mono Medium";
}

.bolder {
    -fx-font-weight: bolder;
}

.underline {
    -fx-underline: true;
}

.grey {
    -fx-background-color: #2D2D2D;
}

.gridPanel {
    -fx-hgap: 16pt;
    -fx-vgap: 2pt;
    -fx-background-color: #3D3D3D;
    -fx-padding: 8 8 8 8;
}

.spacingBig {
    -fx-spacing: 16px;
    -fx-hgap: 16px;
    -fx-vgap: 16px;
}

.spacing {
    -fx-spacing: 8px;
    -fx-hgap: 8px;
    -fx-vgap: 8px;
}

.spacingSmall {
    -fx-spacing: 2px;
    -fx-hgap: 2px;
    -fx-vgap: 2px;
}

.subheadingPadding {
    -fx-padding: 0 0 0 2;
}


.commandFeedback{
    -fx-text-fill: #f3f3f3;
    -fx-font-family: "Roboto Medium";
    -fx-font-size: 12pt;
}

.commandFeedback.error {
    -fx-text-fill: #FF6464;
}

.commandInput {
    -fx-font-family: "Roboto Mono Medium";
    -fx-font-size: 20px;
}

.commandInput.error {
    -fx-border-color: #FF6464;
    -fx-border-width: 2px;
    -fx-text-fill: #FF6464;
}

.commandError {
    -fx-text-fill: #f3f3f3;
    -fx-font-size: 12pt;
    -fx-wrap-text: true;
}

.roundLabel {
    -fx-background-radius: 100;
    -fx-text-fill: #f3f3f3;
    -fx-background-color: #2D2D2D;
    -fx-font-size: 10pt;
}

.roundLabel.white {
    -fx-text-fill: #2D2D2D;
    -fx-background-color: #f3f3f3;
    -fx-font-size: 12pt;
}

/***View Filter Styles Start***/
.viewFilter {
    -fx-padding: -12 0 0 0;
    -fx-hgap: -3;
}

.viewFilter .label {
    -fx-font-family: "Roboto Bold";
    -fx-font-size: 14pt;
    -fx-font-smoothing-type: gray;
    -fx-text-fill: #ddd;
}

.viewFilter .viewFilterItem {
    -fx-padding: 0 12 2;
}

.viewFilter .selected {
    -fx-background-color: #f3f3f3;
    -fx-background-radius: 100;
}

.viewFilter .selected .label {
    -fx-text-fill: #2D2D2D;
}

```
###### \resources\style\DefaultStyle.css
``` css
/***TaskCardView Styles Start***/
/*Default and Base*/
.taskCard {
    primary-color: transparent;
    font-color: #444;
    selected-color: #00A4FF;
    
    -fx-border-width: 0 12 0 0;
    -fx-border-color: primary-color;
}

.taskCard #dateBox {
    -fx-background-color: primary-color;
}

.taskCard #dateBox .label {
    -fx-text-fill: font-color; 
}

.taskCard .label {
    -fx-text-fill: #444;
}

.taskCard .titleLabel {
    -fx-font-size: 16pt;
    -fx-font-family: "Roboto Medium";
}

.taskCard .descriptionLabel {
    -fx-font-size: 12pt;
}

.taskCard .footnoteLabel {
    -fx-font-size: 10pt;
    -fx-font-style: italic;
    -fx-padding: 0 0 2 2;
}

.taskCard .highlightedBackground {
    -fx-background-color: #00A4FF;
}

.taskCard.event .highlightedBackground {
    -fx-background-color: #ff9800;
}

.taskCard .lightBackground {
    -fx-background-color: #777777;
}

.taskCard .roundLabel {
    -fx-text-fill: rgba(255, 255, 255, .9);
    -fx-padding: 1 8 2;
}

.taskCard .pinImage {
    -fx-image: url("../images/star_gold.png");
    -fx-fit-to-width: 30px;
    -fx-fit-to-height: 30px;
}

.taskCard .dateImage {
    -fx-image: url("../images/clock_black.png");
    -fx-fit-to-width: 20px;
    -fx-fit-to-height: 20px;
}

.taskCard .locationImage {
    -fx-image: url("../images/location_black.png");
    -fx-fit-to-width: 20px;
    -fx-fit-to-height: 20px;
}

/*Completed*/
.completed, 
.event.overdue {
    -fx-opacity: 0.4;
}

.completed.selected, 
.event.overdue.selected {
    -fx-opacity: 0.85;
}

.completed .label, 
.event.overdue .label {
    -fx-text-fill: font-color;
}

.completed .roundLabel,
.event.overdue .roundLabel {
    -fx-background-color: font-color;
    -fx-text-fill: #fff;
}

.completed .pinImage,
.event.overdue .pinImage {
    -fx-image: url("../images/star_grey.png");
}

.completed .dateImage,
.event.overdue .dateImage {
    -fx-image: url("../images/clock_grey.png");
}

.completed .locationImage,
.event.overdue .locationImage {
    -fx-image: url("../images/location_grey.png");
}

.completed .titleLabel .text {
    -fx-strikethrough: true;
}

/* Overdue and ongoing inverts their highlights their dateBox, so 
   we add some padding to allow the */
.overdue.task #dateBox, 
.ongoing #dateBox {
    -fx-padding: 3 8;
    -fx-background-radius: 4;
}

.overdue.task .dateImage, 
.ongoing .dateImage, 
.taskCard.selected .dateImage {
    -fx-image: url("../images/clock_white.png");
}

/*Overdue*/
.overdue.task {
    primary-color: #e53935;
    selected-color: #b71c1c;
    font-color: rgba(255, 255, 255, .92);
}

```
###### \resources\style\DefaultStyle.css
``` css
/*Selected*/
.taskCard.selected {
    font-color: rgba(255, 255, 255, .9);
    -fx-background-color: selected-color;
}

.taskCard.selected .label {
    -fx-text-fill: font-color;
}

.taskCard.selected .roundLabel {
    -fx-background-color: #fff;
    -fx-text-fill: selected-color;
}

.taskCard.selected .pinImage {
    -fx-image: url("../images/star_white.png");
}

.taskCard.selected .locationImage {
    -fx-image: url("../images/location_white.png");
}

/*Collapse*/
.collapsed .collapsible {
    visibility: collapse;
    -fx-pref-height: 0;
    -fx-min-height: 0;
}

/***TaskCardView Styles End***/
```
